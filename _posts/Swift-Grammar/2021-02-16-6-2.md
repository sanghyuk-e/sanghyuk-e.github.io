---
title : "CHAPTER06: 옵셔널 - 2. 옵셔널 값 처리"
excerpt: "스위프트 문법 스터디"
tagline: "스위프트 문법 스터디"
header:
  teaser: /assets/images/posts/Swift-Grammar/swift.png
  overlay_image: /assets/images/posts/Swift-Grammar/swift.png
  overlay_filter: 0.5
  
categories:
    - Swift-Grammar
tags:
    - Swift
    - Swift-Grammar
    - 꼼곰한 재은 씨의 스위프트:문법편
    - 이재은
    - 루비페이퍼
    - ISBN:979-11-86710-23-4

// 목차
toc: true
toc_sticky: true
---

![Swift](/assets/images/posts/Swift-Grammar/swift.png)

# 2. 옵셔널 값 처리

문자열을 숫자로 변환해주는 생성자 Int(문자열) 이야기를 조금 더 해보자. 숫자로 바꿀 수 있는 문자열 `"123"`이 입력되면 숫자로 변환할 수 있지만, 그럴 수 없는 일반 문자열이 입력되면 잠재적인 오류 가능성이 있다고 설명했다. 이 때문에 Int(문자열)은 그냥 정수가 아니라 옵셔널 타입의 정수값을 반환하도록 설계되어 있다. Int 구조체의 생성자를 정의하는 구문 일부를 살펴보면 알 수 있다.

```swift
extension Int {
    public init?(_ text: String, radix: Int = default)
}
```

Int(문자열) 구문이 반환하는 옵셔널 타입을 분석해보면, ```"안녕하세요"```처럼 숫자로 바꿀 수 없는 문자열이 입력되었을 떄 옵셔널 타입에는 nil이 할당된 상태로 반환된다. 다른 문자열이 입력되어 변환에 성공하면 Optional(123)이라는 옵셔널 값이 할당된다. 어쨋거나 두 경우 모두 옵셔널 타입으로 반환되는 것만은 분명하다.

이렇게 전달받은 옵셔널 타입의 결과값은 그 자체로는 아무것도 할 수 없다. 옵셔널 타입은 애초에 연산을 지원하지 않는 타입이다. 따라서 옵셔널 타입과 일반 타입은 서로 연산할 수 없으며 옵셔널 타입끼리의 연산이나 결합도 지원하지 않는다. 옵셔널 Int 타입과 일반 Int 타입의 연산도, 옵셔널 String과 일반 String 결합도 모두 불가능하다.

```swift
// ( x ) : 옵셔널 타입은 결합 연산 또는 더하기 연산이 가능한 데이터 타입이 아님
Int("123") + Int("123")

// ( x ) : Int? 와 Int 는 서로 다른 타입이므로 연산이 불가능함
Int("123") + 30
```

이 옵셔널 값을 그대로 사용하는 방법을 알아보자. 우리가 결과값으로 전달받은 것은 Optional이라는 객체이다. 그 내부에 우리가 원하는 값이 들어있을 것이다. 이 값을 우리가 원하는 대로 사용하려면 실제 값을 둘러싼 옵셔널 객체를 해제해야 한다. 옵셔널 객체를 해제하면 일반 타입의 값이 되는데, 이 값이 비로소 우리가 직접 사용할 수 잇는 값이다. 이처럼 옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 옵셔널 해제라고 한다. 다른 말로 옵셔널 언래핑(Optional Unwrapping)이라고도 한다.

[![옵셔널 타입의 값을 연산에 사용할 수 있도록 처리하는 과정](/assets/images/posts/Swift-Grammar/2021-02-05-6-1/5.png)](/assets/images/posts/Swift-Grammar/2021-02-05-6-1/5.png)

옵셔널 해제 방식은 **명시적 해제**와 **묵시적 해제**로 나누어진다. 명시적 해제는 다시 **강제적인 해제**와 **비강제적인 해제**로 나눌 수 있고 묵시적 해제는 각각 **컴파일러에 의한 자동 해제**와 **연산자를 이용한 자동 해제**로 나눌 수 있다.

[![옵셔널 해제 방식](/assets/images/posts/Swift-Grammar/2021-02-05-6-1/6.png)](/assets/images/posts/Swift-Grammar/2021-02-05-6-1/6.png)

차례대로 각 해제 방법에 대해 알아보자. 우선 학습할 것은 명시적 해제, 특히 가장 많이 사용되는 강제 해제이다. 강제 해제는 옵셔널 값의 nil 여부와 관계없이 옵셔널을 무조건 해제하는 방식으로, 스위프트 공식 문서에서 사용하는 용어로는 Forced Unwrapping이다. 정확한 의미로는 옵셔널을 벗겨내는 것이지만, 이 강의에서는 편의상 강제 해제라고 부르겠다.

## 2.1 옵셔널 강제 해제

옵셔널을 강제 해제하는 방법은 무척 단순하다. 옵셔널 타입의 값 뒤에 `!`기호만 붙여주면 된다. 이렇게 처리해 주면 옵셔널 객체가 해제되고, 그 내부에 저장된 값을 꺼내 사용할 수 있게 된다. 이때 사용된 `!` 기호를 가리켜 옵셔널에 대한 '강제 해제 연산자(Forced-Unwrapping Operator)'라고 한다. 이와 관련된 다음 예제를 살펴보자. 옵셔널 Int 타입으로 선언된 optInt를 강제 해제 연산자를 사용하여 값을 추출하는 구문이다.

```swift
// 옵셔널 타입의 변수 선언
var optInt: Int? = 3

print("옵셔널 자체의 값 : \(optInt)")
print("!로 강제해제한 값 : \(optInt!)")
```

다음은 위 구문을 실행한 결과이다.

```
옵셔널 자체의 값 : Optional(3)
!로 강제해제한 값 : 3
```

뱐수 optInt를 Int 타입으로 정의하면서 `?`를 붙여 옵셔널 타입으로 선언했다. 옵셔널 타입에 대입된 값은 옵셔널 객체로 감싸 처리되므로, 변수 자체를 출력하면 'Optional(3)'이라는 값이 출력된다. 이어서 두 번째 print 구문을 살펴보자. optInt 뒤에 `!` 연산자를 붙였더니 3이 출력되었다. 이는 옵셔널 타입의 값이 ! 연산자 덕분에 해제되었기 때문이다. 이처럼 옵셔널 타입으로부터 값을 추출하려면 옵셔널 값 뒤에 ! 연산자를 붙이면 된다. 앞에서 옵셔널 타입끼리 연산은 불가능하다고 이야기했지만, 강제 해제 연산자를 사용하면 일반 타입으로 해제되므로 연산이 가능하다.

```swift
Int("123")! + Int("123")! // 246
Int("123")! + 30 // 153
```

여기서 이상한점이 있다. 옵셔널 타입의 변수나 상수에 ! 연산자만 붙이면 일반 타입처럼 사용할 수 있는 앞서 설명대로라면 그냥 모든 옵셔널 타입에 ! 연산자를 붙여서 사용해버리면 되는것이다. 게다가 옵셔널 변수의 값이 nil일 때도 강제 해제 연산자를 붙일수는 있는데, 실제로 값이 nil인 옵셔널 변수에 이 연산자를 붙이면 오류가 발생한다. 이렇게 된다면 굳이 힘들게 옵셔널 타입을 사용하는 의미가 있을까?

그래서 옵셔널 변수나 상수를 안전하게 사용하려면 조건이 따른다. 강제 해제 연산자를 사용할 때에는 먼저 옵셔널 값이 nil인지 점검해야 한다. 그리고 옵셔널 값이 nil이 아닐 떄에만 강제 해제 연산자를 붙여서 값을 추출해야 한다. 다음 구문을 보자.

```swift 
var str = "123"
var intFromStr = Int(str)

if intFromStr != nil {
    print("값이 변환되었습니다. 변환된 값은 \(intFromStr!)입니다.") // ①
} else {
    print("값 변환에 실패하였습니다.") // ②
}
```

앞서 여러 차례 설명한 바와 같이 Int(문자열) 생성자는 옵셔널 정수값을 반환한다. 따라서 위 예제에서 Int(문자열)의 결과를 대입받는 intFromStr 상수 역시 옵셔널 타입으로 정의된다. 옵셔널은 값이 없는 nil이거나 정상적인 값을 옵셔널 객체로 둘러싼 두 가지 경우만 존재하므로 옵셔널 값이 nil인지를 if 조건절로 점검해야 한다. 그리고 그에 맞는 조건절 블록 내에서만 강제 해제 연산자를 사용해야 한다. 이것이 오류 없이 안전하게 옵셔널 타입을 해제하여 사용할 수 있는 방법이다.

위 예제에서 Int(문자열) 생성자의 변환 대상이 되는 문자열 "123"은 숫자로 변환할 수 있는 문자열이므로 intFromStr은 nil이 아니다. 정확히는 Optional(123)이다. 따라서 if 조건절이 참이 되면서 ①의 내용이 실행되므로 실행 결과는 다음과 같다.

```
값이 변환되었습니다. 변환된 값은 123입니다.
```

만약 대입된 값이 숫자로 변환할 수 없는 "Swift" 문자열이라면 어떻게 실행될까?

```swift 
var str = "Swift"
var intFromStr = Int(str)

if intFromStr != nil {
    print("값이 변환되었습니다. 변환된 값은 \(intFromStr!)입니다.") // ①
} else {
    print("값 변환에 실패하였습니다.") // ②
}
```

입력된 문자열은 Int(<문자열>)을 통해 숫자로 변환할 수 없는 값이므로 실행 결과는 nil이다. if 조건절이 거짓이므로 else 블록 영역인 ②가 실행된다. 따라서 결과는 다음과 같다. 

```
값 변환에 실패하였습니다.
```

else 블록에서 ! 연산자를 사용하면 nil에 대한 옵셔널 강제 해제가 실행되어 오류가 발생한다. 따라서 ! 연산자는 확실히 옵셔널의 값이 nil이 아닌 조건에서만 사용해야 한다.

위 구문에서 주의 깊게 살펴보아야 할 부분이 있다. if에서 nil 값을 비교하는 데 사용된 조건절이다.

```swift
intFromStr != nil
```

이 조건절에서 intFromStr와 비교연산자 != 사이에 의도적인 공백이 있음을 알아야 한다. 이 공백은 단순히 가독성을 높이기 위해 추기된 것이 아니다. 일반적으로 연산자 앞에 공백이 있을 필요는 없다. 일부는 가독성을 위해 공백을 집어넣기도 하지만 그것은 습관일 뿐, 컴파일러의 규칙상 반드시 그래야 하는 것은 아니다.

그런데 이번처럼 옵셔널 타입의 nil 점검을 위한 != 연산자를 사용할 때는 반드시 앞에 공백을 두어야 한다. 문법의 오류를 방지하기 위한 목적이다. intFromStr 변수처럼 옵셔널 타입의 값을 비교 연산자와 함께 사용하면서 공백을 두지 않으면 컴파일러는 이 구문을 다음 두 가지로 해석할 수 있다. 

```swift
intFromStr!=nil

// 해석 ① : (intFromStr)!=(nil) -> 원래 의도한 대로 intFromStr 변수와 nil의 비교
// 해석 ② : (intFromStr)=nil -> intFromStr 변수의 옵셔널 강제 해제 + nil 값의 할당
```

결국, 해석의 차이가 발생할 수 있으므로 구문이 모호해지는 결과를 가져온다. 컴파일러는 이를 확실하게 해석하지 못하므로 구문 분석 오류가 발생하게 된다. 이러한 상황을 방지하기 위해 옵셔널 타입이 비교 대상이라면 부등 비교 연산자(!=)를 사용할 때 공백을 두어야 한다. '아버지가방에들어가십니다'가 생각나는, 의외로 띄어쓰기가 중요해지는 이야기라고 할 수 있겠다.

## 2.2 옵셔널 바인딩

앞에서 우리는 nil 체크 조건절을 사용하여 안전하게 옵셔널 타입을 해제할 수 있었다. 이 예제는 동일한 기능을 하는 비강제적인 해제 구문으로 바꾸어 작성이 가능하다. 이는 if 구문 내에서 조건식 대신 옵셔널 값을 일반 변수나 상수에 할당하는 구문을 사용하는 방식으로, **옵셔널 바인딩(Optional Binding)**이라고 한다.

옵셔널 바인딩은 **조건문 내에서 일반 상수에 옵셔널 값을 대입하는 방식**으로 이루어진다. 반드시 조건문에서 사용해야만 하며, 상수에 옵셔널 값을 대입한 결과는 true/false 로 리턴된다. 우리가 배운 대표적인 조건절인 if를 사용하여 옵셔널 바인딩하는 예제를 살펴보자.

```swift
var str = "Swift"
if let intFromStr = Int(str) {
    print("값이 변환되었습니다. 변환된 값은 \(intFromStr)입니다.")
} else {
    print("값 변환에 실패하였습니다.")
}
```

앞의 구문과 매우 비슷하지만, infFromStr가 상수로 선언되었다는 점과 이 상수가 옵셔널이 아닌 일반 타입이라는 점이 다르다. 강제 해제 연산자를 사용하지 않아도 옵셔널 값이 일반 변수나 상수에 할당되면서 자연스럽게 옵셔널 타입이 해제되지만, 값이 nil이더라도 값의 할당이 실패하여 결과값이 false로 반환될 뿐이므로 오류는 발생하지 않는다. 단지 else 블록이 실행 될 뿐이다. 또다른 구문 하나를 보자.

```swift
func intStr(str: String) {
    guard let intFromStr = Int(str) else {
        print("값 변환에 실패하였습니다.")
        return
    }

    print("값이 변환되었습니다. 변환된 값은 \(intFromStr)입니다.")
}
```

위 구문은 guard 구문을 이용하여 옵셔널 바인딩을 구현한 예제이다. guard 구문은 특성상 함수나 메소드에만 사용할 수 있기 때문에 intStr() 함수를 정의하고 그 안에 guard 구문을 작성하였다. 실제로 앱을 만드는 과정 거의 대부분은 함수로 이루어지기 때문에, guard 구문을 사용할 여지는 많다.

guard 구문을 사용하더라도 옵셔널 바인딩 방식은 동일하다. 상수를 선언하고, 여기에 옵셔널 값을 대입하는 것이 전부다. 하지만 사용 용법상 if 구문 내에서 옵셔널 바인딩을 사용하는 것과 구분해야 할 필요는 있다. if 구문을 사용한 옵셔널 바인딩은 단순히 옵셔널 값의 처리 결과에 따라 서로 다른 피드백을 주고 싶을 때 사용한다. 하지만 guard 구문은 조건에 맞지 않으면 무조건 함수의 실행을 종료시키는 특성이 있기 때문에, 실행 흐름상 옵셔널 값이 해제되지 않으면 더 이상 진행이 불가능할 정도로 큰일이 생길 때에만 사용하는 것이 좋다. 참고로, 옵셔널 타입이긴 하지만 절대 nil 값이 들어가지 않을 것이라는 보장이 있을 때에는 강제 해제 연산자를 사용하여 옵셔널 타입을 처리하는 것이 효율적이다.


(작성중)

--- 

<br/>
<center>
<a href="https://sanghyuk.dev/swift-grammar/6-1/" class="btn btn--info">이전 내용 보기</a>
<a href="https://sanghyuk.dev/ios/2/" class="btn btn--success">iOS 면접 질문 목록 보기</a>
<a href="https://sanghyuk.dev/swift-grammar/7-1/" class="btn btn--info">다음 내용 보기</a>
</center>