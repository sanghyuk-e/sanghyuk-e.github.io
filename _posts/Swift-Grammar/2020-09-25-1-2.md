---
title : "CHAPTER01: 스위프트 - 2.스위프트 언어의 특징"
excerpt: "스위프트 문법 스터디"
tagline: "스위프트 문법 스터디"
header:
  teaser: /assets/images/posts/Swift-Grammar/swift.png
  overlay_image: /assets/images/posts/Swift-Grammar/swift.png
  overlay_filter: 0.5
  
categories:
    - Swift-Grammar
tags:
    - Swift
    - Swift-Grammar
    - 꼼곰한 재은 씨의 스위프트:문법편
    - 이재은
    - 루비페이퍼
    - ISBN:979-11-86710-23-4
toc: true
toc_sticky: true
---

![Swift](/assets/images/posts/Swift-Grammar/swift.png)

# 2. 스위프트 언어의 특징

상대적으로 언어에 대한 진입장벽이 낮고 개발하기 쉬운 자바스크립트나 파이썬, 루비와 같은 동적 바인딩 타입의 언어는 생산성이 좋지만 성능이 부족한 경우가 많고, 성능이 좋은 언어일수록 진입 장벽이 높고 개발하기 어려워 생산성이 낮은 경우가 많다. 이에 비해 스위프트는 개발 생산성과 앱 성능 모두에서 만족할 만한 결과를 가져오는 언어로 포지셔닝되어있다.

스위프트가 파이썬이나 자바스크립트처럼 동적 바인딩(Dynamic Binding)을 채용하고 있는 언어는 아니다. C, C++, 오브젝티브-C, 자바처럼 정적 바인딩을 채용하고 있다. 비록 데이터 타입 추론 기능에 의해 컴파일러가 알아서 변수와 상수의 타입을 결정하기 때문에 마치 동적 바인딩 언어인 것처럼 착각되기도 하지만, 기본적으로 스위프트는 정적 바인딩 언어이다.

스위프트는 데이터 타입에 대한 구분이 엄격하다. 스위프트에서 선언된 변수와 상수는 컴파일 단계에서 데이터 타입이 미리 정의되어 있어야 하고, 변수의 데이터 타입이 정의되면 다른 타입으로 변경할 수 없다. 이러한 엄격성을 바탕으로 컴파일러는 타입에 맞지 않는 데이터가 변수에 대입되는 것을 사전에 차단하여 안정성을 높일 수 있다. 

스위프트는 네임스페이스를 사용하여 필요한 객체들으 참조하는데, 일반적으로 프로젝트 전체가 네임스페이스의 범위로 지정된다. 이는 같은 프로젝트 내에 작성된 객체일지라도 오브젝티브-C에서는 참조를 위해 일일이 헤더 파일을 반입해 주어야 했던 것과 다르게, 스위프트에서는 같은 프로젝트 내에 작성된 객체들은 반입 과정 없이 참조할 수 있다는 뜻이다. 이 때문에 스위프트에서 import 구문은 UIKit, Foundation 등의 프레임워크나 라이브러리 정도에만 사용하게 되어 개발 생산성을 향상할 수 있게 되었다.

## 2.1 스위프트 언어에서 차용하고 있는 주요 기능들 

세상에 존재하는 수많은 프로그래밍 언어 대부분이 그렇겠지만, 특히 현대에 와서 발표되는 언어 중 전적으로 새로운 언어는 거의 없다고 해도 과언이 아니다. 대부분의 언어는 앞선 시대의 언어에서 아이디어를 차용하여 자신의 것으로 발전시키고, 시간이 지나면 또 다른 언어가 이를 차용하는 과정이 반복된다.

기술적으로 새롭다고 할 수 있는 스위프트이지만, 사실 알고 보면 다른 언어에서 채택된 개념들을 새로운 이름으로 조합한 것에 지나지 않는다. 이런 관점에서 마국의 IT 전문 저술가 피터 웨이너(Peter Wayner)는 InfoWorld.com에서 애플이 스위프트를 만들면서 주변 언어로부터 차용한 10가지 개념과 특징들에 관해 이야기 하고 있다. 이 글을 인용하여 스위프트의 특성을 다른 언어들과 비교해 보겠다. 다른 언어를 익힌 분들이라면 이 설명을 통해 스위프트의 특징에 대해 더욱 잘 이애할 수 있을 것이다.

### 2.1.1 딕셔너리(해시 테이블) - 자바스크립트, 파이썬

자바스크립트 프로그래머들은 대괄호 구문을 이용해 값을 배열로 만들거나 문자열을 입력받는데, 이것이 해시 테이블 역할을 한다. 스위프트도 마찬가지이다. 대괄호를 사용하여 해시 테이블을 만들 수 있다. 애플에서는 이것을 '딕셔너리(Dictionaries)'라고 부르며, 초기화할 수 있는 구문을 제공한다.

```swift
var airports = [String : String?]()
airports["ICN"] = "Inchon International Airport"
// If close "Inchon International Airport", then delete it
airports["ICN"] = nil
// ICN has now benn removed from the dictionary
```

### 2.1.2 데이터 타입 추론 - 함수형 프로그래밍 언어

프로그래머 관점에서 변수를 특정 데이터 형식으로 강제하면 코드를 실행해 보기 전에 버그를 미리 잡을 수 있어 효율적이다. 컴파일러가 데이터 형식을 확인하고 비호환성이 발견되면 오류를 검출해주기 때문이다. 편리함을 추구하는 프로그래밍에서 모든 변수마다 데이터 형식을 일일이 지정하는 고생을 감수할 사람은 그다지 많지 않다.

최근의 우수한 컴파일러들은 데이터로부터 스스로 형식을 추론할 수 있으므로 컴파일러가 알아서 변수에 데이터 형식을 지정할 수 있게 되었다. 이러한 움직임은 ML과 같은 함수형 언어부터 시작 됐으며, 이후 하스켈, 스칼라, 오파 등의 언어에도 등장했다. 마이크로소프트까지도 이같은 추론 기능을 닷넷 프레임워크에 추가한 만큼 이제는 주류 기능이라고 할 만하다. 데이터 타입은 강제하지만, 데이터 타입을 생략할 수 있는 스위프트 컴파일러의 발전 덕분에 iOS 개발자들도 이제 코드 입력에 드는 수고를 조금은 덜 수 있게 되었다.

```swift
let meaningOfLife = 42
// meaningOfLife is inferred to be of type Int
```

### 2.1.3 자동 참조(가비지 콜렉터 비슷) - 자바, C#, 오브젝티브-C

가비지 콜렉터는 메모리를 탐색하면서 더는 사용되지 않는 메모리 영역을 회수하는 자동 루틴으로, GC라고 불리기도 한다. 자바와 C# 프로그래머들은 가비지 콜렉터를 무척 좋아하지만, 때로는 가비지 콜렉터 때문에 프로그램이 잠깐 멈추는 현상이 발생해 스트레스를 받기도 한다. 가비지 콜렉터의 결과로 가용 메모리가 다시 늘어나는 장점이 있는 반면, 가비지 콜렉터를 실핼하는 동안 프로세스는 원활한 진행을 방해받는다는 단점도 있다.

스위프트는 자동 참조 카운트(ARC - Auto Referencing Counter)를 사용하는데, 이는 오브젝티브-C 사용자들 사이에서 널리 사용된 것과 비슷한 솔루션이다. 이 기능은 오브젝티브-C에서 물려받았다고 할 만한 기능이다.

### 2.1.4 부호 있는 정수와 부호 없는 정수 - C#과 오브젝티브-C

좋은 시스템 프로그램이란 바이트 레벨에서 작동하는 프로그랴ㅐㅁ을 의미하는 경우가 많다. 자바와 같은 일부 추상적 언어는 부호 없는 정수의 복잡성을 회피했지만, C# 언어는 이를 수용했다. 스위프트 역시 1, 2, 4, 8바이트의 부호 없는 정수와 부호 있는 정수를 제공한다.

```swift
let pink: UInt32 = 0xCC6699

let redComponent = (pink & 0xFF0000) >> 16
// redComponent is 0xCC, or 204

let greenComponent = (pink & 0x00FF00) >> 8
// greenComponent is 0x66, or 102

let blueComponent = pink & 0x0000FF
// blueComponent is 0x99, or 153
```

### 2.1.5 클로저(Closure) - 리스프와 스킴에서 자바스크립트까지

자바스크립트 프로그래머는 소량의 코드를 묶어서 함수처럼 전달하는 클로저를 사용할 수 있다. 이러한 클로저는 람다 함수 아이디어를 개발한 리스프, 스킴과 같은 언어에서 가져온 것이다. 스위프트는 클로저를 제공할 뿐만 아니라 함수를 1급 객체로 간주, 인자값으로 함수 자체를 전달하는 기능을 제공한다.

```swift
let numbers = [Int]()

numbers.map({
    (number:Int) -> Int in
    let result = 3 * number
    return result
})
```

### 2.1.6 멀티 라인 쿼우팅(Multi-Line Quoting)

파이썬 프로그래머들은 세 개의 따옴표를 겹친 """ ~ """ 를 이용해 여러 줄의 문자열을 간편하게 입력해 왔다. 줄바꿈이나 범위에 삼관없이 """로 시작하고 """로 닫기만 하면 그 안에 표현된 모든 문자열(공백까지 포함한)이 그대로 처리된다는 장점 덕분에 긴 문자열을 입력할 때 요긴하게 사용되어 왔다. 스위프트 4 버전에서는 파이썬의 이와 같은 멀티 라인 쿼우팅 문법을 거의 그대로 도입했다. 파이썬처럼 큰따옴표 세 개 겹친 """로 문자열의 시작과 끝을 나타내는 방식으로 우리는 여러 줄의 문자열을 간편하게 입력할 수 있게 되었다. 이는 여러 줄의 문자열을 입력하기 위해 더이상 문자열 내부에 인위적인 줄바꿈 문자('\n')를 넣어주지 않아도 된다는 뜻이다.

```swift
let query = """
    SELECT member_id, member_name, member_level, nick_name
    FROM member
    WHERE login_id = ? AND password = ?
"""
```

---

## 2.2 구조적 특징

스위프트의 발표 자료에 따른 스위프트 언어의 구조적 특징은 여섯 가지 정도로 구분된다. 이들 특성은 스위프트가 지향하는 방향성이기도 하다.

### 2.2.1 빠름(Fast)

스위프트는 매우 빠른 언어로, 복합정렬 연산에서 오브젝티브-C보다 빠른 성능을 나타낸다. 애플에서는 고성능 앱을 만들기 위해 GCC 대신 LLVM 컴파일러를 사용해오고 있는데, 이 컴파일러에서 제공하는 코드 최적화기를 사용하여 소스 컴파일과 최적화를 수행함으로써 스위프트의 성능을 극대화할 수 있다.

### 2.2.2 설계에 의한 안정성(Safety by Design)

스위프트는 언어 차원에서 안전성을 담보하기 위한 설계로 여러 장치를 해 두었다. 변수나 상수는 반드시 선언한 후에 사용하도록 강제하였으며 타입 추론 기능에 의해 변수의 초기값을 기준으로 타입을 정의함으로써 데이터 입력에 대한 안전성을 높이고자 하였다. 배열과 정수는 오버플로우에 대비하여 확인하며, 특히 개발자가 정의하지 않은 배열 값에 승인하지 않은 값들이 주입될 수 없도록 Array bounds check 기능을 추가하였다.

여기에 더하여 스위프트는 포인터에 직접 접근하는 시도를 차단하고, 클래스를 통해 간접적으로만 레퍼런스를 참조할 수 있도록 제한했다. 스위프트는 ARC를 이용하여 자동으로 메모리를 관리하므로 메모리 누수 현상에 대한 안전성도 높일 수 있다. 이처럼 설게 수준에서 안전성을 구현하는 것이 스위프트의 구조적 특징 중 하나이다.

### 2.2.3 현대적(Modern)

스위프트는 파이썬 언어에 기반을 둔 읽고 쓰기 쉬운 문법을 채택하였다. 그 결과, 코드 작성이나 디버깅, 유지보수 과정에서 기존의 오브젝티브-C보다 훨씬 적은 양의 코드가 사용된다. 손쉬운 유지보수를 위해 헤더 파일 사용 대신 메인 파일에 통합하여 코드를 작성할 수 있도록 섳계되었다. 스위프트는 옵셔널(Optional), 제네릭(Generics), 클로저(Closure), 튜플(Tuple)뿐만 아니라 현대 프로그래밍 언어의 특성까지도 상당수 포함하고 있다. 

### 2.2.4 상호반응(Interactive)

Xcode 6 버전부터 애플은 스위프트 코드의 프로토타이핑을 위해 플레이그라운드 편집기를 제공한다. 스위프트 코드를 작성하고, 그 결과와 메모리 스택 등의 정보 확인을 즉시 확인할 수 있어 상호반응적으로 코드를 작성할 수 있으며 디버깅도 무척 쉽다. 이러한 특징은 스위프트를 이용한 코딩의 효율성을 한껏 높였다. 

### 2.2.5 완전한 플랫폼(Complete Platform)

단순히 보조적인 수준으로만 스위프트를 사용할 수 있는 것이 아니라, 코코아 프레임워크나 코코아 터치 프레임워크의 모든 API를 스위프트로 호출할 수 있다. 오브젝티브-C로 작성되었던ㄴ 핵심 프레임워크의 모든 라인이 스위프트 언어를 이용하여 거의 모두 재작성되었고, 이를 이용하면 오브젝티브-C 코드에 의존하지 않고도 프로그램을 작성할 수 있다는 것은 애플의 발표에 의해 널리 알려진 사실이다. 스위프트만으로 하나의 완전한 앱을 만들 수 있다는 의미이다.

### 2.2.6 통홥(Unified)

스위프트는 C 언어나 오브젝티브-C 언어를 완전히 대체할 수 있다. 스위프트는 객체지향 언어의 특성을 모두 제공하는 동시에 자료형과 흐름 제어, 연산자 같은 저수준 언어의 기본 요소들도 모두 포함한다. 하나의 앱 프로젝트에서 오브젝티브-C와 함께 사용할 수 있도록 통합성도 지니고 있다. 오브젝티브-C 객체를 스위프트에서 참조할 수 있으며, 각각의 화면별로 오브젝티브-C 또는 스위프트로 나누어 작성하는 것도 가능하디.

---

<br/>
<center>
<a href="https://sanghyuk.dev/swift-grammar/1-1/" class="btn btn--info">이전 내용 보기</a> 
<a href="https://sanghyuk.dev/swift-grammar/1-3/" class="btn btn--info">다음 내용 보기</a>
</center>