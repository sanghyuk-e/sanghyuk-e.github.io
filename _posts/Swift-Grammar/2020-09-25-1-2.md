---
title : "CHAPTER01:스위프트 - 2.스위프트 언어의 특징"
excerpt: "스위프트 문법 스터디"

categories:
    - Swift-Grammar
tags:
    - Swift
    - Swift-Grammar
    - 꼼곰한 재은 씨의 스위프트:문법편
    - 이재은
    - 루비페이퍼
    - ISBN:979-11-86710-23-4
toc: true
toc_sticky: true
---

## 2. 스위프트 언어의 특징

상대적으로 언어에 대한 진입장벽이 낮고 개발하기 쉬운 자바스크립트나 파이썬, 루비와 같은 동적 바인딩 타입의 언어는 생산성이 좋지만 성능이 부족한 경우가 많고, 성능이 좋은 언어일수록 진입 장벽이 높고 개발하기 어려워 생산성이 낮은 경우가 많다. 이에 비해 스위프트는 개발 생산성과 앱 성능 모두에서 만족할 만한 결과를 가져오는 언어로 포지셔닝되어있다.

스위프트가 파이썬이나 자바스크립트처럼 동적 바인딩(Dynamic Binding)을 채용하고 있는 언어는 아니다. C, C++, 오브젝티브-C, 자바처럼 정적 바인딩을 채용하고 있다. 비록 데이터 타입 추론 기능에 의해 컴파일러가 알아서 변수와 상수의 타입을 결정하기 때문에 마치 동적 바인딩 언어인 것처럼 착각되기도 하지만, 기본적으로 스위프트는 정적 바인딩 언어이다.

스위프트는 데이터 타입에 대한 구분이 엄격하다. 스위프트에서 선언된 변수와 상수는 컴파일 단계에서 데이터 타입이 미리 정의되어 있어야 하고, 변수의 데이터 타입이 정의되면 다른 타입으로 변경할 수 없다. 이러한 엄격성을 바탕으로 컴파일러는 타입에 맞지 않는 데이터가 변수에 대입되는 것을 사전에 차단하여 안정성을 높일 수 있다. 

스위프트는 네임스페이스를 사용하여 필요한 객체들으 참조하는데, 일반적으로 프로젝트 전체가 네임스페이스의 범위로 지정된다. 이는 같은 프로젝트 내에 작성된 객체일지라도 오브젝티브-C에서는 참조를 위해 일일이 헤더 파일을 반입해 주어야 했던 것과 다르게, 스위프트에서는 같은 프로젝트 내에 작성된 객체들은 반입 과정 없이 참조할 수 있다는 뜻이다. 이 때문에 스위프트에서 import 구문은 UIKit, Foundation 등의 프레임워크나 라이브러리 정도에만 사용하게 되어 개발 생산성을 향항할 수 있게 되었다.

---

### 2.1 스위프트 언어에서 차용하고 있는 주요 기능들 

세상에 존재하는 수많은 프로그래밍 언어 대부분이 그렇겠지만, 특히 현대에 와서 발표되는 언어 중 전적으로 새로운 언어는 거의 없다고 해도 과언이 아니다. 대부분의 언어는 앞선 시대의 언어에서 아이디어를 차용하여 자신의 것으로 발전시키고, 시간이 지나면 또 다른 언어가 이를 차용하는 과정이 반복된다.

기술적으로 새롭다고 할 수 있는 스위프트이지만, 사실 알고 보면 다른 언어에서 채택된 개념들을 새로운 이름으로 조합한 것에 지나지 않는다. 이런 관점에서 마국의 IT 전문 저술가 피터 웨이너(Peter Wayner)는 InfoWorld.com에서 애플이 스위프트를 만들면서 주변 언어로부터 차용한 10가지 개념과 특징들에 관해 이야기 하고 있다. 이 글을 인용하여 스위프트의 특성을 다른 언어들과 비교해 보겠다. 다른 언어를 익힌 분들이라면 이 설명을 통해 스위프트의 특징에 대해 더욱 잘 이애할 수 있을 것이다.

> 딕셔너리(해시 테이블) - 자바스크립트, 파이썬

자바스크립트 프로그래머들은 대괄호 구문을 이용해 값을 배열로 만들거나 문자열을 입력받는데, 이것이 해시 테이블 역할을 한다. 스위프트도 마찬가지이다. 대괄호를 사용하여 해시 테이블을 만들 수 있다. 애플에서는 이것을 '딕셔너리(Dictionaries)'라고 부르며, 초기화할 수 있는 구문을 제공한다.

```swift
var airports = [String : String?]()
airports["ICN"] = "Inchon International Airport"
// If close "Inchon International Airport", then delete it
airports["ICN"] = nil
// ICN has now benn removed from the dictionary
```

> 데이터 타입 추론 - 함수형 프로그래밍 언어

프로그래머 관점에서 변수를 특정 데이터 형식으로 강제하면 코드를 실행해 보기 전에 버그를 미리 잡을 수 있어 효율적이다. 컴파일러가 데이터 형식을 확인하고 비호환성이 발견되면 오류를 검출해주기 때문이다. 편리함을 추구하는 프로그래밍에서 모든 변수마다 데이터 형식을 일일이 지정하는 고생을 감수할 사람은 그다지 많지 않다.

최근의 우수한 컴파일러들은 데이터로부터 스스로 형식을 추론할 수 있으므로 컴파일러가 알아서 변수에 데이터 형식을 지정할 수 있게 되었다. 이러한 움직임은 ML과 같은 함수형 언어부터 시작 됐으며, 이후 하스켈, 스칼라, 오파 등의 언어에도 등장했다. 마이크로소프트까지도 이같은 추론 기능을 닷넷 프레임워크에 추가한 만큼 이제는 주류 기능이라고 할 만하다. 데이터 타입은 강제하지만, 데이터 타입을 생략할 수 있는 스위프트 컴파일러의 발전 덕분에 iOS 개발자들도 이제 코드 입력에 드는 수고를 조금은 덜 수 있게 되었다.

```swift
let meaningOfLife = 42
// meaningOfLife is inferred to be of type Int
```

> 자동 참조(가비지 콜렉터 비슷) - 자바, C#, 오브젝티브-C

가비지 콜렉터는 메모리를 탐색하면서 더는 사용되지 않는 메모리 영역을 회수하는 자동 루틴으로, GC라고 불리기도 한다. 자바와 C# 프로그래머들은 가비지 콜렉터를 무척 좋아하지만, 때로는 가비지 콜렉터 때문에 프로그램이 잠깐 멈추는 현상이 발생해 스트레스를 받기도 한다. 가비지 콜렉터의 결과로 가용 메모리가 다시 늘어나는 장점이 있는 반면, 가비지 콜렉터를 실핼하는 동안 프로세스는 원활한 진행을 방해받는다는 단점도 있다.

스위프트는 자동 참조 카운트(ARC - Auto Referencing Counter)를 사용하는데, 이는 오브젝티브-C 사용자들 사이에서 널리 사용된 것과 비슷한 솔루션이다. 이 기능은 오브젝티브-C에서 물려받았다고 할 만한 기능이다.

> 부호 있는 정수와 부호 없는 정수 - C#과 오브젝티브-C

좋은 시스템 프로그램이란 바이트 레벨에서 작동하는 프로그랴ㅐㅁ을 의미하는 경우가 많다. 자바와 같은 일부 추상적 언어는 부호 없는 정수의 복잡성을 회피했지만, C# 언어는 이를 수용했다. 스위프트 역시 1, 2, 4, 8바이트의 부호 없는 정수와 부호 있는 정수를 제공한다.

```swift
let pink: UInt32 = 0xCC6699

let redComponent = (pink & 0xFF0000) >> 16
// redComponent is 0xCC, or 204

let greenComponent = (pink & 0x00FF00) >> 8
// greenComponent is 0x66, or 102

let blueComponent = pink & 0x0000FF
// blueComponent is 0x99, or 153
```
