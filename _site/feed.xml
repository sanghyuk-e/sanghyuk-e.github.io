<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://sanghyuk.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sanghyuk.dev/" rel="alternate" type="text/html" /><updated>2021-09-09T21:17:45+09:00</updated><id>https://sanghyuk.dev/feed.xml</id><title type="html">Sanghyuk’s Blog</title><subtitle>Sanghyuk's Blog</subtitle><author><name>SANGHYUK LEE</name></author><entry><title type="html">Part.1</title><link href="https://sanghyuk.dev/product%20manager/2/" rel="alternate" type="text/html" title="Part.1" /><published>2021-09-02T00:00:00+09:00</published><updated>2021-09-02T00:00:00+09:00</updated><id>https://sanghyuk.dev/product%20manager/2</id><content type="html" xml:base="https://sanghyuk.dev/product%20manager/2/">&lt;h1 id=&quot;part1&quot;&gt;Part.1&lt;/h1&gt;

&lt;p&gt;제품을 만드는 사람들이 밤과 주말을 희생해 가며 오랜 기간 열심히 제품을 만들었다. 제품을 설명하는 자리를 가졌고 좋은 평가를 받았다. 성공을 위한 만반의 준비를 하고 마침내 제품을 출시했다. 그런데 제품은 실패했다. 원인은 제품을 구매하는 사람이 없었기 때문이다. 기술적으로 매우 훌륭한 제품이었고, 전문가들은 극찬을 아끼지 않았다. 하지만 결국 사람들이 원하는 제품이 아니었던 것이다. 여기서 알 수 있는 점은 &lt;strong&gt;만들 만한 가치가 있는 제품이 아니라면 엔지니어 팀이 얼마나 훌륭한지는 아무 의미가 없다는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;여기서 배울 점이 있다. 만들 제품을 정의하는 책임을 진 ‘제품 관리자’라는 사람이 무슨 제품을 만들지에 대한 의사결정을 한다는 것이다. 또 대부분의 회사가 제품 관리에 서툴고, 지금도 마찬가지라는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최고&lt;/strong&gt;의 기업들과 &lt;strong&gt;대부분&lt;/strong&gt; 기업이 제품을 만드는 방식에서 큰 차이가 있다. &lt;strong&gt;최신 기술을 잘 아는 것과 실제로 잘 만드는 것은 매우 다르다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;대부분 기업은 여전히 오래되고 비효율적인 방법으로 제품을 발견하고 출시한다. 학계나 최고 경영대학의 프로그램, 산업 기관 등 모두 과거의 실패한 모델에 갇혀 있다.&lt;/p&gt;

&lt;p&gt;대부분의 제품 리더들은 사람들에게 진정한 가치과 감동을 제공하는, 고객이 사랑하는 제품을 만들기 원한다. 하지만 많은 제품은 감동을 주지 못하며, 우리의 삶은 좋은 제품만을 사용하기에도 모자라다.&lt;/p&gt;

&lt;h2 id=&quot;훌륭한-제품을-이끄는-사람&quot;&gt;훌륭한 제품을 이끄는 사람&lt;/h2&gt;

&lt;p&gt;모든 훌륭한 제품 이면에는 지칠줄 모르고, 무대 뒤에서 최선을 다하는 누군가가 있다. 그 사람은 제품팀을 이끌며, 비즈니스 목표에 맞는 방향으로 기술과 디자인을 통해 고객의 실제 문제를 해결한다. 이런 사람들을 우리는 &lt;strong&gt;제품 관리자(product manager)&lt;/strong&gt;라고 부른다. 이들은 스타트업의 공동 창업자나 대표일 수 있다. 또한, 이미 다른 역할을 가지고 있지만, 필요에 의해 선택된 사람일 수도 있다. 제품 관리자로서 임무를 수행한다는 것은 디자이너, 엔지니어, 마케팅, 프로젝트 매니저의 역할과는 매우 다르다.&lt;/p&gt;

&lt;p&gt;기술 제품을 만드는 팀에서 제품 관리자는 매우 특별하고 도전적인 책임을 지고 일을 한다. 어려운 역할이고, 다른 사람이 어떤 이야기를 해준다고 도움이 되지 않는다. 제품 관리자는 보통 풀타임 업무가 필요하다. 일반적으로 업무를 충실하게 수행하는 제품 관리자는 주 60시간보다 적게 일하는 경우를 찾아보기 힘들다.&lt;/p&gt;

&lt;p&gt;디자이너나 엔지니어로서 제품 관리자의 역할을 동시에 수행하는 것도 충분히 가능하고, 실제로 몇 가지 장점들이 있다. 하지만 어마어마한 업무량을 소화해야 한다.&lt;/p&gt;

&lt;p&gt;제품팀은 적어도 한 명의 제품 관리자 및 두 명에서 최대 10명의 엔지니어로 구성된다. 사용자 접점에 있는 제품을 만드는 경우라면 아마도 팀에 제품 디자이너도 필요할 것이다.&lt;/p&gt;

&lt;p&gt;앞으로의 이야기는 팀의 구성이 어떻게 되었든 제품 관리자라는 역할, 그리고 함께 일하는 전담팀이 있다는 것을 가정한다. 그 팀은 제품을 설계-구현-출시를 위해 함께 업무를 하는 팀을 말한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/ProductManager/1/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/ProductManager/3/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Product Manager" /><category term="Product Manager" /></entry><entry><title type="html">Product Manager</title><link href="https://sanghyuk.dev/product%20manager/1/" rel="alternate" type="text/html" title="Product Manager" /><published>2021-09-01T00:00:00+09:00</published><updated>2021-09-01T00:00:00+09:00</updated><id>https://sanghyuk.dev/product%20manager/1</id><content type="html" xml:base="https://sanghyuk.dev/product%20manager/1/">&lt;h1 id=&quot;product-manager&quot;&gt;Product Manager&lt;/h1&gt;

&lt;p&gt;요즘 기업에서는 많은 팀에 애자일(agile)이 정착되었고, 고객 개발(customer development)과 린 스타트업(lean startup)등의 방법을 수년간 사용하고 있으며, 이제는 린와 애자일을 넘어서는 무언가에 관심을 가지고 있다.&lt;/p&gt;

&lt;p&gt;제품관리의 기법들은 계속 발전해왔다. 기업은 규모를 확장하면서 새로운 도전 과제들에 직면하게 된다. 빠르게 성장하며 생존한다는 것이 얼마나 어려운지를 표현할 때, 생존 그 자체를 ‘성공’이라고 부른다.&lt;/p&gt;

&lt;p&gt;제품 관리자에게는 크게 두 가지의 중요한 주제가 있다.&lt;/p&gt;

&lt;p&gt;첫째, 제품 관리자(product manager)에 대해 구체적으로 알아야 한다. 제품 관리자는 기술 제품(technology-powered)를 책임지는 중요한 사람인데도 잘 모르고 있다. 기술 제품을 만드는 회사의 제품 관리자 혹은 그 일을 희망하는 사람들은 반드시 제품 관리자가 하는 일을 알아야 정확하게 알아야 한다.&lt;/p&gt;

&lt;p&gt;둘째, 고객이 사랑하는 훌륭한 제품을 만드는 지침이나 체계, 비법은 있을 수 있다. 하지만 그것만으로 훌륭한 제품을 만들 수 없다. 제품의 성공을 위해서는 올바른 제품 문화를 만들어야 한다. 또, 제품 발견(product discovery)과 제품 실행(product delivery)에 이르는 일련의 방법들을 이해해야 이슈가 발생하는 상황이 되었을 때 올바른 도구들을 선택할 수 있다. 제품 관리자의 일은 절대 쉽지 않으며, 이 일을 성공적으로 할 수 있도록 준비를 해야 한다.&lt;/p&gt;

&lt;p&gt;이 모든 것을 고려하여 업계에서 제품 관리자는 매우 인기가 높은 직종이다. 특히 스타트업의 대표이사가 되거나 혹은 그러한 자질을 시험할 기회가 되기도 한다.&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/ProductManager/2/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;제품 실행은 제품 발견 단계 이후부터 실제로 제품을 구현하고 테스트하고 고객에게 전달하는 과정을 모두 포함하는 용어이다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Product Manager" /><category term="Product Manager" /></entry><entry><title type="html">기획</title><link href="https://sanghyuk.dev/planner/1/" rel="alternate" type="text/html" title="기획" /><published>2021-08-31T00:00:00+09:00</published><updated>2021-08-31T00:00:00+09:00</updated><id>https://sanghyuk.dev/planner/1</id><content type="html" xml:base="https://sanghyuk.dev/planner/1/">&lt;h1 id=&quot;제목&quot;&gt;제목&lt;/h1&gt;

&lt;p&gt;내용&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Planner" /><category term="기획" /></entry><entry><title type="html">CHAPTER07: 함수 - 1.함수의 기본 개념</title><link href="https://sanghyuk.dev/swift-grammar/7-1/" rel="alternate" type="text/html" title="CHAPTER07: 함수 - 1.함수의 기본 개념" /><published>2021-02-21T00:00:00+09:00</published><updated>2021-02-21T00:00:00+09:00</updated><id>https://sanghyuk.dev/swift-grammar/7-1</id><content type="html" xml:base="https://sanghyuk.dev/swift-grammar/7-1/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/swift.png&quot; alt=&quot;Swift&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;text-center&quot;&gt;&lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fsanghyuk.dev%2Fswift-grammar%2F7-1%2F&amp;amp;count_bg=%23FA7343&amp;amp;title_bg=%23555555&amp;amp;icon=swift.svg&amp;amp;icon_color=%23E7E7E7&amp;amp;title=Views&amp;amp;edge_flat=false&quot; alt=&quot;Hits&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;함수(Function)&lt;/strong&gt;는 대부분의 프로그래밍 언어에서 지원하는 개념으로 프로그램의 실행 과정 중에서 독립적으로 처리될 수 있는 부분을 분리하여 구조화한 객체를 의미한다. 즉, 외부에 의존하는 부분 없이 툭 떼어 분리할 수 있는 실행 단위를 일종의 캡슐처럼 포장해놓은 것이다. 이렇게 독립적으로 작성된 함수는 간단한 방식으로 여러 번 호출하여 사용할 수 있어서 같은 코드를 반복해서 작성할 필요가 없다.&lt;/p&gt;

&lt;p&gt;스위프트는 함수를 지원하므로, 이를 통해 한번 작성된 코드를 여러 곳에서 호출하여 사용할 수 있다. 특히 스위프트는 함수형 프로그래밍 패러다임을 채택하고 있는 언어이므로 함수형 프로그래밍의 특성을 이해하는 것은 매우 중요하다.&lt;/p&gt;

&lt;h1 id=&quot;1-함수의-기본-개념&quot;&gt;1. 함수의 기본 개념&lt;/h1&gt;

&lt;p&gt;일반적으로 함수를 표현할 때에는 다음과 같은 모습으로 표현하는 경우가 많다. 함수의 성격과 특성을 가장 잘 나타내는 모습이기 떄문일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-21-7-1/1.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-21-7-1/1.png&quot; alt=&quot;함수의 모식도&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;함수는 위 그림처럼 입력값을 받아 내부 처리 과정(그림에서는 입력값에 4를 더하는 처리)을 거친 후 그 결과값을 내어 놓는 형태를 기본으로 한다. 입력값을 &lt;strong&gt;인자값&lt;/strong&gt; 혹은 &lt;strong&gt;파라미터&lt;/strong&gt;라고 하고, 내어놓는 결과값을 &lt;strong&gt;반환값&lt;/strong&gt; 혹은 &lt;strong&gt;리턴값&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;함수의 인자값은 하나도 없을 수도 있고, 하나 이상일 수도 있다. 특별한 경우에는 인자값의 개수가 제한되지 않는 형태를 가지기도 한다.&lt;/p&gt;

&lt;p&gt;함수의 반환값은 특정 값을 반환하는 형태와 반환하는 값이 없는 형태 두 가지로 나눌 수 있다. 다만 특정 값을 반환하더라도 그 값의 갯수는 일반적으로 하나이다. 만약 둘 이상의 값을 반환해야 할 필요가 있다면 반환할 값들을 집단 자료형 하나에 담아 반환해야 한다. 즉, 실질적으로 반환하는 값이 여러 개더라도, 반환하는 단위는 하나라는 것이다.&lt;/p&gt;

&lt;p&gt;함수는 &lt;strong&gt;일반 함수&lt;/strong&gt;와 &lt;strong&gt;사용자 정의 함수&lt;/strong&gt;로 나눌 수 있따. 일반 함수는 프로그래밍 언어나 프레임워크 수준에서 제공하는 함수로 &lt;strong&gt;기본적인 데이터의 처리나 연산 등을 수행하기 위한 목적&lt;/strong&gt;으로 사용된다. 대표적으로 출력에 사용하는 함수인 print()를 들 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 실제로 애플리케이션을 개발하다 보면 언어나 프레임워크가 제공하는 함수만으로는 충반하지 않은 경우가 많다. 이때에는 우리가 원하는 기능을 실행해 줄 함수를 직접 만들어 사용해야 하는데, 이를 사용자 정의 함수라고 부른다. 이때 말하는 정의란 옳고 그름의 Justice가 아니라 Definition을 의미한다. 이번 장에서 배울 대부분의 내용은 이같은 사용자 정의 함수에 관련된 것들이다.&lt;/p&gt;

&lt;p&gt;기본적으로 함수는 의존성 없이 독립적으로 실행 가능한 코드를 모듈 단위로 분리해 놓은 것에 불과하므로, 함수를 사용하지 않고 함수 내부의 실행 코드만 가져다 전체 코드에 넣고 사용해도 된다. 다시 말해 프로그래밍에서 함수가 필수 요소는 아니라는 것이다. 그럼에도 함수가 중요한 의미를 가지는 것은 다음과 같은 이점들 떄문이라고 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 코드가 여러 곳에서 사용될 때 이를 함수화하면 재작성을 할 필요 없이 함수 호출만으로 처리할 수 있다.&lt;/li&gt;
  &lt;li&gt;전체 프로세스를 하나의 소스 코드에서 연속적으로 작성하는 것보다 기능 단위로 함수화하면 가독성이 좋아지고, 코드와 로직을 이해하기 쉽다.&lt;/li&gt;
  &lt;li&gt;비즈니스 로직을 변경해야 할 때 함수 내부만 수정하면 되므로 유지보수가 용이하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;11-사용자-정의-함수&quot;&gt;1.1 사용자 정의 함수&lt;/h2&gt;

&lt;p&gt;사용자 정의 함수를 만드는 방법을 알아보자. 스위프트에서 함수를 정의하는 형식은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;함수명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;매개변수1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;매개변수2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환타입&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;실행내용&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환값&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스위프트에서 함수를 정의할 때 func 키워드를 사용한다. 함수를 선언할 때 키워드를 사용하지 않는 언어들도 많지만 스위프트는 명시적으로 func 키워드를 사용하여 함수를 선언해야 한다. func 키워드 다음에는 함수의 이름을 작성하는데, 이때 [+, -, *, /] 같은 연산자와 예약어는 사용할 수 없다.&lt;/p&gt;

&lt;p&gt;함수의 이름에 사용할 수 있는 문자들은 영어나 숫자, 한자, 바이너리 이미지 등으로 다양하지만, 첫 글자는 반드시 영어 또는 언더바(_)로 시작해야 한다. 언더바 이외의 특수문자나 숫자로 시작할 경우 컴파일러에 의해 오류가 발생한다. 대신 두 번째 글자부터는 이런 제약이 없으므로 영어, 숫자, 일부 특수문자를 충분히 활용할 수 있다. 단, 숫자나 특수 문자 등을 너무 남발하면 함수의 핵심인 재사용성과 생산성 측면에서 불편함이 야기될 수 있으므로 주의해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s0110&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;사당역 5번 출구&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 함수는 스위프트에서 함수명에 적용되는 규칙을 정확하게 지키고 있어 아무런 문제가 없다. 하지만 실제로 사용하기에 적절하지는 않다. 여러 개의 숫자로 이루어져 있어 쉽게 헷갈릴 수 있기 때문이다. 무엇보다 함수를 작성한 사람 이외에는 함수의 기능과 함수명을 연관 짓기 어렵다는 것이 치명적인 단점이다. 이 함수 하나만 사용한다면 외워서 사용할 수도 있겠지만, 이같은 함수들이 백 개쯤 된다고 생각해보자. 그것은 악몽이다.&lt;/p&gt;

&lt;p&gt;이름에 특수문자가 포함되어 있는 함수도 마찬가지이다. 앞에서 이미지를 사용한 변수명의 불편함에 대해 잠깐 이야기한 적이 있는데, 비슷한 이유로 함수명에 특수문자가 포함되면 충분히 불편하다. 함수를 호출할 떄마다 특수문자를 입력하는 복잡한 과정을 거쳐야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;숫자도 마찬가지이다. 숫자를 너무 남발하면 함수의 이름을 외우기 쉽지 않다. 과자 포장지 뒤에 있는 바코드 숫자 외우고 있는 사람이 있을까? 아마 없을 것이다. 너무 외우기 어려우니까. 그러므로 함수에서 숫자나 특수기호는 꼭 필요할 때 의미를 구분하는 용도로 적당한 선만큼만 사용하는 것이 좋다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;이름 지을 땐 왠만하면 숫자를 자제하자.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예전에 필자가 어떤 회사의 내부 시스템 리뉴얼을 진행할 떄의 이야기이다.(리뉴얼은 ‘개편’이라는 뜻으로, 기존에 있던 시스템을 업그레이드하거나 바꿀 때 사용하는 현장 용어이다.) 리뉴얼을 위한 미팅에서 데이터를 저장하고 있는 데이터베이스의 명세서를 받아보고는 이내 당황해 버렸는데, 데이터베이스에서 수백 개 되는 테이블의 이름이 모조리 의미를 쉽게 짐작하기 어려운 숫자와 코드로 이루어져 있었기 때문이다.&lt;/p&gt;

&lt;p&gt;물론 최초 개발 당시에는 테이블에 저장하는 데이터의 성격에 따라 분류하려는 의도였겠지만, 이후 데이터베이스의 내용을 정리한 문서 관리가 제대로 되지 않고, 담당자까지 교체되면서 복잡한 코드로 이루어진 테이블명들은 개발자들에게 마치 다빈치 코드 같은 존재가 되어 버렸다. 실제로 운영을 담당하고 있던 기존 개발자들도 주로 사용하는 몇 개의 테이블명만 표로 정리해서 출력하여 참조하고 있었다. 매번 데이터베이스를 다루어야 할 때마다 테이블을 찾기가 정말 힘들었던 기억이 새록새록하다.&lt;/p&gt;

&lt;p&gt;이런 의미에서 회사가 여러분을 해고하지 못하도록 하려면 변수명이나 함수명을 모두 숫자나 코드로 작성하면된다. 후임자가 와서 코드를 보고 나면 바로 도망칠 테니까. 유지보수해야 하는 여러분들에게도 악몽과 같다는 건 함정. 단, 개발이 끝날 때까지는 들키지 말아야 할 것이다. 개발 도중에 들키면 일찍 집에 가는 수가 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;함수명을 작성하고 나면 다음으로 해야 할 것은 함수의 인자값 개수와 형태를 정의하기 위해 소괄호로 영역을 표시해 주는 것이다. 이 공간에는 함수가 호출될 때 전달되는 입력값을 대입 받기 위한 변수의 이름과 타입이 정의되는데, 이를 &lt;strong&gt;매개변수&lt;/strong&gt;라고 한다. 영어로는 &lt;strong&gt;파라미터(Parameter)&lt;/strong&gt;라고도 부른다. 오브젝티브-C에서 콜론(;) 다음에 매개변수명이 작성되던 것과 달리 스위프트에서는 괄호 내부에 쉼표(,)로 구분된 매개변수가 차례로 정의된다. 함수의 인자값이 필요 없는 경우라면 매개변수를 생략할 수 있으며, 이때 함수를 정의하는 형식은 다음과 같이 변경된다. 위의 함수 정의 구문과 비교해 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;함수명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환타입&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;실행내용&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환값&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;매개변수가 없는 함수를 작성할 떄는 함수명 뒤의 매개변수 영역을 표시하는 괄호 내부를 비워두면 된다. 일부 언어에서는 매개변수를 사용하지 않는 함수의 경우 매개변수 영역을 비워두는 대신 void라는 키워드를 명시적으로 작성할 것을 강제하기도 하지만, 스위프트에서는 그냥 빈칸으로 두면 된다. 하지만 매개변수가 없더라도 괄호는 생략할 수 없다.&lt;/p&gt;

&lt;p&gt;매개변수의 이름과 타입까지 작성이 완료되었으면 이제 이 함수의 반환 타입을 작성해 줄 차례이다. 반환타입이라는 것은 함수가 실행된 결과로 어떤 값을 내놓을 것이냐 하는 것이다. 함수의 기본은 인자값을 입력받아 내부적으로 처리하고, 그 결과를 외부로 다시 반환하는 과정에 있다. 따라서 반환값이라는 요소는 함수 내부에서 생성된 값을 외부로 전달하는 역할을 한다. 이를 &lt;strong&gt;함수가 값을 반환한다&lt;/strong&gt;고 표현한다. 실무에서는 &lt;strong&gt;함수가 값을 리턴한다&lt;/strong&gt;라는 표현을 더 많이 사용하기도 한다.&lt;/p&gt;

&lt;p&gt;함수의 반환 타입을 표시할 때에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; 기호와 함께 사용한다. 이 기호 다음에 작성된 자료형이 함수가 반환하는 값의 타입인 것이다. 함수의 반환 타입으로 사용될 수 있는 자료형에는 제약이 없다. String이나 Int, Double, Bool 등 기본 자료형은 물론이거니와 AnyObject, UITableCell 등과 같은 클래스 객체도 사용할 수 있으며, 사용자가 정의한 커스텀 클래스도 가능하다. 구조체 역시 사용할 수 있다. 하지만 반환 타입이 지정되면 반드시 그 타입에 맞는 값을 반환해야 한다. 반환 타입을 문자열로 정의했는데 실수를 반환해서는 안 된다. 또한 nil을 반환하려면 함수의 반환타입이 반스듸 옵셔널 타입으로 정의되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;함수의 성격에 따라서는 반환값이 전혀 없는 함수를 작성할 수도 있다. 이런 경우를 “아무 값도 반환하지 않는다.” 또는 “void 타입을 반환한다.”고 표현한다. 반환 타입을 생략할 수 없도록 설계된 언어에서는 반환 타입을 void로 작성하도록 강제되기도 하지만, 스위프트에서는 다음과 같이 반환 타입을 생략함으로써 반환값이 없음을 표현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;함수명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;매개변수1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;매개변수2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;실행내용&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환값&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/6-2/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/ios/2/&quot; class=&quot;btn btn--success&quot;&gt;iOS 면접 질문 목록 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/7-2/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><category term="함수" /><category term="문법" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER06: 옵셔널 - 2. 옵셔널 값 처리</title><link href="https://sanghyuk.dev/swift-grammar/6-2/" rel="alternate" type="text/html" title="CHAPTER06: 옵셔널 - 2. 옵셔널 값 처리" /><published>2021-02-16T00:00:00+09:00</published><updated>2021-02-16T00:00:00+09:00</updated><id>https://sanghyuk.dev/swift-grammar/6-2</id><content type="html" xml:base="https://sanghyuk.dev/swift-grammar/6-2/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/swift.png&quot; alt=&quot;Swift&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;text-center&quot;&gt;&lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fsanghyuk.dev%2Fswift-grammar%2F6-2%2F&amp;amp;count_bg=%23FA7343&amp;amp;title_bg=%23555555&amp;amp;icon=swift.svg&amp;amp;icon_color=%23E7E7E7&amp;amp;title=Views&amp;amp;edge_flat=false&quot; alt=&quot;Hits&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-옵셔널-값-처리&quot;&gt;2. 옵셔널 값 처리&lt;/h1&gt;

&lt;p&gt;문자열을 숫자로 변환해주는 생성자 Int(문자열) 이야기를 조금 더 해보자. 숫자로 바꿀 수 있는 문자열 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;123&quot;&lt;/code&gt;이 입력되면 숫자로 변환할 수 있지만, 그럴 수 없는 일반 문자열이 입력되면 잠재적인 오류 가능성이 있다고 설명했다. 이 때문에 Int(문자열)은 그냥 정수가 아니라 옵셔널 타입의 정수값을 반환하도록 설계되어 있다. Int 구조체의 생성자를 정의하는 구문 일부를 살펴보면 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;radix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Int(문자열) 구문이 반환하는 옵셔널 타입을 분석해보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;안녕하세요&quot;&lt;/code&gt;처럼 숫자로 바꿀 수 없는 문자열이 입력되었을 떄 옵셔널 타입에는 nil이 할당된 상태로 반환된다. 다른 문자열이 입력되어 변환에 성공하면 Optional(123)이라는 옵셔널 값이 할당된다. 어쨋거나 두 경우 모두 옵셔널 타입으로 반환되는 것만은 분명하다.&lt;/p&gt;

&lt;p&gt;이렇게 전달받은 옵셔널 타입의 결과값은 그 자체로는 아무것도 할 수 없다. 옵셔널 타입은 애초에 연산을 지원하지 않는 타입이다. 따라서 옵셔널 타입과 일반 타입은 서로 연산할 수 없으며 옵셔널 타입끼리의 연산이나 결합도 지원하지 않는다. 옵셔널 Int 타입과 일반 Int 타입의 연산도, 옵셔널 String과 일반 String 결합도 모두 불가능하다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ( x ) : 옵셔널 타입은 결합 연산 또는 더하기 연산이 가능한 데이터 타입이 아님&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// ( x ) : Int? 와 Int 는 서로 다른 타입이므로 연산이 불가능함&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 옵셔널 값을 그대로 사용하는 방법을 알아보자. 우리가 결과값으로 전달받은 것은 Optional이라는 객체이다. 그 내부에 우리가 원하는 값이 들어있을 것이다. 이 값을 우리가 원하는 대로 사용하려면 실제 값을 둘러싼 옵셔널 객체를 해제해야 한다. 옵셔널 객체를 해제하면 일반 타입의 값이 되는데, 이 값이 비로소 우리가 직접 사용할 수 잇는 값이다. 이처럼 옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 옵셔널 해제라고 한다. 다른 말로 옵셔널 언래핑(Optional Unwrapping)이라고도 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-16-6-2/1.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-16-6-2/1.png&quot; alt=&quot;옵셔널 타입의 값을 연산에 사용할 수 있도록 처리하는 과정&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;옵셔널 해제 방식은 &lt;strong&gt;명시적 해제&lt;/strong&gt;와 &lt;strong&gt;묵시적 해제&lt;/strong&gt;로 나누어진다. 명시적 해제는 다시 &lt;strong&gt;강제적인 해제&lt;/strong&gt;와 &lt;strong&gt;비강제적인 해제&lt;/strong&gt;로 나눌 수 있고 묵시적 해제는 각각 &lt;strong&gt;컴파일러에 의한 자동 해제&lt;/strong&gt;와 &lt;strong&gt;연산자를 이용한 자동 해제&lt;/strong&gt;로 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-16-6-2/2.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-16-6-2/2.png&quot; alt=&quot;옵셔널 해제 방식&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;차례대로 각 해제 방법에 대해 알아보자. 우선 학습할 것은 명시적 해제, 특히 가장 많이 사용되는 강제 해제이다. 강제 해제는 옵셔널 값의 nil 여부와 관계없이 옵셔널을 무조건 해제하는 방식으로, 스위프트 공식 문서에서 사용하는 용어로는 Forced Unwrapping이다. 정확한 의미로는 옵셔널을 벗겨내는 것이지만, 이 강의에서는 편의상 강제 해제라고 부르겠다.&lt;/p&gt;

&lt;h2 id=&quot;21-옵셔널-강제-해제&quot;&gt;2.1 옵셔널 강제 해제&lt;/h2&gt;

&lt;p&gt;옵셔널을 강제 해제하는 방법은 무척 단순하다. 옵셔널 타입의 값 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt;기호만 붙여주면 된다. 이렇게 처리해 주면 옵셔널 객체가 해제되고, 그 내부에 저장된 값을 꺼내 사용할 수 있게 된다. 이때 사용된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; 기호를 가리켜 옵셔널에 대한 ‘강제 해제 연산자(Forced-Unwrapping Operator)’라고 한다. 이와 관련된 다음 예제를 살펴보자. 옵셔널 Int 타입으로 선언된 optInt를 강제 해제 연산자를 사용하여 값을 추출하는 구문이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 옵셔널 타입의 변수 선언&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;옵셔널 자체의 값 : &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;!로 강제해제한 값 : &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 위 구문을 실행한 결과이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;옵셔널 자체의 값 : Optional(3)
!로 강제해제한 값 : 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;뱐수 optInt를 Int 타입으로 정의하면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt;를 붙여 옵셔널 타입으로 선언했다. 옵셔널 타입에 대입된 값은 옵셔널 객체로 감싸 처리되므로, 변수 자체를 출력하면 ‘Optional(3)’이라는 값이 출력된다. 이어서 두 번째 print 구문을 살펴보자. optInt 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; 연산자를 붙였더니 3이 출력되었다. 이는 옵셔널 타입의 값이 ! 연산자 덕분에 해제되었기 때문이다. 이처럼 옵셔널 타입으로부터 값을 추출하려면 옵셔널 값 뒤에 ! 연산자를 붙이면 된다. 앞에서 옵셔널 타입끼리 연산은 불가능하다고 이야기했지만, 강제 해제 연산자를 사용하면 일반 타입으로 해제되므로 연산이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 246&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 153&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 이상한점이 있다. 옵셔널 타입의 변수나 상수에 ! 연산자만 붙이면 일반 타입처럼 사용할 수 있는 앞서 설명대로라면 그냥 모든 옵셔널 타입에 ! 연산자를 붙여서 사용해버리면 되는것이다. 게다가 옵셔널 변수의 값이 nil일 때도 강제 해제 연산자를 붙일수는 있는데, 실제로 값이 nil인 옵셔널 변수에 이 연산자를 붙이면 오류가 발생한다. 이렇게 된다면 굳이 힘들게 옵셔널 타입을 사용하는 의미가 있을까?&lt;/p&gt;

&lt;p&gt;그래서 옵셔널 변수나 상수를 안전하게 사용하려면 조건이 따른다. 강제 해제 연산자를 사용할 때에는 먼저 옵셔널 값이 nil인지 점검해야 한다. 그리고 옵셔널 값이 nil이 아닐 떄에만 강제 해제 연산자를 붙여서 값을 추출해야 한다. 다음 구문을 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값이 변환되었습니다. 변환된 값은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ①&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값 변환에 실패하였습니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ②&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞서 여러 차례 설명한 바와 같이 Int(문자열) 생성자는 옵셔널 정수값을 반환한다. 따라서 위 예제에서 Int(문자열)의 결과를 대입받는 intFromStr 상수 역시 옵셔널 타입으로 정의된다. 옵셔널은 값이 없는 nil이거나 정상적인 값을 옵셔널 객체로 둘러싼 두 가지 경우만 존재하므로 옵셔널 값이 nil인지를 if 조건절로 점검해야 한다. 그리고 그에 맞는 조건절 블록 내에서만 강제 해제 연산자를 사용해야 한다. 이것이 오류 없이 안전하게 옵셔널 타입을 해제하여 사용할 수 있는 방법이다.&lt;/p&gt;

&lt;p&gt;위 예제에서 Int(문자열) 생성자의 변환 대상이 되는 문자열 “123”은 숫자로 변환할 수 있는 문자열이므로 intFromStr은 nil이 아니다. 정확히는 Optional(123)이다. 따라서 if 조건절이 참이 되면서 ①의 내용이 실행되므로 실행 결과는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;값이 변환되었습니다. 변환된 값은 123입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 대입된 값이 숫자로 변환할 수 없는 “Swift” 문자열이라면 어떻게 실행될까?&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값이 변환되었습니다. 변환된 값은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ①&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값 변환에 실패하였습니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ②&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;입력된 문자열은 Int(&lt;문자열&gt;)을 통해 숫자로 변환할 수 없는 값이므로 실행 결과는 nil이다. if 조건절이 거짓이므로 else 블록 영역인 ②가 실행된다. 따라서 결과는 다음과 같다.&lt;/문자열&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;값 변환에 실패하였습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;else 블록에서 ! 연산자를 사용하면 nil에 대한 옵셔널 강제 해제가 실행되어 오류가 발생한다. 따라서 ! 연산자는 확실히 옵셔널의 값이 nil이 아닌 조건에서만 사용해야 한다.&lt;/p&gt;

&lt;p&gt;위 구문에서 주의 깊게 살펴보아야 할 부분이 있다. if에서 nil 값을 비교하는 데 사용된 조건절이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 조건절에서 intFromStr와 비교연산자 != 사이에 의도적인 공백이 있음을 알아야 한다. 이 공백은 단순히 가독성을 높이기 위해 추기된 것이 아니다. 일반적으로 연산자 앞에 공백이 있을 필요는 없다. 일부는 가독성을 위해 공백을 집어넣기도 하지만 그것은 습관일 뿐, 컴파일러의 규칙상 반드시 그래야 하는 것은 아니다.&lt;/p&gt;

&lt;p&gt;그런데 이번처럼 옵셔널 타입의 nil 점검을 위한 != 연산자를 사용할 때는 반드시 앞에 공백을 두어야 한다. 문법의 오류를 방지하기 위한 목적이다. intFromStr 변수처럼 옵셔널 타입의 값을 비교 연산자와 함께 사용하면서 공백을 두지 않으면 컴파일러는 이 구문을 다음 두 가지로 해석할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 해석 ① : (intFromStr)!=(nil) -&amp;gt; 원래 의도한 대로 intFromStr 변수와 nil의 비교&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 해석 ② : (intFromStr)=nil -&amp;gt; intFromStr 변수의 옵셔널 강제 해제 + nil 값의 할당&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결국, 해석의 차이가 발생할 수 있으므로 구문이 모호해지는 결과를 가져온다. 컴파일러는 이를 확실하게 해석하지 못하므로 구문 분석 오류가 발생하게 된다. 이러한 상황을 방지하기 위해 옵셔널 타입이 비교 대상이라면 부등 비교 연산자(!=)를 사용할 때 공백을 두어야 한다. ‘아버지가방에들어가십니다’가 생각나는, 의외로 띄어쓰기가 중요해지는 이야기라고 할 수 있겠다.&lt;/p&gt;

&lt;h2 id=&quot;22-옵셔널-바인딩&quot;&gt;2.2 옵셔널 바인딩&lt;/h2&gt;

&lt;p&gt;앞에서 우리는 nil 체크 조건절을 사용하여 안전하게 옵셔널 타입을 해제할 수 있었다. 이 예제는 동일한 기능을 하는 비강제적인 해제 구문으로 바꾸어 작성이 가능하다. 이는 if 구문 내에서 조건식 대신 옵셔널 값을 일반 변수나 상수에 할당하는 구문을 사용하는 방식으로, &lt;strong&gt;옵셔널 바인딩(Optional Binding)&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;옵셔널 바인딩은 &lt;strong&gt;조건문 내에서 일반 상수에 옵셔널 값을 대입하는 방식&lt;/strong&gt;으로 이루어진다. 반드시 조건문에서 사용해야만 하며, 상수에 옵셔널 값을 대입한 결과는 true/false 로 리턴된다. 우리가 배운 대표적인 조건절인 if를 사용하여 옵셔널 바인딩하는 예제를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값이 변환되었습니다. 변환된 값은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값 변환에 실패하였습니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞의 구문과 매우 비슷하지만, infFromStr가 상수로 선언되었다는 점과 이 상수가 옵셔널이 아닌 일반 타입이라는 점이 다르다. 강제 해제 연산자를 사용하지 않아도 옵셔널 값이 일반 변수나 상수에 할당되면서 자연스럽게 옵셔널 타입이 해제되지만, 값이 nil이더라도 값의 할당이 실패하여 결과값이 false로 반환될 뿐이므로 오류는 발생하지 않는다. 단지 else 블록이 실행 될 뿐이다. 또다른 구문 하나를 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값 변환에 실패하였습니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값이 변환되었습니다. 변환된 값은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 구문은 guard 구문을 이용하여 옵셔널 바인딩을 구현한 예제이다. guard 구문은 특성상 함수나 메소드에만 사용할 수 있기 때문에 intStr() 함수를 정의하고 그 안에 guard 구문을 작성하였다. 실제로 앱을 만드는 과정 거의 대부분은 함수로 이루어지기 때문에, guard 구문을 사용할 여지는 많다.&lt;/p&gt;

&lt;p&gt;guard 구문을 사용하더라도 옵셔널 바인딩 방식은 동일하다. 상수를 선언하고, 여기에 옵셔널 값을 대입하는 것이 전부다. 하지만 사용 용법상 if 구문 내에서 옵셔널 바인딩을 사용하는 것과 구분해야 할 필요는 있다. if 구문을 사용한 옵셔널 바인딩은 단순히 옵셔널 값의 처리 결과에 따라 서로 다른 피드백을 주고 싶을 때 사용한다. 하지만 guard 구문은 조건에 맞지 않으면 무조건 함수의 실행을 종료시키는 특성이 있기 때문에, 실행 흐름상 옵셔널 값이 해제되지 않으면 더 이상 진행이 불가능할 정도로 큰일이 생길 때에만 사용하는 것이 좋다. 참고로, 옵셔널 타입이긴 하지만 절대 nil 값이 들어가지 않을 것이라는 보장이 있을 때에는 강제 해제 연산자를 사용하여 옵셔널 타입을 처리하는 것이 효율적이다.&lt;/p&gt;

&lt;p&gt;옵셔널과 관련하여, 앞 장에서 학습했던 딕셔너리에 값을 입력하고 사용하는 예제를 다시 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 딕셔너리 선언&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;capital&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Seoul&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;EN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;London&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;FR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Paris&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 실행 결과
Optional(&quot;Seoul&quot;)
Seoul
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;딕셔너리에 키로 접근하면 그 결과값은 옵셔널 타입으로 반환된다. 값을 출력한 결과를 확인하면 금세 알 수 있다. 옵셔널 타입 대신 일반 타입의 값을 얻으려면 capital[“KR”] 뒤에 ! 연산자를 붙여야 한다. 그렇지 않으면 옵셔널 타입이 그대로 반환되어 예제에서 보는 것과 같이 Optional(“Seoul”)이 반환된다. 그런데 딕셔너리는 왜 옵셔널 타입의 값을 반환하는 것일까?&lt;/p&gt;

&lt;p&gt;딕셔너리에 키로 사용될 수 있는 값은 Hashable 프로토콜이 구현된 모든 자료형이라고 설명했다. 정해진 숫자 0, 1, 2, 3…만 차례대로 들어갈 수 있는 배열과 달리 딕셔너리는 미리 정해진 키 값만 사용되는 것이 아니라 무작위로 키가 사용될 수도 있다. 키 사용에 대한 제한이 거의 없는 거나 마찬가지이므로 키가 있는지를 점검하기도 어렵다.&lt;/p&gt;

&lt;p&gt;이 때문에, 딕셔너리에서 값을 읽을 때에는 존재하지 않는 키를 사용할 가능성이 있다. 이 경우 딕셔너리는 주어진 키에 값이 비어있거나 입력된 키가 아예 없다는 것을 표현하기 위해 nil을 반환해야 한다. 이 때문에 딕셔너리는 기본적으로 옵셔널 타입으로 정의된 값을 반환하게된다.&lt;/p&gt;

&lt;p&gt;사실 위 코드 역시 잘 구성된 코드는 아니다. nil 여부를 체크하지 않고 ! 연산자를 사용하여 바로 강제 해제를 실행한 것 때문이다. 이를 그대로 실행하면 오류가 발생할 수 있으므로 다음과 같이 보완하는 것이 좋다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 또는&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;옵셔널 타입에서 ! 연산자를 사용할 떄는 반드시 nil 점검을 해 주어야 오류를 미연에 방지할 수 있다는 점, 잊지 말아야 한다.&lt;/p&gt;

&lt;h2 id=&quot;23-컴파일러에-의한-옵셔널-자동-해제&quot;&gt;2.3 컴파일러에 의한 옵셔널 자동 해제&lt;/h2&gt;

&lt;p&gt;옵셔널 타입의 값을 사용하려면 항상 ! 연산자를 사용하여 옵셔널을 &lt;strong&gt;강제 해제(Forced-unwrapping)&lt;/strong&gt;하든가, 아니면 옵셔널 바인딩을 통해 일반 자료형으로 바꾸어 주어야 한다. 이렇게 해야 옵셔널 객체로 감싸진 값을 꺼낼 수 있다. 하지만 명시적으로 강제 해제를 하지 않아도 컴파일러에서 자동으로 옵셔널을 해제해주는 경우가 있다. 다음 예제를 보자&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;optInt == 123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;optInt != 123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문자열을 숫자로 변환한 옵셔널 상수의 값이 nil이 아니면 ! 연산자를 사용하여 옵셔널 값을 강제 해제하고 이 값을 정수 123과 비교하는 예제이다. 그 결과는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;optInt == 123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이번에는 강제 해제하지 않은 옵셔널 타입과 정수 123을 비교해보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;optInt == 123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;optInt != 123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;강제 해제하지 않은 옵셔널 값은 Optional(123)이므로 정수값 123과 다르다. 따라서 위 예제에서는 else 영역이 실행되어야 한다. 하지만 실제로 실행한 결과는 그렇지 않다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;optInt == 123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이상한 결과이다. 해제하지 않은 옵셔널 값 자체로 정수와 비교한 결과는 예상대로라면 일치하지 않는다고 나왔어야 한다. 그런데 결과는 값이 일치하는 것으로 보여주고 있다. 어떻게 된 것일까?&lt;/p&gt;

&lt;p&gt;옵셔널 타입으로 감싼 변수나 상수는 그 값을 사용하기 위해 반드시 ! 연산자를 사용하여 옵셔널 객체를 해제해야 한다. 하지만 굳이 해제하지 않아도 괜찮을 때가 있다. 옵셔널 객체의 값을 비교 연산자를 사용하여 비교하는 경우가 그에 해당하는데, 명시적으로 옵셔널 객체를 강제 해제하지 않아도 한쪽이 옵셔널, 다른 한쪽이 일반 타입이라면 자동으로 옵셔널 타입을 해제하여 비교 연산을 수행한다. 따라서 아래의 예제에서 모든 결과는 true이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tempInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tempInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tempInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tempInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tempInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;말하자면 비교 연산을 처리할 떄는 옵셔널 타입 여부에 구애받지 않고 일반 자료형처럼 값을 비교하면 된다는 것이다. 이는 옵셔널 타입에 값을 할당할 때도 마찬가지이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optValue01&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// ①&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optValue02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// ②&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원칙적으로 옵셔널 타입의 변수나 상수를 정의할 떄는 대입할 값을 Optional() 객체로 감싼 ①의 방식으로 처리해야 한다. 하지만 ②처럼 감싸지지 않은 순수 리터럴을 직접 대입할 수도 있다. 주의할 점은 타입 어노테이션 없이 직접 대입하면 단순히 일반 Int 타입의 변수로 선언되므로 타입 어노테이션을 추가하여 Int 타입이면서 동시에 옵셔널 타입이라는 것을 명시해 주어야 한다는 것 이다. 그러면 값 123은 대입될 대상이 옵셔널 타입이라는 것을 인지하고, 그것에 맞게 Optional(123)으로 변환된다.&lt;/p&gt;

&lt;h2 id=&quot;24-옵셔널의-묵시적-해제&quot;&gt;2.4 옵셔널의 묵시적 해제&lt;/h2&gt;

&lt;p&gt;옵셔널 타입을 해제하는 방법 중에는 &lt;strong&gt;묵시적 해제(Implicitly Unwrapped Optional)&lt;/strong&gt;라는 개념이 존재한다. 이것은 비록 옵셔널 타입이긴 하지만 값을 사용할 때에는 자동으로 옵셔널이 해제되기때문에 굳이 ! 연산자를 사용하여 해제할 필요가 없는 아주 편리한 구문이다. 컴파일러가 알아서 옵셔널을 해제해 준다는 점에서 방금 다루어 본 자동 해제와 유사하지만, 자동 해제가 비교 연산이나 값의 할당 등 일부 구문에 한정되는 것과 달리 묵시적 해제는 옵셔널 변수를 사용하는 모든 경우에 적용할 수 있으며, 옵셔널 변수의 타입을 선언할 떄 묵시적 해제를 미리 선언해 주어야 한다는 차이점이 있다.&lt;/p&gt;

&lt;p&gt;옵셔널의 묵시적 해제 구문은(이하 &lt;strong&gt;묵시적 옵셔널&lt;/strong&gt;) 일반 옵셔널 타입의 변수 선언 구문과 매우 유사하다. ? 연산자 대신 ! 연산자만 붙여주면 그뿐이다. 먼저 일반 옵셔널 변수를 선언하는 구문을 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 명시적 옵셔널 선언&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift Optional&quot;&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 구문의 실행 결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional(&quot;Swift Optional&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문자열 변수 str을 옵셔널 타입으로 선언하고, 여기에 “Swift Optional”이라는 문자열을 대입했다. 이를 출력해 보면 대입된 문자열이 옵셔널 객체로 감싸진 것을 확인할 수 있다. 이제 이 구문을 묵시적 옵셔널로 바꾸어 보자. 딱히 큰 수정이 필요하지는 않다. 단지 ? 연산자를 제거하고 ! 연산자로 그 자리를 대체하기만 하면 된다. 하지만 결과는 사뭇 다르다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 묵시적 옵셔널 선언&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift Optional&quot;&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Swift Optional
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;타입 어노테이션 뒤에 붙은 연산자 하나만 바꾸었을 뿐인데 결과는 전혀 달라졌다. 출력된 구문에서 옵셔널 객체가 사라졌다. 컴파일러에 의해 옵셔널 객체가 자동으로 해제된 것이다. 혹시 str 변수가 일반 타입인 것을 아닐까? 혹시 모르니 nil 값을 대입해 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nil을 대입해도 아무 문제가 없다. 이는 곧 str이 옵셔널 타입으로 정의되어 있음을 의미한다.&lt;/p&gt;

&lt;p&gt;이처럼 ! 연산자를 붙여 변수를 정의하면 옵셔널 타입이 된다. 하지만 일반적으로 옵셔널 타입을 사용할 때 필요한 강제 해제 연산자나 옵셔널 바인딩 과정 없이, 일반 변수처럼 다루어도 된다. 이는 묵시적 해제 선언이 이루어졌기 때문이다.&lt;/p&gt;

&lt;p&gt;묵시적 옵셔널을 사용하면 옵셔널 타입 변수의 연산도 간단하게 처리할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value01&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 오류&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value02&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반적으로 옵셔널 타입과 일반 타입을 직접 연산하는 것은 오류이지만, 묵시적 해제를 선언한 옵셔널 타입은 다르다. 직접 일반 타입과 연산해도 문제가 되지 않는다. 이처럼 묵시적 해제를 선언한 옵셔널은 일반 타입처럼 사용할 수 있기 때문에 굉장히 편리하게 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 무조건 모든 경우에 묵시적 옵셔널을 사용할 수 있는 것은 아니다. 옵셔널의 묵시적 해제 선언에서 염두에 두어야 할 것 한 가지가 있는데, 바로 &lt;strong&gt;변수의 값이 nil이 될 가능성이 있다면 묵시적 옵셔널 해제를 사용하지 않아야 한다&lt;/strong&gt;는 것이다.&lt;/p&gt;

&lt;p&gt;의아할 것이다. 변수가 nil이 될 가능성이 있을 때 사용하는 것이 옵셔널 타입인데 변수가 nil이 될 가능성이 있다면 사용하지 말라니. 그렇다면 도대체 언제 사용하는 것일까?&lt;/p&gt;

&lt;p&gt;묵시적 옵셔널 해제를 사용하는 경우는 한 가지로 정의할 수 있다. 바로,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;“형식상 옵셔널로 정의해야 하지만, 실제로 사용할 때에는 절대 nil 값이 대입될 가능성이 없는 변수일 때”&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이다. 다음 구문을 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 구문은 Int(문자열)이 반환하는 값이 옵셔널 타입이기 떄문에 어쩔 수 없이 value 변수를 옵셔널 타입으로 선언해야 한다. 하지만 Int(“123”)은 누가 봐도 제대로 정수로 변환될 것이 확실하다. 이런 확실한 값에 굳이 옵셔널 처리를 해 줄 필요는 사실 거의 없다. 이때 위와 같이 value 변수를 묵시적 옵셔널로 선언한다면 옵셔널 타입 여부에 신경 쓰지 않고 일반 변수처럼 편하게 사용할 수 있다. 하지만 이 경우가 묵시적 옵셔널을 사용해야 하는 이유로 납득하기는 조금 어렵다. Int(“123”)! 처럼 대입하는 값 쪽에 강제 해제 연산자를 붙여주면 처음부터 value를 일반 변수로 만들어줄 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;실제로 묵시적 옵셔널이 정말 유용하게 사용되는 경우는 클래스 또는 구조체 내에서 이다. 주로 멤버 변수를 정의할 때 선언과 초기화를 분리시켜야 하는 경우에 해당한다. 아직 클래스를 배우기 전이므로 이해하기 어려울 것이다. 지금은 그냥 클래스에서는 묵시적 옵셔널 해제가 많이 사용되는구나 하는 정도로만 알고 있으면 될 것 같다.&lt;/p&gt;

&lt;p&gt;많은 사람이 옵셔널 개념의 도입 여부에 대해 의문을 표시한다. 필요할 떄만 값의 여부를 점검하여 정상적으로 값이 있을 때 처리할 수 있도록 코딩하면 될 것을 뭐하러 까다롭고 번거로운 옵셔널 개념을 도입했는가에 대해 말이다. 그러나 옵셔널의 강점은 안전성뿐만 아니라 안전성을 담보하는 과정에서 표현되는 코드의 간결성에 있다.&lt;/p&gt;

&lt;p&gt;다음은 애플에서 스위프트 언어를 발표할 때 제시했던 코드로, nil 값을 점검하면서 사용하는 오브젝티브-C 코드와 이를 옵셔널을 사용하여 간결하게 표현한 스위프트 코드를 함께 보여주고 있다. 이 처럼 옵셔널을 이용하여 간결하게 처리할 수 있는 문법을 &lt;strong&gt;옵셔널 체인(Optional Chain)&lt;/strong&gt;이라고 하는데, 스위프트의 옵셔널 개념이 코드를 얼마나 간결하게 만들어줄 수 있는지 보여주는 대표적인 예라고 할 수 있다. 옵셔널 체인에 대한 문법은 클래스에 대해 학습하는 과정에서 자세히 다루겠다.&lt;/p&gt;

&lt;div class=&quot;language-objectivec highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 오브젝티브-C 코드&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myDelegate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myDelegate&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;respondsToSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scrollViewDidScroll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:)])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myDelegate&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scrollViewDidScroll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myScrollView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 스위프트 코드&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myDelegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scrollViewDidScroll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myScrollView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/6-1/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/ios/2/&quot; class=&quot;btn btn--success&quot;&gt;iOS 면접 질문 목록 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/7-1/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><category term="옵셔널" /><category term="Optional" /><category term="언래핑" /><category term="unwrapping" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER06: 옵셔널 - 1. 옵셔널 타입 선언과 정의</title><link href="https://sanghyuk.dev/swift-grammar/6-1/" rel="alternate" type="text/html" title="CHAPTER06: 옵셔널 - 1. 옵셔널 타입 선언과 정의" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sanghyuk.dev/swift-grammar/6-1</id><content type="html" xml:base="https://sanghyuk.dev/swift-grammar/6-1/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/swift.png&quot; alt=&quot;Swift&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;text-center&quot;&gt;&lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fsanghyuk.dev%2Fswift-grammar%2F6-1%2F&amp;amp;count_bg=%23FA7343&amp;amp;title_bg=%23555555&amp;amp;icon=swift.svg&amp;amp;icon_color=%23E7E7E7&amp;amp;title=Views&amp;amp;edge_flat=false&quot; alt=&quot;Hits&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;옵셔널(Optional)은 스위프트에서 도입된 새로운 개념으로서 언어 차원에서 프로그램의 안정성을 높이기 위해 사용하는 개념이다. 옵셔널의 개념을 한 문장으로 정의하자면 ‘nil을 사용할 수 있는 타입과 사용할 수 없는 타입을 구분하고, 사용할 수 있는 타입을 가리켜 옵셔널 타입(Optional Type)이라고 부른다’라고 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;여기서 말하는 nil이란, &lt;strong&gt;값이 없음&lt;/strong&gt;을 의미하는 특수한 값이다. 정수형의 0이나, 문자열의 ““과는 다른, 말 그대로 순수하게 하무 값도 없다는 것을 의미한다. 이런 특수성 때문에 nil은 종종 실제 값으로는 처리할 수 없는, 무엇인가 문제가 발생했을 때 이를 의미하기 위해 사용된다.&lt;/p&gt;

&lt;p&gt;앞에서 잠깐 다룬 딕셔너리를 떠올려보자. 저장된 값을 읽으려면 딕셔너리 변수명 뒤에 대괄호와 함께 키 값을 넣어주어야 하는데, 종종 잘못된 키를 대입할 때가 있다. 오타이거나, 혹은 이미 삭제된 키를 사용하는 경우가 대표적이다. 이같은 상황에서 스위프트는 우리에게 뭔가 ‘너 지금 잘못했어. 그 키는 지금의 딕셔너리에는 존재하지 않아’라고 알려주고 싶어한다.&lt;/p&gt;

&lt;p&gt;하지만 오류를 발생시키는 것은 그리 좋지 않다. 겨우 딕셔너리 키에 대한 잘못된 참조 하나 때문에 실행을 중단시키는 것은 매정할 뿐만 아니라, 스위프트는 최대한 안정성을 높이고자 노력하는 언어이다. 하지만 결과값을 공백을 반환할 수는 없다. 그랬다면 사용자가 자신이 실수한 것을 알지 못하고 정말 ‘그 키에는 공백이 저장되어 있었나보군’이라고 착각하게 될지도 모르기 때문이다. 이런 상황에서 스위프트는 오류도 발생시키지 않고 뭔가 문제가 있었다는 것도 알려주기 위해 nil이라는 값을 반환하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;capital&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Seoul&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;CN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Beijing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;JP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Tokyo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ko&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이처럼 스위프트에서는 값을 처리하는 과정에 문제가 있을 경우 많은 부분에서 오류를 발생시키는 대신 결과값을 nil로 반환한다. 하지만 모든 타입이 nil을 반환할 수 있는 것은 아니며 오직 옵셔널 타입만 nil을 반환할 수 있다. 다시 말해, nil을 반환하려면 해당 값이 옵셔널 타입으로 정의되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;여기에서 중요한 것은 “오류가 발생할 가능성”이다. 경우에 따라서는 오류가 발생하지 않을 수도 있지만, 언젠가 오류가 발생할 수 있는 가능성이 아주 조금이라도 있다면 모두 옵셔널 타입으로 정의해야 한다. 이해를 돕기 위해 또다른 예를 살펴보자. 문자열 “123”을 숫자로 변환해야 한다고 가정해 보겠다.&lt;/p&gt;

&lt;p&gt;일반적으로 사람의 인식에서는 “그저 큰따옴표만 떼면 된다”라고 생각할지도 모르겠지만, 프로그래밍에서 문자열 “123”을 숫자로 바꾸려면 다소 복잡한 변환 과정을 거쳐야 한다. 다행히 스위프트를 포함한 많은 프로그래밍 언어에서는 문자열을 숫자로 변환해주는 간편한 방법을 제공한다. 스위프트에서는 Int 객체의 생성자 옵션에 숫자로 변환할 문자열을 넣어주면 정수로 변환된다. 사용 형식은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;바꿀&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;문자열&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예를 들어, 문자열 “123”을 숫자로 바꾸려면 다음과 같이 작성하면 된다. 상수 num은 문자열 “123”이 아니라 정수 123이 대입된 Int 타입의 상수로 정의된다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 값을 넣어도 마찬가지이다. 문자열을 정수로 변환한 값을 얻을 수 있따. 그런데 만약 “123”이나 “456”처럼 숫자로 바꿀 수 있는 문자열 대신, 아래와 같이 문자열을 인자값으로 넣으면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;무척 난감한 상황이다. 일반 문자열은 숫자로 변환할 수 없기 떄문이다. 따라서 컴파일러는 이럴 떄 “죄송합니다. 이 문자열은 숫자로 변환할 수 없습니다”라고 난감함을 표현해야 한다. 개발자가 상황을 이해하고 적절히 대응할 수 있는 구문을 보완할 수 있도록 말이다.&lt;/p&gt;

&lt;p&gt;대부분 프로그래밍 언어에서는 이런 상황을 오류로 처리하거나 혹은 예외사항으로 처리한다. 오류 처리 구문을 사용할 수 있는 대표적인 언어인 자바는 이럴 떄 NumberFormatException() 예외를 발생함으로써 개발자가 인지하고 이에 대응하는 코드를 작성할 수 있도록 돕는다. 비단 자바뿐만 아니라 PHP도 오류 코드를 발생시키고, 자바스크립트 역시 NaN을 반환하여 변환에 실패했음을 알려준다.&lt;/p&gt;

&lt;p&gt;그러나 스위프트는 조금 다르다. 언어의 안정성을 위해 가급적 오류를 발생시키지 않으려고 노력한다. 오류가 발생하면 프로그램의 실행 흐름이 중단되고 경우에 따라 앱의 동작이 멈추거나 아예 꺼져버릴 수도 있으므로, 언어의 안정성을 위해서는 될 수 있으면 피해야 하는 상황일 수밖에 없다. 이런 맥락에서 스위프트는 문자열의 정수 변환이 실패하더라도 실행을 중지시키거나 오류를 발생시키지 않고 억지로 값을 반환하려고 노력한다. 반환하는 값이 그 무엇이 도든 간에 말이다.&lt;/p&gt;

&lt;p&gt;하지만 아무 값이나 반환할 수는 없다. 특히 0을 반환해서는 안 된다. 누군가 Int(“0”)을 호출했을 떄 정상적인 처리 결과로 정수 0이 반환된 경우와 구분할 수 없기 떄문이다. 또한 공백을 사용해서도 안 된다. 공백은 일반적으로 문자열로 처리되는 경향이 있어, 반환 타입이 일치하지 않을 뿐만 아니라 공백 또한 실패를 의미하는 값은 아니기 떄문이다. 이런 상황에서 개발자들은 실패를 의미하면서도 오류를 던지는 것이 아닌 값이 필요했다. 이런 목적에서 정의된 값이 바로 “값이 없음”을 뜻하는 nil이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;다른 언어에서 Null이나 null로 표현되기도 하는 nil은 &lt;strong&gt;값이 없다는 것&lt;/strong&gt;을 표현하기 위해 사용하는 일종의 특수 값이다. 이 값은 원래 오브젝티브-C에서 쓰이던 값이었는데, 스위프트로 넘어오면서 의미가 약간 달라졌다. 오브젝티브-C에서는 빈 메모리 주소를 가리키는 값이었지만 스위프트에서는 단순히 &lt;strong&gt;‘값이 없음’&lt;/strong&gt;을 의미하게 된 것이다. 스위프트에서는 뭔가 연산 과정에서 정상적으로 값을 처리하지 못하는 상황이 발생했을 떄 제대로 된 결과값 대신 nil을 반환한다. 앞에서 예로 든 문자열을 숫자로 변환하는 과정에서도 잘못된 인자값으로 인해 문자열의 정수 반환이 실패했을 떄, ‘인자값이 잘못되었으므로 이 변환 처리는 실패입니다. 따라서 아무 값도 반환되지 않습니다’라는 의미를 표현하기 위해 nil을 반환한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런데 스위프트에서는 nil의 사용에 제약을 걸어두었다. 바로 일반 자료형은 nil 값을 가질 수 없다는 것이다. 문자열이나 정수 등은 일반 자료형이기 때문에 &lt;strong&gt;‘값이 없음’&lt;/strong&gt;을 뜻하는 nil 값을 저장할 수 없다. 만약 일반 자료형에 억지로 nil 값을 대입하려고 하면 다음과 같은 오류가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/1.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/1.png&quot; alt=&quot;일반 자료형에 nil을 대입하려고 했을 때의 오류&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;함수에서 값을 반환할 때에도 마찬가지이다. 함수는 반환 타입이 정해져 있기 때문에 항상 그 타입에 맞는 값을 반환해야 하는데, 처리 과정이 실패했을 경우에는 nil을 반환하게 된다. 하지만 일반 자료형에는 nil 값을 할당할 수 없다는 스위프트의 특성 때문에 nil을 반환하면 오류가 발생한다.&lt;/p&gt;

&lt;p&gt;이때 사용하는 타입이 바로 옵셔널 타입이다. 옵셔널 타입으로 선언된 자료형은 nil 값을 저장할 수 있다. 만약 nil 값을 저장해야 하거나 혹은 함수의 반환값에 nil이 포함될 가능성이 있다면, 다시 말해 오류가 발생할 가능성이 있다면 반환 타입을 반드시 옵셔널 타입으로 설정해야 한다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int(&amp;lt;바꿀문자열&amp;gt;)&lt;/code&gt; 구문의 반환 타입은 옵셔널 타입으로 정의된다.&lt;/p&gt;

&lt;p&gt;사실 옵셔널 타입은 별도로 존재하는 자료형이 아니다. 스위프트에서 모든 기본 자료형들은 그에 대응하는 옵셔널 타입이 존재한다. 다시 말해 정수형에 대응하는 옵셔널 타입과, 문자열에 대응하는 옵셔널 타입이 모두 있다는 뜻이다. 또한, 클래스나 구조체를 이용하여 만든 객체도 옵셔널 타입으로 바꿀 수 있다. 함수를 통해서 반환 가능한 모든 타입들 역시 옵셔널 타입으로 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;어떤 자료형을 사용하는지에 따라 대응하는 옵셔널 타입은 다르다. 정수 타입을 옵셔널 타입으로 변경하면 Optional Int 타입이 되고, 문자열을 옵셔널 타입으로 바꾸면 Optional String이 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int(&amp;lt;바꿀문자열&amp;gt;)&lt;/code&gt; 구문의 반환타입은 Optional Int이다.&lt;/p&gt;

&lt;p&gt;그런데 스위프트에서 옵셔널 타입이 실제로 가질 수 있는 값의 종류는 오직 두 가지 뿐이다. 하나는 &lt;strong&gt;nil이 아닌 값&lt;/strong&gt;, 또다른 하나는 &lt;strong&gt;nil 값&lt;/strong&gt;이다. nil이 아닌 값은 실제 실행 결과에서 오류가 발생하지 않았을 때 반환되며, 실제 실행 과정에서 오류가 발생했을 때에는 nil이 반환된다.&lt;/p&gt;

&lt;p&gt;헷갈릴지도 모르겠지만 여기에서 말하는 ‘nil이 아닌 값’은 “ABC” 또는 123 등의 구체적인 값이 아니라 정말 nil이 아닌 값 그 자체이다. 이것은 반환하려는 실제 값이 옵셔널이라는 객체로 둘러 싸인 상태를 의미한다. 다시 말해 처리 과정에 문제가 있었다면 nil이 반환되고, 문제가 없어 처리가 성공했다면 옵셔널 객체로 감싸진 결과값이 반환된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/2.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/2.png&quot; alt=&quot;옵셔널 타입이 가질 수 있는 값의 경우&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;결국, 옵셔널 타입이란 &lt;strong&gt;반환하고자 하는 값을 옵셔널 객체로 다시 한 번 감싼 형태&lt;/strong&gt;를 의미한다. 하지만 성공했을 때에는 일반 값을 반환하고, 그렇지 않으면 특수하게 처리된 예외나 NaN 값을 반환하는 방식으로 나누어 반환하는 다른 프로그래밍의 반환 방식과는 다르다. 스위프트에서는 일단 오류가 발생할 가능성이 있기만 하면, 성공적으로 처리했더라도 일단 옵셔널 타입으로 감싸서 반환하기 떄문이다.&lt;/p&gt;

&lt;p&gt;문자열 “123”을 숫자로 변환한 값을 반환하고자 한다면 실제로 변환된 값 123을 직접 반환하는 것이 아니라 옵셔널 타입으로 값을 감싼 Optional(123)을 반환한다. 만약 숫자로 변환하지 못할 문자열(예를 들어, “안녕하세요”와 같은)이 입력되어 정상적인 변환이 불가능한 상황이라면 Optional(“안녕하세요”)가 아니라 nil 값을 반환한다. 이떄 Optional(123)과 nil은 모두 옵셔널 타입이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/3.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/3.png&quot; alt=&quot;문자열의 정수 변환 처리 결과&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;처리가 성공적일 경우, 옵셔널 타입으로 반환된 값을 열어보면 실제 값이 옵셔널 타입으로 둘러싸여 있는 것을 볼 수 있다. 이를 &lt;strong&gt;옵셔널 래핑(Optional Wrapping)&lt;/strong&gt;이라고 한다. 이렇게 받은 값은 &lt;strong&gt;옵셔널 언래핑(Optional Unwrapping)&lt;/strong&gt;이라고 불리는 특수한 처리 과정을 통해 옵셔널 타입을 해제하고 실제 값을 추출하여 사용해야 한다. 단, 처리 결과가 실패여서 옵셔널 타입의 값이 nil이라면 옵셔털 타입을 해제해서는 안 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/4.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/4.png&quot; alt=&quot;문자열의 정수 변환 처리 결과&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;질문 : 차라리 모든 값을 옵셔널 타입으로 선언하고 사용하면 안 되나요? 일반 타입과 옵셔널 타입으로 나누어 사용하는 건 헷갈리고 불편할 것 같아서요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모든 값을 옵셔널 타입으로 선언하는 것은, 일반 자료형에 nil 값을 대입할 수 잇도록 허용하는 것과 다를 바가 없다. 그런데 모든 값이 nil을 가질 수 있다는 것은 또 다른 문제를 발생시킨다. 값을 사용할 때마다 일일이 nil인지 아닌지를 체크하여 사용해야 한다. 이는 프로그래밍 로직을 복잡하게 만들 뿐만 아니라 처리 과정 또한 어렵게 만든다. 그러므로 꼭 필요한 경우에만 제한적으로 옵셔널 타입을 적용하는 것이 좋다.&lt;/p&gt;

&lt;h1 id=&quot;1-옵셔널-타입-선언과-정의&quot;&gt;1. 옵셔널 타입 선언과 정의&lt;/h1&gt;

&lt;p&gt;일반 자료형을 옵셔널 타입으로 만드는 방법은 단순하다. 우리가 사용하는 자료형 뒤에 퀘스천 마크(물음표)만 붙이면 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'String?'&lt;/code&gt; 은 Optional String 타입을 의미하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'Int?'&lt;/code&gt;는 Optional Int 타입을 의미한다. String 타입에는 nil을 대입할 수 없지만 String? 타입에는 nil을 대입할 수 있다. 다음 예제들은 다양한 옵셔널 타입을 보여주고 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Int 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 String 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Double 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optDouble&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Array 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Dictionary 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optDic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optDic2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Class 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AnyObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반 자료형을 선언만 하고 초기화하지 않으면 아예 아무것도 할당되지 않지만, 옵셔널 타입으로 자료형을 선언하면 자동으로 nil로 초기화된다. 물론, 옵셔널 내부에 있는 자료형에 nil 값이 부여된다는 것은 아니다. 옵셔널 타입 자체에 nil이 부여된다는 것이다.&lt;/p&gt;

&lt;p&gt;옵셔널 타입으로 선언된 변수나 상수에 실제 값을 할당하는 방법은 일반 타입의 그것과 동일하다. 다음은 옵셔널 타입의 변수와 상수에 값을 할당하는 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Int 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 String 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;optString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Array 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;optArr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;JAVA&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Objective-C&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;SmallTalk&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Dictionary 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optDic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;optDic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;국어&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;94&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;수학&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;88&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;영어&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;96&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;옵셔널 타입의 변수에 값을 할당할 때에는 옵셔널 타입임을 인지할 필요가 거의 없다. 일반 변수처럼 값을 할당하면 옵셔널 객체 내부에 값이 대입되기 때문이다. 즉, 값을 대입할 때에는 옵셔널이 아닌 일반 변수처럼 생각하고 다루어도 무방하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/2-5/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/ios/2/&quot; class=&quot;btn btn--success&quot;&gt;iOS 면접 질문 목록 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/6-2/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><category term="옵셔널" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">iOS 면접 질문 모음</title><link href="https://sanghyuk.dev/ios/2/" rel="alternate" type="text/html" title="iOS 면접 질문 모음" /><published>2021-02-01T00:00:00+09:00</published><updated>2021-02-01T00:00:00+09:00</updated><id>https://sanghyuk.dev/ios/2</id><content type="html" xml:base="https://sanghyuk.dev/ios/2/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/iOS/2021-02-01-2/interview.png&quot; alt=&quot;interview&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ios-면접-질문-모음&quot;&gt;iOS 면접 질문 모음&lt;/h1&gt;

&lt;p&gt;개발자를 채용하는 면접에는 기술 면접이 있다. 여러번 면접을 경험하다 보니 특정 질문들을 자주 받는 느낌이 들었다. 업무를 진행하는데 있어서 중요한 부분들을 주로 질문한다고 생각이 들었고, 그 말은 반대로 꼭 공부해야 알아야 할 부분이라는 생각이 들었다. 그래서 실제 면접을 통해서 받는 질문들을 정리하려고 한다. 관련 자료들을 찾던 중 iOS 개발자들이 면접에서 받는 질문들을 리스트로 정리한 글을 발견했다. 질문의 답을 아는 것도 있었지만, 모르는 것이 더 많았다. 원본 글에 공부하며 습득하는 것을 위해 답이 적혀있지 않아 따로 질문에 대한 답을 정리하기로 했다.&lt;/p&gt;

&lt;p&gt;원본 글은 &lt;a href=&quot;https://github.com/JeaSungLEE/iOSInterviewquestions&quot;&gt;이재성님의 깃허브&lt;/a&gt;에서 볼 수 있다. 지속적으로 iOS 개발자들의 제보에 의해 채워지는 질문 리스트라고 한다. 이직을 준비하는 사람들은 유용한 글이 될 것 같다.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;strong&gt;💡 Notice :&lt;/strong&gt;
답을 정리한 글은 체크가 되어있으며, 클릭 시 정리한 글로 이동한다.&lt;/p&gt;

&lt;h2 id=&quot;required&quot;&gt;Required&lt;/h2&gt;

&lt;p&gt;아래 내용들은 최대한 많이 공부하는 것이 좋다고 한다.&lt;/p&gt;

&lt;p&gt;만약 면접시기가 WWDC 이후 라면 WWDC의 &lt;a href=&quot;https://developer.apple.com/videos/all-videos/&quot;&gt;세션들&lt;/a&gt;을 봐 두는것이 좋다.&lt;/p&gt;

&lt;h3 id=&quot;ios&quot;&gt;iOS&lt;/h3&gt;
&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Bounds 와 Frame 의 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;실제 디바이스가 없을 경우 개발 환경에서 할 수 있는 것과 없는 것을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;앱이 foreground에 있을 때와 background에 있을 때 어떤 제약사항이 있나요?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;상태 변화에 따라 다른 동작을 처리하기 위한 앱델리게이트 메서드들을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;scene delegate에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;앱이 In-Active 상태가 되는 시나리오를 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;NSOperationQueue 와 GCD Queue 의 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;GCD API 동작 방식과 필요성에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;자신만의 Custom View를 만들려면 어떻게 해야하는지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;iOS 앱을 만들고, User Interface를 구성하는 데 필수적인 프레임워크 이름은 무엇인가?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Foundation Kit은 무엇이고 포함되어 있는 클래스들은 어떤 것이 있는지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Delegate란 무언인가 설명하고, retain 되는지 안되는지 그 이유를 함께 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;NotificationCenter 동작 방식과 활용 방안에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;UIKit 클래스들을 다룰 때 꼭 처리해야하는 애플리케이션 쓰레드 이름은 무엇인가?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;TableView를 동작 방식과 화면에 Cell을 출력하기 위해 최소한 구현해야 하는 DataSource 메서드를 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;하나의 View Controller 코드에서 여러 TableView Controller 역할을 해야 할 경우 어떻게 구분해서 구현해야 하는지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;App Bundle의 구조와 역할에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;View 객체에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;UIView 에서 Layer 객체는 무엇이고 어떤 역할을 담당하는지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;UIWindow 객체의 역할은 무엇인가?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;UINavigationController 의 역할이 무엇인지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;모든 View Controller 객체의 상위 클래스는 무엇이고 그 역할은 무엇인가?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;앱이 시작할 때 main.c 에 있는 UIApplicationMain 함수에 의해서 생성되는 객체는 무엇인가?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;UIApplication 객체의 컨트롤러 역할은 어디에 구현해야 하는가?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;앱의 콘텐츠나 데이터 자체를 저장/보관하는 특별한 객체를 무엇이라고 하는가?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체를 무엇이라고 하는가?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Swift의 클로저와 Objective-C의 블록은 어떤 차이가 있는가?&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;App의 Not running, Inactive, Active, Background, Suspended에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;App thinning에 대해서 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Global DispatchQueue 의 Qos 에는 어떤 종류가 있는지, 각각 어떤 의미인지 설명하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;autolayout&quot;&gt;AutoLayout&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;오토레이아웃을 코드로 작성하는 방법은 무엇인가? (3가지)&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;hugging, resistance에 대해서 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Intrinsic Size에 대해서 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;스토리보드를 이용했을때의 장단점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Safearea에 대해서 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Left Constraint 와 Leading Constraint 의 차이점을 설명하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;swift&quot;&gt;Swift&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/6-1/&quot;&gt;Optional 이란 무엇인지 설명하시오.&lt;/a&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Fast Enumeration 이란 무엇인지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Struct 가 무엇이고 어떻게 사용하는지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;instance 메서드와 class 메서드의 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Delegate 패턴을 활용하는 경우를 예를 들어 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Singleton 패턴을 활용하는 경우를 예를 들어 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;KVO 동작 방식에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Delegates와 Notification 방식의 차이점에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;멀티 쓰레드로 동작하는 앱을 작성하고 싶을 때 고려할 수 있는 방식들을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;MVC 구조에 대해 블록 그림을 그리고, 각 역할과 흐름을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;프로토콜이란 무엇인지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Hashable이 무엇이고, Equatable을 왜 상속해야 하는지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;mutating 키워드에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;탈출 클로저에 대하여 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Extension에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;접근 제어자의 종류엔 어떤게 있는지 설명하시오&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;defer란 무엇인지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우를 설명하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;arc&quot;&gt;ARC&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;ARC란 무엇인지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Retain Count 방식에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Strong 과 Weak 참조 방식에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;ARC 대신 Manual Reference Count 방식으로 구현할 때 꼭 사용해야 하는 메서드들을 쓰고 역할을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;retain 과 assign 의 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;순환 참조에 대하여 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;강한 순환 참조 (Strong Reference Cycle) 는 어떤 경우에 발생하는지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;특정 객체를 autorelease 하기 위해 필요한 사항과 과정을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Autorelease Pool을 사용해야 하는 상황을 두 가지 이상 예로 들어 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;다음 코드를 실행하면 어떤 일이 발생할까 추측해서 설명하시오.
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;Ball&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ball&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[[[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Ball&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;autorelease&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;autorelease&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;functional-programming&quot;&gt;Functional Programming&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/7-1/&quot;&gt;함수형 프로그래밍이 무엇인지 설명하시오.(작성중)&lt;/a&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;고차 함수가 무엇인지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Swift Standard Library의 map, filter, reduce, compactMap, flatMap에 대하여 설명하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;optional&quot;&gt;Optional&lt;/h2&gt;

&lt;p&gt;추가로 공부하면 좋을 내용들이라고 한다. Objective-C 나 rx는 회사, 팀마다 차이가 있다.&lt;/p&gt;

&lt;h3 id=&quot;objective-c&quot;&gt;Objective-C&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Mutable 객체과 Immutable 객체는 어떤것이 있는지 예를 들고, 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;dynamic과 property 의미와 차이를 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;@property로 선언한 NSString* title 의 getter/setter 메서드를 구현해보시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;@property에서 atomic과 nonatomic 차이점을 설명하고, 어떤것이 안전한지, 어느것이 기본인지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;@property로 선언한다는 것의 의미를 설명하고, .h에 넣을 경우와 .m에 넣을 경우 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;-performSelector:withObject:afterDelay: 메시지를 보내면 인자값의 객체는 retain되는가? 그 이유를 함께 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Objective-C 에서 캡슐화된 데이터를 접근하기 위한 방법들을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;unnamed category 방식에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Category 확장과 Subclass 확장의 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Category 방식에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Objective-C 에서 Protocol 이란 무엇인지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Objective-C++ 방식이 무엇인지 설명하고, 어떤 경우 사용해야 하는지 설명하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;advanced&quot;&gt;Advanced&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;method swizzling이 무엇이고, 어떨 때 사용하는지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;NSCoder 클래스는 어떤 상황에서 어떻게 써야 하는지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Responder Chain 구조에 대해 설명하고, First Responder 역할에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;NSObject부터 UIButton 까지 상속 과정의 계층과 역할을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;shallow copy와 deep copy의 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Push Notification 방식에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Foundation 과 Core Foundation 프레임워크의 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;NSURLConnection 에서 사용하는 Delegate 메서드들에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Synchronous 방식과 Asynchronous 방식으로 URL Connection을 처리할 경우의 장단점을 비교하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Plist 파일 구조와 Plist 파일에 저장된 데이터를 다루기 적합한 클래스를 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Core Data와 Sqlite 같은 데이터 베이스의 차이점을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;JSON 데이터를 처리하는 방식과 파서, 객체 변환 방식에 대해 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;웹 서버와 HTTP 연결을 사용해서 데이터를 주거나 받으려면 사용해야 하는 클래스와 동작을 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Protocol에서는 왜 var만 되는지 설명하시요.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;architecture&quot;&gt;Architecture&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;MVVM, MVC, Ribs, VIP 등 자신이 알고있는 아키텍쳐를 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;의존성 주입에 대하여 설명하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;rx&quot;&gt;Rx&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Reactive Programming이 무엇인지 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;RxSwift에서 Hot Observable과 Cold Observable의 차이를 설명하시오.&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Subject와 drive의 차이를 설명하시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;출처 : &lt;a href=&quot;https://github.com/JeaSungLEE/iOSInterviewquestions&quot;&gt;이재성님의 깃허브&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;날짜 : 2021년 2월 1일 기준&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="iOS" /><category term="interview" /><category term="question" /><category term="programming" /><category term="면접" /><category term="면접 질문" /><category term="swift" /><category term="인터뷰" /><category term="질문" /><category term="예상문제" /><category term="이력서" /></entry><entry><title type="html">Jekyll 블로그 검색엔진에 등록하기 - Google</title><link href="https://sanghyuk.dev/blog/3/" rel="alternate" type="text/html" title="Jekyll 블로그 검색엔진에 등록하기 - Google" /><published>2021-01-06T00:00:00+09:00</published><updated>2021-01-06T00:00:00+09:00</updated><id>https://sanghyuk.dev/blog/3</id><content type="html" xml:base="https://sanghyuk.dev/blog/3/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Blog/Jekyll.jpeg&quot; alt=&quot;jekyll&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jekyll-블로그-검색엔진에-등록하기---google&quot;&gt;Jekyll 블로그 검색엔진에 등록하기 - Google&lt;/h1&gt;

&lt;p&gt;블로그에 작성한 글이 검색엔진에 노출시키기 위해서는 블로그를 등록하는 과정이 필요하다. 이번에는 Jekyll로 작성된 블로그가 구글에서 검색되도록 설정하는 과정이다.&lt;/p&gt;

&lt;h2 id=&quot;구글-search-console에-속성-추가&quot;&gt;구글 Search Console에 속성 추가&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://search.google.com/search-console/welcome?hl=ko&quot;&gt;구글 Search Console&lt;/a&gt;에 접속한다. 로그인을 진행하는데 Google 계정이 필요하디.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2021-01-06-3/1.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2021-01-06-3/1.png&quot; alt=&quot;구글 서치 콘솔 로그인&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사이트 등록 란에 자신의 jekyll 블로그 주소를 입력하여 추가한다. (ex.http://[github 사용자명].github.io/ 또는 자신이 사용하는 도메인)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2021-01-06-3/2.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2021-01-06-3/2.png&quot; alt=&quot;구글 서치 콘솔 로그인&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;원래는 소유권을 인증하는 화면이 나와야 하지만 Google 에서 구매한 도메인을 사용하고 있어 따로 소유권 인증이 필요하지 않은 것으로 보인다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2021-01-06-3/3.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2021-01-06-3/3.png&quot; alt=&quot;구글 서치 콘솔 로그인&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;기존의 과정대로 소유권을 인증하고 Sitemap.xml, robot.txt 파일을 업로드 하는 과정이 필요하지만, 그 과정은 네이버 검색엔진에 등록하는 방법과 동일하다. &lt;a href=&quot;https://sanghyuk.dev/blog/2/&quot;&gt;링크&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Blog" /><category term="jekyll" /><category term="blog" /><category term="search engine" /><category term="google" /><category term="지킬" /><category term="블로그" /><category term="구글" /><category term="검색" /></entry><entry><title type="html">Jekyll 블로그 검색엔진에 등록하기 - Naver</title><link href="https://sanghyuk.dev/blog/2/" rel="alternate" type="text/html" title="Jekyll 블로그 검색엔진에 등록하기 - Naver" /><published>2020-12-29T00:00:00+09:00</published><updated>2020-12-29T00:00:00+09:00</updated><id>https://sanghyuk.dev/blog/2</id><content type="html" xml:base="https://sanghyuk.dev/blog/2/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Blog/Jekyll.jpeg&quot; alt=&quot;jekyll&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;jekyll-블로그-검색엔진에-등록하기---naver&quot;&gt;Jekyll 블로그 검색엔진에 등록하기 - NAVER&lt;/h1&gt;

&lt;p&gt;블로그에 작성한 글이 검색엔진에 노출시키기 위해서는 블로그를 등록하는 과정이 필요하다. 이번에는 Jekyll로 작성된 블로그가 네이버에서 검색되도록 설정하는 과정이다.&lt;/p&gt;

&lt;h2 id=&quot;네이버-웹-마스터-도구에-속성-추가&quot;&gt;네이버 웹 마스터 도구에 속성 추가&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://searchadvisor.naver.com/&quot;&gt;네이버 서치어드바이저&lt;/a&gt;에 접속한다. 로그인을 진행하는데 Naver 계정이 필요하디. (대한민국 사람이면 없을리가 없다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/1.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/1.png&quot; alt=&quot;서치어드바이저 로그인&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;웹 마스터 도구로 접속한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/2.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/2.png&quot; alt=&quot;웹마스터 도구 접속&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사이트 등록 란에 자신의 jekyll 블로그 주소를 입력하여 추가한다. (ex.http://[github 사용자명].github.io/ 또는 자신이 사용하는 도메인)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/3.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/3.png&quot; alt=&quot;사이트 등록&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;사이트-소유-확인&quot;&gt;사이트 소유 확인&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;제공하는 HTML 파일을 다운로드 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/4.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/4.png&quot; alt=&quot;HTML 다운&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;다운받은 HTML 파일을 자신의 Jekyll 블로그의 가장 상위 디렉토리에 업로드한다. 이 과정에서 git에 commit 과 push 를 해야한다. 정상적으로 업로드 되었는지 확인한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/5.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/5.png&quot; alt=&quot;업로드 확인&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;정상 업로드 되었다면 &lt;strong&gt;소유확인&lt;/strong&gt; 버튼을 누른다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/6.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/6.png&quot; alt=&quot;소유확인&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;소유확인이 완료되면 정상이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/7.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/7.png&quot; alt=&quot;소유확인 완료&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;웹마스터 도구에서 등록된 사이트를 확인할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/8.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/8.png&quot; alt=&quot;사이트 등록 확인&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;rss-feedxml-파일-생성&quot;&gt;RSS feed.xml 파일 생성&lt;/h2&gt;

&lt;p&gt;RSS(Rich Site Summary)는 뉴스나 블로그 사이트에서 주로 사용하는 콘텐츠 표현 방식이다. RSS Feed 는 다음과 같은 기능을 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사이트에 방문하지 않고도 해당 사이트에 올라오는 글들을 자동으로 모아주는 기능&lt;/li&gt;
  &lt;li&gt;웹 사이트에서 게시하며 자주 업데이트되는 콘텐츠를 제공&lt;/li&gt;
  &lt;li&gt;네이버 및 다음 등의 검색엔진에 자신의 블로그 및 웹 사이트를 RSS 형태로 등록하여 많은 페이지를 더욱 쉽게 노출 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jekyll 에는 feed.xml 파일을 생성하는 방법이 두 가지 있다. 플러그인을 사용하는 방법과 수동으로 만드는 방법이 있는데 둘 중 편한 방법을 선택하여 만들면 된다. Github-pages 에서는 플러그인을 사용할 수 없어 수동으로 만들어 보겠다.&lt;/p&gt;

&lt;p&gt;GitHub Jekyll 블로그의 가장 상위 디렉토리에 feed.xml 파일을 생성한다. 그리고 아래의 코드를 입력한다. (1~2 행의 – 부분도 포함시켜야 한다.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/9.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/9.png&quot; alt=&quot;feed 파일 생성&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;플러그인에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/jekyll/jekyll-feed&quot;&gt;이곳&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;sitemapxml-파일-생성&quot;&gt;sitemap.xml 파일 생성&lt;/h2&gt;

&lt;p&gt;Sitemap 은 웹 크롤링 로봇이 이용할 수 있는 웹사이트의 접근 가능한 페이지의 목록이다. 다음과 같은 기능을 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹사이트의 웹페이지를 계층별로 구분지어 웹사이트의 전체 구조를 보여주며, 검색엔진의 크롤링 로봇들이 크롤링 작업에 유용&lt;/li&gt;
  &lt;li&gt;sitemap.xml 파일을 사용하면 사이트 및 콘텐츠 구조를 Google 및 기타 검색엔진에 손쉽게 제출 가능&lt;/li&gt;
  &lt;li&gt;검색엔진에 크롤링해야하는 URL을 알려줌으로써 색인을 생성하는 방법과 색인을 생성하는 방법을 제어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jekyll 에는 sitemap.xml 파일을 생성하는 방법이 두 가지 있다. 플러그인을 사용하는 방법과 수동으로 만드는 방법이 있는데 둘 중 편한 방법을 선택하여 만들면 된다. Github-pages 에서는 플러그인을 사용할 수 없어 수동으로 만들어 보겠다.&lt;/p&gt;

&lt;p&gt;GitHub Jekyll 블로그의 가장 상위 디렉토리에 feed.xml 파일을 생성한다. 그리고 아래의 코드를 입력한다. (1~2 행의 – 부분도 포함시켜야 한다.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/10.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/10.png&quot; alt=&quot;sitemap 파일 생성&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;플러그인에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/jekyll/jekyll-sitemap&quot;&gt;이곳&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;sitemap-설정하기&quot;&gt;sitemap 설정하기&lt;/h3&gt;
&lt;p&gt;포스트를 작성할 때 해당 포스트의 변경 주기나 우선순위 정보 등을 변경하고 싶으면, 아래와 같이 lastmod, sitemap.chagefreq, sitemap.priority 등의 태그 정보를 추가한다. 각 포스트의 맨 위에 아래와 같이 sitemap의 옵션을 추가하여 설정할 수 있다. 설정이 없을 때의 default 설정은 sitemap.xml에 정의되어 있다. sitemap의 changefreq를 너무 짧게 하면 빈번한 접속으로 안좋은 영향을 미칠 수도 있으니 중요한 변동이 없는 포스트는 일주일 정도로 잡아준다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-marksdown&quot;&gt;---
layout: post
title: '제목'
date: 2017-10-20
lastmod : 2017-10-20 12:00:00
sitemap :
changefreq : daily
priority : 1.0
---
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;주의사항&quot;&gt;주의사항&lt;/h2&gt;

&lt;h3 id=&quot;_configyml-파일-설정-확인하기&quot;&gt;_config.yml 파일 설정 확인하기&lt;/h3&gt;

&lt;p&gt;루트 디렉터리(GitHub Jekyll 블로그의 가장 상위 디렉터리)에 존재하는 _config.yml 파일 내의 url 부분에 자신의 블로그 url을 입력해야 sitemap.xml에서 site.url 부분을 사용 할 수 있다. 즉 _config.yml 파일 내에 url: ‘http://[github 사용자명].github.io’ 이 있는지 확인한다.&lt;/p&gt;

&lt;h2 id=&quot;robottxt-파일-생성&quot;&gt;robot.txt 파일 생성&lt;/h2&gt;

&lt;p&gt;robots.txt 는 검색엔진의 웹 크롤러가 방문할 때 참고하는 정책을 명시하는 파일이다. robots.txt 파일에 sitemap.xml 위치를 등록해두면 검색엔진의 크롤러들이 홈페이지를 크롤링하는데 도움을 준다.&lt;/p&gt;

&lt;p&gt;robots.txt 파일을 자신의 GitHub Jekyll 블로그의 가장 상위 디렉터리에 생성한다. 아래의 코드를 붙여 넣는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;User-agent: *
Allow: /
Sitemap: http://[자신의 github 사용자명].github.io/sitemap.xml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;sitemapxml-robotstxt-feedxml-파일-github에-업로드&quot;&gt;sitemap.xml, robots.txt, feed.xml 파일 GitHub에 업로드&lt;/h2&gt;

&lt;p&gt;Local에서 sitemap.xml, feed.xml 확인해보자. jekyll serve 명령어를 이용하여 로컬 서버를 실행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;http://127.0.0.1:4000/sitemap.xml 에 접속하여 내용을 확인한다.&lt;/li&gt;
  &lt;li&gt;http://127.0.0.1:4000/feed.xml 에 접속하여 내용을 확인한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;git에 commit 과 push 를 해야한다. 정상적으로 업로드 되었는지 확인한다.&lt;/p&gt;

&lt;h2 id=&quot;네이버-웹마스터-도구에-feedxml-sitemapxml-제출하기&quot;&gt;네이버 웹마스터 도구에 feed.xml, sitemap.xml 제출하기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;네이버 웹마스터 도구에 접속한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자신이 추가한 연동 사이트를 선택한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/11.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/11.png&quot; alt=&quot;연동 사이트 선택&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;화면 좌측에 나타난 메뉴에서 [요청] → [RSS 제출] 순으로 선택한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RSS URL 란에 ‘http://[github 사용자명].github.io/feed.xml’ 를 입력한다. (ex.http://[github 사용자명].github.io/feed.xml)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Blog/2020-12-29-1/12.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Blog/2020-12-29-1/12.png&quot; alt=&quot;RSS 등록&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;확인 버튼을 눌러 등록한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;같은 방법으로 화면 좌측에 나타난 메뉴에서 [요청] → [사이트맵 제출] 을 눌러 사이트맵을 등록한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Blog" /><category term="jekyll" /><category term="blog" /><category term="search engine" /><category term="naver" /><category term="지킬" /><category term="블로그" /><category term="네이버" /><category term="검색" /></entry><entry><title type="html">[codeit - 컴퓨터 개론] 프로그래밍 언어 이해하기 (Part. 1)</title><link href="https://sanghyuk.dev/codeit/3/" rel="alternate" type="text/html" title="[codeit - 컴퓨터 개론] 프로그래밍 언어 이해하기 (Part. 1)" /><published>2020-12-23T00:00:00+09:00</published><updated>2020-12-23T00:00:00+09:00</updated><id>https://sanghyuk.dev/codeit/3</id><content type="html" xml:base="https://sanghyuk.dev/codeit/3/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Codeit/codeit.png&quot; alt=&quot;codeit&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;컴퓨터-개론&quot;&gt;컴퓨터 개론&lt;/h1&gt;

&lt;p&gt;프로그래밍 시장은 계속 커지고 있다. 하지만 사실 현업에서는 뛰어난 개발자를 없어서 못 구한다는 것. 프로그래밍의 세계는 광범위하기 때문에, 올바른 방향을 갖고 효과적으로 공부하는 것이 매우 중요하다. 코드잇의 컴퓨터 개론을 통해 프로그래밍 언어, 프로그래머, 프로그램에 대해 올바른 이해를 갖고, 나만의 커리어 로드맵을 만들어 보자.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;strong&gt;💡Infomation:&lt;/strong&gt;
컴퓨터 개론 학습은 하루 1시간 학습을 기준으로 약 12일이 소요됩니다.&lt;/p&gt;

&lt;h2 id=&quot;프로그래밍-언어-살펴보기&quot;&gt;프로그래밍 언어 살펴보기&lt;/h2&gt;

&lt;p&gt;전공자는 물론 비전공자도 이 강의만 들어도 기본적인 프로그래밍 언어의 특징과 분야를 이해할 수 있다. 비전공자를 위한 기초강의!&lt;/p&gt;

&lt;h3 id=&quot;프로그래밍을-배우기-힘든-이유&quot;&gt;프로그래밍을 배우기 힘든 이유&lt;/h3&gt;

&lt;p&gt;프로그래밍을 배워야겠다는 결심을 했다. 하지만 문제는 생각보다 프로그래밍을 제대로 공부하기가 쉽지 않다는 것이다. 무엇을 어떻게 공부해야 하는지 방향을 잡기가 어렵다. 프로그래밍 공부를 시작하려면 언어를 먼저 골라야 한다는데 언어는 왜 이렇게 많은지 모르겠고 누구는 C 언어를 공부하라고 하고, 누구는 Java, 누구는 Python 과 JavaScript 를 추천하기도 한다. 하지만 사실 그 이유를 정확하게 이해하지는 못했다.&lt;/p&gt;

&lt;p&gt;일단 C 언어를 공부해 보기로 한다. 그러다가 너무 어려워서 쉽다고 하는 Python 으로 옮긴다. 이런 식으로 다른 언어를 배회하다 보니 딱히 실력이 늘었다는 느낌은 들지 않고 시간만 흐르고 있다. 또 어디서는 자료 구조와 알고리즘을 공부하라고 하고 누구는 객체 지향을, 누구는 Git 을 공부하라고도 한다. 컴퓨터 공학을 전공하지 않은 사람은 이것들이 정말 다 필요한 건지도 잘 모르겠고 지금 당장 나에게 필요한 언어, 필요한 과목이 무엇인지 판단하기가 힘들다. 인터넷에는 정보가 너무 많아서 오히려 더 혼란스러워 진다. 언어는 왜 이렇게 많은 것이며 어떤 언어를 선택해서, 어떻게 공부해야 하는 걸까?&lt;/p&gt;

&lt;p&gt;사실 사람마다 필요한 언어는 다르다. 어떤 분야에 관심이 있고 어떤 개발자가 되고 싶은지, 심지어는 성향이 어떤지에 따라서도 필요한 언어와 기술이 달라진다. 마치 디자이너도 브랜드 디자이너, 제품 디자이너, 웹 디자이너 등이 있듯이 개발자도 여러 부류가 있으며 일하는 환경이나 여건 등이 꽤 달라지기도 한다. 그래서 무작정 누군가의 추천을 따라 공부할 것이 아니라 나에게 필요한 것이 무엇인지 스스로 판단하는 능력이 필요하다. 하지만 문제는 프로그래밍 자체를 모르는 상황에서 프로그래밍 분야나 기술 용어를 이해하기가 어렵다는 것이다. 모든 분야를 다 자세하고 깊게 알 필요는 없지만 본격적인 프로그래밍 공부에 앞서 프로그래밍의 세계에 대한 전반적인 이해를 갖추는 것이 필요하다. 이번 강의에서는 프로그래밍 언어에 대해 먼저 배워보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프로그래밍-언어-이해하기-강의-소개&quot;&gt;프로그래밍 언어 이해하기 강의 소개&lt;/h3&gt;

&lt;p&gt;프로그래밍 언어 이해하기 강의는 총 4개의 챕터로 구성되어 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로그래밍 언어 살펴보기&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어를 분류하는 두 가지 기준&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어 Overview&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어 제대로 사용하기&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;챕터-1-프로그래밍-언어-살펴보기&quot;&gt;챕터 1: 프로그래밍 언어 살펴보기&lt;/h4&gt;

&lt;p&gt;첫 번째 챕터에서는 프로그래밍 언어가 무엇인지에 대해 간단히 살펴보고, 기본적인 이해를 갖춘다. 그리고 컴퓨터, 프로그램, 프로그래밍 언어는 어떤 관계가 있는지 배우고, 프로그래밍 언어가 지나온 길을 살펴본다.&lt;/p&gt;

&lt;h4 id=&quot;챕터-2-프로그래밍-언어를-분류하는-두-가지-기준&quot;&gt;챕터 2: 프로그래밍 언어를 분류하는 두 가지 기준&lt;/h4&gt;

&lt;p&gt;첫 번째 챕터에서 프로그래밍 언어의 공통적인 원리에 대해 배웠다면, 두 번째 챕터에서는 프로그래밍 언어를 분류하는 두 가지 기준에 대해서 배운다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어의 종류가 왜 많아졌는지, 여러 프로그래밍 언어들 사이에는 어떤 차이가 있는지, 최근 프로그래밍 언어들은 어떻게 바뀌고 있는지 등을 배우게 된다.&lt;/p&gt;

&lt;p&gt;이 내용들은 나에게 맞는 프로그래밍 언어가 무엇인지 판단하는 데 도움이 될 것이다.
이 챕터를 배우면서, 앞으로 어떤 언어를 배우는 게 좋을지 직접 한번 고민해 보자.&lt;/p&gt;

&lt;h4 id=&quot;챕터-3-프로그래밍-언어-overview&quot;&gt;챕터 3: 프로그래밍 언어 Overview&lt;/h4&gt;

&lt;p&gt;세 번째 챕터에서는 앞서 배운 프로그래밍 언어를 분류하는 두 가지 기준을 배웠다면, 이번에는 프로그래밍 언어를 추상화가 얼마나 되었는지를 기준으로 분류하는 방법을 배워본다.
그리고 추상화가 프로그래밍 언어에 미치는 영향과 추상화가 많이 된 언어와 적게 된 언어의 장,단점을 배운다.&lt;/p&gt;

&lt;h4 id=&quot;챕터-4-프로그래밍-언어-제대로-사용하기&quot;&gt;챕터 4: 프로그래밍 언어 제대로 사용하기&lt;/h4&gt;

&lt;p&gt;마지막 챕터는 프로그래밍 언어의 활용법을 다룬다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어는 마치 사람의 언어와 같아서, 단순히 동작만 한다고 해서 좋은 코드를 작성한 건 아니다.
의미만 전달했다고 해서 좋은 글이 아닌 것처럼 말이다.&lt;/p&gt;

&lt;p&gt;어떻게 하면 더 좋은 코드를 만들 수 있는지, 개발자들은 코드를 어떤 관점으로 바라보며, 어떻게 코드를 작성하는지 이 챕터에서 살펴본다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프로그래밍-언어란&quot;&gt;프로그래밍 언어란?&lt;/h3&gt;

&lt;p&gt;프로그래밍 언어를 이해하려면 컴퓨터, 프로그램, 프로그래밍 언어 이 단어들을 함께 살펴봐야 한다. 쉽게 말해서 컴퓨터는 우리의 일을 대신해 주는 기계고 프로그램은 컴퓨터가 어떤 일을 해야 할지 알려주는 설명서라고 할 수 있다. 프로그래밍 언어는 그 설명서를 쓰기 위해 사용하는 언어이다.&lt;/p&gt;

&lt;p&gt;예를 들어 보자. 햄버거 가게를 오픈했다고 생각해보자. 그리고 혼자 모든 일을 할 수 없으니까 일을 대신해 줄 아르바이트 직원을 고용했다. 이 알바생에게 계산대를 맡기려고 한다. 그럼 먼저 계산대 업무를 맡기기 전에 어떻게 할지 알려 줘야한다. 이런 식으로 기본적인 지침이 있을 것이다. 그래야 내가 원하는 일을 알려 주고 대신 시킬 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;컴퓨터는 사람의 일을 대신해 준다고 했는데 실제로 요즘에는 많은 매장이 주문을 사람이 아닌 키오스크 같은 무인기기로 대신하고 있다. 프로그램과 프로그래밍 언어 그리고 컴퓨터의 관계가 이것과 비슷하다. 일을 대신해 주는 존재가 컴퓨터고 일을 어떻게 해야 하는지, 어떤 일을 해야 하는지 알려주는 설명서가 프로그램이고 그 프로그램이 작성된 언어가 프로그래밍 언어인 것이다. 이런 식으로 우리가 평소에 사용하는 컴퓨터 프로그램이나 휴대폰 앱 같은 것도 다 이렇게 프로그래밍 언어로 만들어진 것이다.&lt;/p&gt;

&lt;p&gt;우리가 못 느낄 수도 있지만 사실은 이 프로그램들은 컴퓨터가 할 일이 순서대로 적혀 있는 것이다. 언제 어떻게 행동해야 할지에 대해서 Python, Java 같은 프로그래밍 언어로 적혀 있는 것이다. 예를 들어서 ‘크롬 브라우저에서 뒤로 가기 버튼을 누르면 이전 페이지를 보여줘라’ 같이 지침이 다 적혀 있는 것이다. 이제 컴퓨터와 프로그램, 프로그램 언어의 관계가 이해될 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프로그래밍-언어의-발전&quot;&gt;프로그래밍 언어의 발전&lt;/h3&gt;

&lt;p&gt;컴퓨터는 계속해서 발전해왔다. 그에 맞춰서 프로그래밍 언어도 발전해 왔다. 초창기의 프로그래밍 언어는 어떻게 생겼을까? 지금처럼 영어였을까? 아니면 기호? 컴퓨터의 성능이 안 좋았으니까 처음에는 시키기 쉬운 일부터 시작했을 텐데, 최초에는 수학 계산을 위해 컴퓨터가 시작되었다. 그래서 최초의 컴퓨터를 얘기할 때 주판 얘기가 나오기도 한다.&lt;/p&gt;

&lt;p&gt;컴퓨터의 역사를 살펴보면 톱니바퀴를 이용해서 덧셈과 뺄셈을 하는 기계가 있었다. 이 기계 이름은 파스칼 계산기이다. 이게 컴퓨터라면 프로그램과 프로그래밍 언어는 뭘까? 지난 수업에 기계에게 할 일을 알려 주는 것이 프로그램이라고 했었는데 숫자를 계산하는 식, 예를 들어 256 + 984 가 하나의 프로그램이다. 이 프로그램을 실행시키면 1240이라는 계산 결과가 나오게 된다. 이 컴퓨터에 다른 프로그램을 실행시카면 다른 결과가 나올 것이다. 123 + 456 을 실행하면 579가 나오게 되는 것이다. 여기서 프로그래밍 언어는 이 계산 결과를 얻을 수 있도록 톱니바퀴를 움직이는 것이라고 볼 수 있다. 프로그래머에게 계산식을 알려 주면 그 프로그래머가 저 톱니바퀴를 돌려 계산한 뒤 알려주는 것이다. 이후에는 종이에 구멍을 뚫어서 이런 방식으로 컴퓨터에게 원하는 숫자를 알려 주기도 했다. 이 경우에는 종이에 구멍을 뚫는 것이 프로그래밍 언어인 셈이다. 사람이 직접 원하는 숫자에 해당하는 구멍을 뚫으면서 코딩을 했다. 한번 만들어서 계속 쓸 수 있으니 톱니바퀴보다는 더 발전된 형태라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;기술이 발전하면서 이제 사람들은 숫자 계산을 넘어서 더 많은 걸 시키고 싶어 했다. 예를 들어 번역을 한다든지 메시지를 보낸다든지 이런 것들도 하고 싶어진 것이다. 그래서 더 기능이 많은 다양한 일을 할 수 있는 컴퓨터와 프로그래밍 언어를 만들었다. 예전에는 프로그래밍 언어가 숫자로만 이루어졌었다면 이제는 더 다양한 표현이 필요해진 것이다. 그래서 요즘은 영어와 숫자, 수학 기호들이 섞인 형태의 어ㄷ쩌면 여러분이 본 적이 있을 생김새의 코드를 작성한다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_evenly_divisible&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;input_num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;숫자를 입력하세요:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_evenly_divisible&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 파이썬 코드이다. 코드가 완전히 이해되진 않지만 리턴, 인풋, 프린트 우리가 읽을 수 있는 단어들이 있다. 언어마다 쓰는 방법은 조금씩 다르지만 대체로 이렇게 생겼다고 보면 된다. 요즘에는 프로그래밍을 할 수 있는 컴퓨터도 일반적으로 보급되어 있고 프로그래밍 언어도 어느 정도 사람이 이해할 수 있는 문자로 되어 있으니 우리는 원한다면 누구나 직접 자신의 프로그램을 만들 수 있는 시대에 살고 있다. 여러분도 다 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/codeit/2/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/codeit/4/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="codeit" /><category term="Python" /><category term="codeit" /><category term="programming" /><category term="tutorial" /><category term="파이썬" /><category term="튜토리얼" /><category term="개발" /><summary type="html">프로그래밍 언어 살펴보기</summary></entry></feed>