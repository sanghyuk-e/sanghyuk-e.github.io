<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-11-04T18:28:21+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sanghyuk’s Blog</title><subtitle>Sanghyuk's Blog</subtitle><author><name>SANGHYUK LEE</name></author><entry><title type="html">CHAPTER02:Xcode - 1. 통합개발 환경</title><link href="http://localhost:4000/swift-grammar/2-1/" rel="alternate" type="text/html" title="CHAPTER02:Xcode - 1. 통합개발 환경" /><published>2020-10-03T00:00:00+09:00</published><updated>2020-10-03T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/2-1</id><content type="html" xml:base="http://localhost:4000/swift-grammar/2-1/">&lt;h1 id=&quot;1-통합개발-환경&quot;&gt;1. 통합개발 환경&lt;/h1&gt;

&lt;p&gt;오브젝티브-C는 20여 년 동안 애플의 주력 개발 언어로 사용된 만큼 튼튼한 아키텍처와 검증된 성능을 가지고 있다. 이런 오브젝티브-C를 대체할 목적으로 스위프트가 출현했을 때 많은 사람의 관심은 과연 스위프트가 오브젝티브-C를 대체할 수 있을까였다. 언어를 대체한다는 것은 기존 언어가 담당하던 모든 역할을 처리할 수 있는 역량이 되어야 가능하다. 이런 점에서 스위프트를 이야기할 때 오브젝티브-C와의 비교는 빠질 수 없다. 애플에 의해 탄생한, 형제라면 형제일 수 있는 두 언어 사이의 공통점과 차이점에 대해서 알아보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;11-통합개발-환경-이전의-프로그래밍&quot;&gt;1.1 통합개발 환경 이전의 프로그래밍&lt;/h2&gt;

&lt;p&gt;블라블라블라블라&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER01:스위프트 - 3. 오브젝티브-C vs 스위프트</title><link href="http://localhost:4000/swift-grammar/1-3/" rel="alternate" type="text/html" title="CHAPTER01:스위프트 - 3. 오브젝티브-C vs 스위프트" /><published>2020-09-27T00:00:00+09:00</published><updated>2020-09-27T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/1-3</id><content type="html" xml:base="http://localhost:4000/swift-grammar/1-3/">&lt;h2 id=&quot;3-오브젝티브-c-vs-스위프트&quot;&gt;3. 오브젝티브-C vs 스위프트&lt;/h2&gt;

&lt;p&gt;오브젝티브-C는 20여 년 동안 애플의 주력 개발 언어로 사용된 만큼 튼튼한 아키텍처와 검증된 성능을 가지고 있다. 이런 오브젝티브-C를 대체할 목적으로 스위프트가 출현했을 때 많은 사람의 관심은 과연 스위프트가 오브젝티브-C를 대체할 수 있을까였다. 언어를 대체한다는 것은 기존 언어가 담당하던 모든 역할을 처리할 수 있는 역량이 되어야 가능하다. 이런 점에서 스위프트를 이야기할 때 오브젝티브-C와의 비교는 빠질 수 없다. 애플에 의해 탄생한, 형제라면 형제일 수 있는 두 언어 사이의 공통점과 차이점에 대해서 알아보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;파일 통합&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 C를 기초로 하여 만들어진 언어이므로 파일 구조도 C 문법을 따라 헤더 파일과 소스 파일로 구분된다. .h 확장자로 작성되는 헤더 파일은 변수나 상수에 대한 선언, 인터페이스에 대한 정의가 작성되고, .m 확장자로 작성되는 소스 파일은 헤더 파일에서 정의한 인터페이스를 구현하는 내용이 작성된다. 선언과 구현이 분리되는 형태이다. 그러나 스위프트는 헤더 파일과 소수 파일이 모두 .swift 확장자를 갖는 파일 하나로 통합되어있다. 변수나 상수, 각종 객체의 형식에 대한 선언과 실질적인 내용 구현이 모두 하나의 파일에서 이루어진다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;클래스의 정의와 구현&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;클래스를 작성할 때 오브젝티브-C는 헤더 파일에 클래스의 인터페이스를 정의하고, 소스파일에서는 정의된 인터페이스를 구현한다. 그러나 스위프트에서는 클래스의 인터페이스 정의 없이 바로 클래스를 구현하면 된다. 또한 오브젝티브-C는 반드시 클래스 선언 시 반드시 상위 클래스를 상속 받아야 하며, 아무것도 상속받을 필요가 없을 때라도 최상위 클래스인 NSObject를 상속받아야 하지만, 스위프트에서는 상속받아야 할 클래스가 없다면 아무것도 상속받지 않아도 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;상속&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 다중 상속을 지원하지 않지만, 자바의 인터페이스(Interface)에 해당하는 개념인 프로토콜(Protocol)을 정의하여 클래스 객체가 준수해야 할 형식을 제공할 수 있다. 또한 카테고리(Category) 개념을 통해 상속 대신 기존 객체 자체를 직접 확장할 수 있다.&lt;/p&gt;

&lt;p&gt;스위프트도 마찬가지이다. 다중 상속을 지원하지 않으며 프로토콜을 정의할 수있다. 또한, 기존 객체를 직접 확장할 수있도록 Extention이 제공되는데, 이는 오브젝티브-C의 카테고리에 대응하는 개념이다. 단, 그보다는 더 넓고 강력한 개념으로 오브젝티브-C에서 클래스 객체만 확장할 수 있었던 카테고리에 비해 스위프트의 Extention은 클래스, 구조체, 프로토콜 등 대부분 객체에 사용할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;범용 타입&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;개발의 편의와 효율성을 높이기 위해 모든 데이터 타입을 저장할 수 있는 범용 타입 객체가 필요할 때가 있는데, 오브젝티브-C에서는 이와 같은 범용 타입으로 id 타입을 제공한다. id 타입은 모든 타입의 데이터를 저장할 수 있을 뿐만 아니라, 호환성만 보장된다면 저장된 데이터를 어떠한 타입으로든 변환할 수 있는 특성을 가지고 있다. 코코아 프레임워크나 코코아 터치 프레임워크에서는 범용 타입을 이용한 API들이 많이 사용되고 있다.&lt;/p&gt;

&lt;p&gt;스위프트 역시 동일한 코코아 프레임워크나 코코아 터치 프레임워크를 사용하기 때문에, 오브젝티브-C의 id 타입에 대응하는 범용 타입의 객체가 필요하다. 이 때문에 제공되는 것이 Any 타입과 AnyObject 클래스이다. Any는 구조체, 클래스, 열거형, 함수 등 스위프트에서 제공하는 모든 타입의 값을 저장할 수 있는 타입인 반면, AnyObject는 클래스에 한해 범용으로 사용 가능한 데이터 타입이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;메소드 호출&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 스몰토크의 문법을 차용한 결과, 메소드 호출을 메시지 전송 방식으로 처리한다. 즉, 객체의 메소드를 호출하는 대신 객체에 메시지를 보내서 필요한 기능을 처리한다. 객체와 메시지는 공백을 통해 연결되며 대괄호([])를 사용하여 메시지 전송 단위를 감싸서 구분한다. 이런 스몰토크의 문법이 낯설거나 익숙하지 않은 사람들이 많아서 오브젝티브-C를 다룰 때에는 종종 주의가 필요하기도 했다.&lt;/p&gt;

&lt;p&gt;그러나 스위프트는 일반적인 객체지향에서의 메소드 호출 방식을 따른다. 객체와 메소드 사이는 점(.)을 통해 연결되고, 메소드 호출 단위를 감싸는 구분자는 사용하지 않는다. 아래는 오브젝티브-C와 스위프트에서의 메소드 호출 방식 예제이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;오브젝티브-C에서의 메소드 호출
    &lt;div class=&quot;language-objectivec highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;인스턴스명&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;스위프트에서의 메소드 호출
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;인스턴스명&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;incrementBy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;nil의 의미&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C에서는 존재하지 않는 객체에 대한 참조를 위해 nil이라는 상수를 사용한다. nil과 NULL의 차이에 대해 궁굼해 하는 사람들이 있는데, 엄격하게 말해서 오브젝티브-C에서 정의된 nil 상수와 C에서 정의된 NULL 상수 간에 차이는 있지만, 오브젝티브-C 문법에서 두 상수는 기술적으로 혼용할 수 있다. 일반적으로 nil은 클래스 객체를 참조하는 데에 사용되고, NULL은 그 밖에 다른 포인터 자료형에 사용된다.&lt;/p&gt;

&lt;div class=&quot;language-objectivec highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 객체의 빈 참조에 사용되는 nil&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;UIViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uvc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 포인터 자료형의 빈 참조에 사용되는 NULL&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sPtr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반면, 스위프트에서 nil은 옵셔널 타입의 기본값으로 사용되며 &lt;strong&gt;‘값이 존재하지 않음’&lt;/strong&gt;을 의마한다. 스위프트에서는 NULL 상수가 정의되어 있지 않다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 옵셔널 타입의 기본값으로 nil이 대입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;포인터 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 C의 포인터 문법을 그대로 물려받았다. 객체에 대한 인스턴스 변수를 정의할 때에는 항상 포인터를 사용하는 레퍼런스 참조를 기본으로 사용했다. 모든 변수 앞에 포인터를 거의 의무적으로 붙여주다 보니, 오브젝티브-C에서 포인터를 사용한다고는 해도 C 코드를 직접 작성하는 부분을 제외하면 크게 신경 쓸 부분이 없기는 했지만, 그럼에도 포인터를 사용해야 한다는 것은 초보자들에게는 적지 않은 부담으로 작용했다.&lt;/p&gt;

&lt;p&gt;스위프트에서는 이러한 포인터 개념을 제거하여 개발자가 직접 레퍼런스를 참조하지 않도록 하는 대신, 객체의 종류에 따라 컴파일러가 직접 레퍼런스를 참조할 것인지 아니면 객체를 복사할 것인지를 결정한다. 클래스틑 포인터를 사용하지 않아도 자동으로 레퍼런스를 참조하고, 구조체는 객체를 복사하여 사용하는 방식으로 처리된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향 타입&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 객체지향을 위한 타입으로 클래스를 제공한다. @Interface 어노테이션을 이용하여 형식을 선언하고, @Implementation 어노테이션을 이용하여 실질적인 내용을 구현한다. 이렇게 작성된 클래스를 사용할 때에는 인스턴스를 생성하여 사용한다.&lt;/p&gt;

&lt;p&gt;그러나 스위프트에서는 객체지향용 타입으로 클래스뿐만 아니라 구조체, 열거형까지 제공한다. 이들 객체 타입은 모두 인스턴스를 만들 수 있으며 인스턴스와 관련된 변수, 상수를 속성(property)으로 선언하여 사용할 수 있다. 그뿐만 아니라 이들 객체 타입에 인스턴스 메소드와 타입 메소드를 작성하여 사용할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 클래스 (Class)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SampleClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 구조체 (Structure)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SampleStruct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 열거형 (Enumeration)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SampleEnum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;익명 함수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;현대 프로그래밍 개념에서 익명 함수의 사용은 람다 함수를 사용할 수 잇게 해주는 리스프, 스킴 같은 함수형 프로그래밍 언어로부터 도입되었다고 할 수 있다. 람다 함수는 함수 기반으로 정의되는 코드 내에서 한 번만 사용하면 되는 코드마저 함수로 선언해서 사용해야 하는 번거로움을 피할 수 있게 해줌으로써 코드를 더욱 간결하게 만들어 준다.&lt;/p&gt;

&lt;p&gt;람다 함수는 최근 자바 8에서도 도입되는 등 프로그래밍 언어의 강력한 기능으로 고려되고 있다. 오브젝티브-C에서는 블록(Block)이라는 개념으로 익명 함수를 표현할 수 있었는데, 이 기능이 스위프트에서는 클로저를 이용한 익명 함수 정의 문법으로 제공된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;오류 처리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일반적으로 객체 지향 언어에서 제공하는 오류 처리 기능은 오류 발생이 예상되는 지점에 미리 오류를 검출하는 코드를 작성해두고, 실제로 오류가 발생했을 때 정해진 코드 블록 바깥으로 오류 정보를 던져 처리할 수 있도록 지원하는 방식이다. 오브젝티브-C에서도 오류를 검출하기 위한 기능은 제공되었지만, 이는 읽고 쓸 수 있는 매개변수를 사용하여 오류를 검출해내는 방법이었을 뿐 오류 처리를 위한 구문이 별도로 제공된 것은 아니었다.&lt;/p&gt;

&lt;p&gt;스위프트는 2.0 버전부터 오류를 검출해내고 각 오류에 효과적으로 대응할 수 있도록 전용 구문을 제공하고 있다. 많은 프로그래밍 언어에서 널리 사용하는 Try ~ Catch 구문을 채택한 스위프트는 코드를 실행하는 과정에서 오류가 발생하더라도 프로그램이 중단되는 것을 막아주고, 미리 준비된 대응 구문을 실행하여 효율적으로 오류에 대응할 수 있게 한다.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER01:스위프트 - 2.스위프트 언어의 특징</title><link href="http://localhost:4000/swift-grammar/1-2/" rel="alternate" type="text/html" title="CHAPTER01:스위프트 - 2.스위프트 언어의 특징" /><published>2020-09-25T00:00:00+09:00</published><updated>2020-09-25T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/1-2</id><content type="html" xml:base="http://localhost:4000/swift-grammar/1-2/">&lt;h2 id=&quot;2-스위프트-언어의-특징&quot;&gt;2. 스위프트 언어의 특징&lt;/h2&gt;

&lt;p&gt;상대적으로 언어에 대한 진입장벽이 낮고 개발하기 쉬운 자바스크립트나 파이썬, 루비와 같은 동적 바인딩 타입의 언어는 생산성이 좋지만 성능이 부족한 경우가 많고, 성능이 좋은 언어일수록 진입 장벽이 높고 개발하기 어려워 생산성이 낮은 경우가 많다. 이에 비해 스위프트는 개발 생산성과 앱 성능 모두에서 만족할 만한 결과를 가져오는 언어로 포지셔닝되어있다.&lt;/p&gt;

&lt;p&gt;스위프트가 파이썬이나 자바스크립트처럼 동적 바인딩(Dynamic Binding)을 채용하고 있는 언어는 아니다. C, C++, 오브젝티브-C, 자바처럼 정적 바인딩을 채용하고 있다. 비록 데이터 타입 추론 기능에 의해 컴파일러가 알아서 변수와 상수의 타입을 결정하기 때문에 마치 동적 바인딩 언어인 것처럼 착각되기도 하지만, 기본적으로 스위프트는 정적 바인딩 언어이다.&lt;/p&gt;

&lt;p&gt;스위프트는 데이터 타입에 대한 구분이 엄격하다. 스위프트에서 선언된 변수와 상수는 컴파일 단계에서 데이터 타입이 미리 정의되어 있어야 하고, 변수의 데이터 타입이 정의되면 다른 타입으로 변경할 수 없다. 이러한 엄격성을 바탕으로 컴파일러는 타입에 맞지 않는 데이터가 변수에 대입되는 것을 사전에 차단하여 안정성을 높일 수 있다.&lt;/p&gt;

&lt;p&gt;스위프트는 네임스페이스를 사용하여 필요한 객체들으 참조하는데, 일반적으로 프로젝트 전체가 네임스페이스의 범위로 지정된다. 이는 같은 프로젝트 내에 작성된 객체일지라도 오브젝티브-C에서는 참조를 위해 일일이 헤더 파일을 반입해 주어야 했던 것과 다르게, 스위프트에서는 같은 프로젝트 내에 작성된 객체들은 반입 과정 없이 참조할 수 있다는 뜻이다. 이 때문에 스위프트에서 import 구문은 UIKit, Foundation 등의 프레임워크나 라이브러리 정도에만 사용하게 되어 개발 생산성을 향항할 수 있게 되었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;21-스위프트-언어에서-차용하고-있는-주요-기능들&quot;&gt;2.1 스위프트 언어에서 차용하고 있는 주요 기능들&lt;/h3&gt;

&lt;p&gt;세상에 존재하는 수많은 프로그래밍 언어 대부분이 그렇겠지만, 특히 현대에 와서 발표되는 언어 중 전적으로 새로운 언어는 거의 없다고 해도 과언이 아니다. 대부분의 언어는 앞선 시대의 언어에서 아이디어를 차용하여 자신의 것으로 발전시키고, 시간이 지나면 또 다른 언어가 이를 차용하는 과정이 반복된다.&lt;/p&gt;

&lt;p&gt;기술적으로 새롭다고 할 수 있는 스위프트이지만, 사실 알고 보면 다른 언어에서 채택된 개념들을 새로운 이름으로 조합한 것에 지나지 않는다. 이런 관점에서 마국의 IT 전문 저술가 피터 웨이너(Peter Wayner)는 InfoWorld.com에서 애플이 스위프트를 만들면서 주변 언어로부터 차용한 10가지 개념과 특징들에 관해 이야기 하고 있다. 이 글을 인용하여 스위프트의 특성을 다른 언어들과 비교해 보겠다. 다른 언어를 익힌 분들이라면 이 설명을 통해 스위프트의 특징에 대해 더욱 잘 이애할 수 있을 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;딕셔너리(해시 테이블) - 자바스크립트, 파이썬&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바스크립트 프로그래머들은 대괄호 구문을 이용해 값을 배열로 만들거나 문자열을 입력받는데, 이것이 해시 테이블 역할을 한다. 스위프트도 마찬가지이다. 대괄호를 사용하여 해시 테이블을 만들 수 있다. 애플에서는 이것을 ‘딕셔너리(Dictionaries)’라고 부르며, 초기화할 수 있는 구문을 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;airports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?]()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;airports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ICN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Inchon International Airport&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// If close &quot;Inchon International Airport&quot;, then delete it&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;airports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ICN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ICN has now benn removed from the dictionary&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 타입 추론 - 함수형 프로그래밍 언어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그래머 관점에서 변수를 특정 데이터 형식으로 강제하면 코드를 실행해 보기 전에 버그를 미리 잡을 수 있어 효율적이다. 컴파일러가 데이터 형식을 확인하고 비호환성이 발견되면 오류를 검출해주기 때문이다. 편리함을 추구하는 프로그래밍에서 모든 변수마다 데이터 형식을 일일이 지정하는 고생을 감수할 사람은 그다지 많지 않다.&lt;/p&gt;

&lt;p&gt;최근의 우수한 컴파일러들은 데이터로부터 스스로 형식을 추론할 수 있으므로 컴파일러가 알아서 변수에 데이터 형식을 지정할 수 있게 되었다. 이러한 움직임은 ML과 같은 함수형 언어부터 시작 됐으며, 이후 하스켈, 스칼라, 오파 등의 언어에도 등장했다. 마이크로소프트까지도 이같은 추론 기능을 닷넷 프레임워크에 추가한 만큼 이제는 주류 기능이라고 할 만하다. 데이터 타입은 강제하지만, 데이터 타입을 생략할 수 있는 스위프트 컴파일러의 발전 덕분에 iOS 개발자들도 이제 코드 입력에 드는 수고를 조금은 덜 수 있게 되었다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;meaningOfLife&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// meaningOfLife is inferred to be of type Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;자동 참조(가비지 콜렉터 비슷) - 자바, C#, 오브젝티브-C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가비지 콜렉터는 메모리를 탐색하면서 더는 사용되지 않는 메모리 영역을 회수하는 자동 루틴으로, GC라고 불리기도 한다. 자바와 C# 프로그래머들은 가비지 콜렉터를 무척 좋아하지만, 때로는 가비지 콜렉터 때문에 프로그램이 잠깐 멈추는 현상이 발생해 스트레스를 받기도 한다. 가비지 콜렉터의 결과로 가용 메모리가 다시 늘어나는 장점이 있는 반면, 가비지 콜렉터를 실핼하는 동안 프로세스는 원활한 진행을 방해받는다는 단점도 있다.&lt;/p&gt;

&lt;p&gt;스위프트는 자동 참조 카운트(ARC - Auto Referencing Counter)를 사용하는데, 이는 오브젝티브-C 사용자들 사이에서 널리 사용된 것과 비슷한 솔루션이다. 이 기능은 오브젝티브-C에서 물려받았다고 할 만한 기능이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;부호 있는 정수와 부호 없는 정수 - C#과 오브젝티브-C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;좋은 시스템 프로그램이란 바이트 레벨에서 작동하는 프로그랴ㅐㅁ을 의미하는 경우가 많다. 자바와 같은 일부 추상적 언어는 부호 없는 정수의 복잡성을 회피했지만, C# 언어는 이를 수용했다. 스위프트 역시 1, 2, 4, 8바이트의 부호 없는 정수와 부호 있는 정수를 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;pink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UInt32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xCC6699&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;redComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xFF0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// redComponent is 0xCC, or 204&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;greenComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x00FF00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// greenComponent is 0x66, or 102&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;blueComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000FF&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// blueComponent is 0x99, or 153&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;클로저(Closure) - 리스프와 스킴에서 자바스크립트까지&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바스크립트 프로그래머는 소량의 코드를 묶어서 함수처럼 전달하는 클로저를 사용할 수 있다. 이러한 클로저는 람다 함수 아이디어를 개발한 리스프, 스킴과 같은 언어에서 가져온 것이다. 스위프트는 클로저를 제공할 뿐만 아니라 함수를 1급 객체로 간주, 인자값으로 함수 자체를 전달하는 기능을 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;numbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;멀티 라인 쿼우팅(Multi-Line Quoting)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파이썬 프로그래머들은 세 개의 따옴표를 겹친 “”” ~ “”” 를 이용해 여러 줄의 문자열을 간편하게 입력해 왔다. 줄바꿈이나 범위에 삼관없이 “&quot;”로 시작하고 “&quot;”로 닫기만 하면 그 안에 표현된 모든 문자열(공백까지 포함한)이 그대로 처리된다는 장점 덕분에 긴 문자열을 입력할 때 요긴하게 사용되어 왔다. 스위프트 4 버전에서는 파이썬의 이와 같은 멀티 라인 쿼우팅 문법을 거의 그대로 도입했다. 파이썬처럼 큰따옴표 세 개 겹친 “&quot;”로 문자열의 시작과 끝을 나타내는 방식으로 우리는 여러 줄의 문자열을 간편하게 입력할 수 있게 되었다. 이는 여러 줄의 문자열을 입력하기 위해 더이상 문자열 내부에 인위적인 줄바꿈 문자(‘\n’)를 넣어주지 않아도 된다는 뜻이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
    SELECT member_id, member_name, member_level, nick_name
    FROM member
    WHERE login_id = ? AND password = ?
&quot;&quot;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;22-구조적-특징&quot;&gt;2.2 구조적 특징&lt;/h3&gt;

&lt;p&gt;스위프트의 발표 자료에 따른 스위프트 언어의 구조적 특징은 여섯 가지 정도로 구분된다. 이들 특성은 스위프트가 지향하는 방향성이기도 하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;빠름(Fast)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스위프트는 매우 빠른 언어로, 복합정렬 연산에서 오브젝티브-C보다 빠른 성능을 나타낸다. 애플에서는 고성능 앱을 만들기 위해 GCC 대신 LLVM 컴파일러를 사용해오고 있는데, 이 컴파일러에서 제공하는 코드 최적화기를 사용하여 소스 컴파일과 최적화를 수행함으로써 스위프트의 성능을 극대화할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;설계에 의한 안정성(Safety by Design)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스위프트는 언어 차원에서 안전성을 담보하기 위한 설계로 여러 장치를 해 두었다. 변수나 상수는 반드시 선언한 후에 사용하도록 강제하였으며 타입 추론 기능에 의해 변수의 초기값을 기준으로 타입을 정의함으로써 데이터 입력에 대한 안전성을 높이고자 하였다. 배열과 정수는 오버플로우에 대비하여 확인하며, 특히 개발자가 정의하지 않은 배열 값에 승인하지 않은 값들이 주입될 수 없도록 Array bounds check 기능을 추가하였다.&lt;/p&gt;

&lt;p&gt;여기에 더하여 스위프트는 포인터에 직접 접근하는 시도를 차단하고, 클래스를 통해 간접적으로만 레퍼런스를 참조할 수 있도록 제한했다. 스위프트는 ARC를 이용하여 자동으로 메모리를 관리하므로 메모리 누수 현상에 대한 안전성도 높일 수 있다. 이처럼 설게 수준에서 안전성을 구현하는 것이 스위프트의 구조적 특징 중 하나이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;현대적(Modern)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스위프트는 파이썬 언어에 기반을 둔 읽고 쓰기 쉬운 문법을 채택하였다. 그 결과, 코드 작성이나 디버깅, 유지보수 과정에서 기존의 오브젝티브-C보다 훨씬 적은 양의 코드가 사용된다. 손쉬운 유지보수를 위해 헤더 파일 사용 대신 메인 파일에 통합하여 코드를 작성할 수 있도록 섳계되었다. 스위프트는 옵셔널(Optional), 제네릭(Generics), 클로저(Closure), 튜플(Tuple)뿐만 아니라 현대 프로그래밍 언어의 특성까지도 상당수 포함하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;상호반응(Interactive)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Xcode 6 버전부터 애플은 스위프트 코드의 프로토타이핑을 위해 플레이그라운드 편집기를 제공한다. 스위프트 코드를 작성하고, 그 결과와 메모리 스택 등의 정보 확인을 즉시 확인할 수 있어 상호반응적으로 코드를 작성할 수 있으며 디버깅도 무척 쉽다. 이러한 특징은 스위프트를 이용한 코딩의 효율성을 한껏 높였다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전한 플랫폼(Complete Platform)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;단순히 보조적인 수준으로만 스위프트를 사용할 수 있는 것이 아니라, 코코아 프레임워크나 코코아 터치 프레임워크의 모든 API를 스위프트로 호출할 수 있다. 오브젝티브-C로 작성되었던ㄴ 핵심 프레임워크의 모든 라인이 스위프트 언어를 이용하여 거의 모두 재작성되었고, 이를 이용하면 오브젝티브-C 코드에 의존하지 않고도 프로그램을 작성할 수 있다는 것은 애플의 발표에 의해 널리 알려진 사실이다. 스위프트만으로 하나의 완전한 앱을 만들 수 있다는 의미이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;통홥(Unified)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스위프트는 C 언어나 오브젝티브-C 언어를 완전히 대체할 수 있다. 스위프트는 객체지향 언어의 특성을 모두 제공하는 동시에 자료형과 흐름 제어, 연산자 같은 저수준 언어의 기본 요소들도 모두 포함한다. 하나의 앱 프로젝트에서 오브젝티브-C와 함께 사용할 수 있도록 통합성도 지니고 있다. 오브젝티브-C 객체를 스위프트에서 참조할 수 있으며, 각각의 화면별로 오브젝티브-C 또는 스위프트로 나누어 작성하는 것도 가능하디.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER01:스위프트 - 1.스위프트 언어의 탄생과 배경</title><link href="http://localhost:4000/swift-grammar/1-1/" rel="alternate" type="text/html" title="CHAPTER01:스위프트 - 1.스위프트 언어의 탄생과 배경" /><published>2020-09-23T00:00:00+09:00</published><updated>2020-09-23T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/1-1</id><content type="html" xml:base="http://localhost:4000/swift-grammar/1-1/">&lt;h2 id=&quot;1-스위프트-언어의-탄생과-배경&quot;&gt;1. 스위프트 언어의 탄생과 배경&lt;/h2&gt;

&lt;p&gt;스위프트(Swift)는 애플이 2014 세계 개발자 대회(WWDC)에서 발표한 iOS나 macOS 앱 개발의 새로운 언어이다. 그동안 앱을 개발하는 데에 사용되던 오브젝티브-C를 대체할 목적으로 발표되었다.&lt;/p&gt;

&lt;p&gt;애플의 이전 주력 언어였던 오프젝티브-C는 C언어를 기초로 하여 스몰토크의 메시지 전달 개념과 객체지향 개념을 반영한, 객체지향형 C 언어이다. C 언어의 장점이자 단점인 포인터 개념은 오브젝티브-C를 강력한 언어로 만들어주긴 했지만, 처음 접근하는 사람에게는 그만큼 높은 장벽으로 작용한 것도 사실이다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어를 익히는 데에만 수개월이 걸리다 보니, 앱을 개발하기 위해 언어만 죽어라 익히다 포기하는 일이 잦았다. 언어 자체가 어렵다 보니 앱의 다양한 기능에 집중해야 할 개발자가 성능 개선에 더 많은 노력과 시간을 소모하는 현상을 가져왔다.&lt;/p&gt;

&lt;p&gt;애플은 앱 개발자들이 기능적으로 더 다양한 종류의 앱을 만들기를 원했다. 개방성을 강력한 무기로 내세우는 구글의 안드로이드에 점차 스마트폰 시장을 잠식당하고 있는 상황에서, 어떤 방식으로든 다시 앱스토어의 콘텐츠 다양성을 무기로 하는 시장 지배력을 갖추고 싶어했다. 현재 개발자뿐만 아니라 아이디어를 가진 많은 잠재적 개발자들까지 마음만 먹으면 손쉽게 앱을 구현할 수 있는 환경을 만들어주는 것이 당연한 과제였다.&lt;/p&gt;

&lt;p&gt;이러한 목적에 맞추어 기능이 아니라 성능에 관련된 많은 부분, 특히 코드 최적화나 메모리 관리, 성능 관리 등의 기술 경험 기반 개발 이슈를 시스템이 전담하여 개발자들의 부담을 덜어주는 것이 가장 중요했다. 아이디어를 가진 많은 사람이 기술에 제한받지 않고 마음껏 아이디어를 구현할 수 있는 손쉬운 개발 환경을 만들어 주고 싶었던 것이다.&lt;/p&gt;

&lt;p&gt;이런 목표를 위해서 만들어진 언어 플랫폼이 바로 스위프트이다. 스위프트는 기존의 오브젝티브-C가 C 언어로부터 가져온 저수준 프로그래밍을 자동 관리 영역으로 대체했고, 생소한 문법이지만 객체지향을 위해 사용할 수 밖에 없었던 스몰토크의 메시지 문법을 사람들에게 익숙한 자바, 파이썬, C#의 문법으로 바꾸었으며, 오브젝티브-C와 호환까지 가능하도록 설계되는 등 여러 가지 언어적 강점을 지녔다.&lt;/p&gt;

&lt;p&gt;오브젝티브-C가 고급 개발자를 대상으로 사용된 언어라면 스위프트는 개발에 갓 입문하는 사람들까지 무리 없이 사용할 수 있는 언어이다. 그 대표적인 기능이 바로 인터랙티브 플레이그라운드이다.&lt;/p&gt;

&lt;p&gt;직관적으로 코드를 작성하여 그 결과까지 볼 수 있는 플레이그라운드는 왼쪽의 편집 창에서 코드를 작성하면 중간 결과물을 보여줄 뿐만 아니라 즉석에서 컴파일하여 처리 결과까지 제공한다. 단순히 텍스트 결과를 나타내는 것만이 아니다. 반복적인 증감값의 경우 그래프를 통해 직관적인 결과를 볼 수 있도록 처리해 주며, 필요에 따라 다양한 멀티미디어 객체를 사용하여 풍부한 사용자 정보를 제공해 주기도 한다. 직관적인 사용자 인터페이스를 통해 쉬운 접근을 추구하는 애플의 철학이 반영된 결과물이다.&lt;/p&gt;

&lt;p&gt;기술적인 관점에서 스위프트는 애플의 메인 프레임워크인 코코아 프레임워크와 코코아 터치 프레임워크 모두 사용할 수 있다. LLVM 컴파일러, 옵티마이저, 오토백터링, ARC 메모리 관리, 런타임 환경 등을 기존 언어의 개발 환경과 거의 동일하게 사용할 수 있다는 장점도 있다. 이처럼 다양한 강점을 통해 스위프트는 점차 iOS 앱 개발의 강력한 플랫폼 언어로서 자리매김하고 있다.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">[git] 버전 관리 무시 목록(.gitignore) 설정</title><link href="http://localhost:4000/git/1/" rel="alternate" type="text/html" title="[git] 버전 관리 무시 목록(.gitignore) 설정" /><published>2020-08-12T00:00:00+09:00</published><updated>2020-08-12T00:00:00+09:00</updated><id>http://localhost:4000/git/1</id><content type="html" xml:base="http://localhost:4000/git/1/">&lt;h1 id=&quot;gitignore&quot;&gt;.gitignore&lt;/h1&gt;

&lt;h2 id=&quot;1-위험성&quot;&gt;1. 위험성&lt;/h2&gt;
&lt;p&gt;특정 파일은 git에서 버전 관리 대상에서 제외해야 합니다.&lt;/p&gt;

&lt;p&gt;프로젝트를 업로드할 때 개인키가 프로젝트 폴더내에 있을 수 있고, 이런 중요한 설정 정보는 git 저장소에 추가하지 말아야 합니다.&lt;/p&gt;

&lt;p&gt;이로인해서 해킹에 대상이 될 수 있고, 심각한 피해를 입을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;2-해결방안&quot;&gt;2. 해결방안&lt;/h2&gt;
&lt;p&gt;git 에는 이러한 문제를 방지하기 위한 무시 목록을 작성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;.gitignore 에 작성된 파일은 git add 명령시 제외됩니다.&lt;/p&gt;

&lt;h2 id=&quot;3-작성법&quot;&gt;3. 작성법&lt;/h2&gt;
&lt;p&gt;.gitignore 의 각 라인에 무시할 파일 또는 디렉토리의 패턴을 적습니다.&lt;/p&gt;

&lt;p&gt;여러 파일을 한번에 지정할 경우 * 을 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jdbc.properties
*.class
*.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 작성하면 git add 명령어를 실행했을 때 jdbc.properties 파일을 제외하며, .class와 .jar 확장자를 가진 파일을 모두 무시합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이미 추가되어 버전 관리중인 파일에는 영향을 미치지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;4-응용&quot;&gt;4. 응용&lt;/h2&gt;
&lt;p&gt;만약 .gitignore 목록에 있는 파일을 추가해야 할 경우 -f 옵션을 이용해 추가할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add -f jdbc.properties
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;.gitignore 에 설정한 내용은 하위 디렉토리에도 동일하게 적용됩니다.&lt;/p&gt;

&lt;p&gt;만약 특정 하위 디렉토리가 다른 ignore 를 적용해야 할 경우 해당 디렉토리에 .gitignore 을 새로 만들어줍니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*
!jdbc.properties
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 .gitignore 을 새로 만들어 config 폴더에 넣을 경우, 기본적으로 config 의 모든 파일을 무시하면서 jdbc.properties 라는 파일은 버전을 관리합니다. !는 이전의 ignore 패턴을 무효화 하는 문자열입니다.&lt;/p&gt;

&lt;p&gt;만약 파일명에 ! 가 들어갈 경우 escape 문자인 \ 를 ! 앞에 붙여줍니다.&lt;/p&gt;

&lt;h2 id=&quot;5-gitignoreio&quot;&gt;5. gitignore.io&lt;/h2&gt;
&lt;p&gt;사용하는 운영체제, IDE, 언어마다 추가하는 패턴들이 있으며 이를 매번 기억하여 입력하는 것은 매우 귀찮습니다.&lt;/p&gt;

&lt;p&gt;이런 귀찮은 일을 대신 처리해주는 &lt;a href=&quot;https://www.toptal.com/developers/gitignore&quot;&gt;gitignore.io&lt;/a&gt; 라는 서비스가 있습니다.&lt;/p&gt;

&lt;p&gt;일반적으로 사용되는 무시 패턴을 해당 서비스를 통해 작성하고, 추가적으로 필요한 부분만 무시 목록을 작성하면 편리하게 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;6-참고&quot;&gt;6. 참고&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/docs/gitignore&quot;&gt;https://git-scm.com/docs/gitignore&lt;/a&gt;&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="git" /><category term="git" /><summary type="html">git의 버전 관리 무시 목록에 대해 다룹니다.</summary></entry><entry><title type="html">이력서 작성하기</title><link href="http://localhost:4000/resume/1/" rel="alternate" type="text/html" title="이력서 작성하기" /><published>2020-08-07T00:00:00+09:00</published><updated>2020-08-07T00:00:00+09:00</updated><id>http://localhost:4000/resume/1</id><content type="html" xml:base="http://localhost:4000/resume/1/">&lt;h2 id=&quot;이력서&quot;&gt;이력서&lt;/h2&gt;

&lt;p&gt;이직을 하기 위해서 계속 이력서를 작성해왔다.
채용 사이트인 원티드의 양식을 이용하여 가장 기본적인 내용들을 작성하였고 내용은 계속해서 수정하는 방식으로 작성했다.&lt;/p&gt;

&lt;p&gt;이렇게 작성한 이력서를 통해서 많은 곳에 지원서를 넣어보았고, 합격을 하기도 했다. 
당연하게도 불합격도 있었고 그 수는 적은편이 아니었다고 생각한다. 
요즘에는 이력서는 엉망이 아니라면 패스시키고, 코딩테스트로 변별력을 확보하려는 회사가 많은 것 같은데, 나의 합격 이력서들도 그런식으로 합격한 것이 대다수일 것 같았다.&lt;/p&gt;

&lt;p&gt;이전에 수기로 작성하던 이력서와 달리 요즘에 작성하는 자유양식의 이력서는 사람마다 모두 다르다. 그래서 나만의 독특한 이력서를 만드는 것이 도움이 될지도 모른다.
하지만 가장 중요한 것은 이력서 본래의 목적에 부합하고, 기본적인 내용들이 충실한 것이 중요하다고 생각한다.&lt;/p&gt;

&lt;p&gt;어딘가에 예시로 올라온 이력서를 제외하고서 생각보다 다른 사람의 이력서를 보는 기회가 잘 없다.
그래서 다른 사람이 어떻게 이력서를 채웠는지, 어떤 내용이 다른지를 비교하기가 쉽지 않았다.
그래서 이력서 작성법에 대한 글들을 기회가 되는대로 읽어보았고, 공통되는 부분이 상당히 많다는 것을 알게되었다.&lt;/p&gt;

&lt;p&gt;관계가 있는지는 잘 모르겠지만 글쓰기가 서툰? 개발자가 이력서를 작성할 때, 나와 똑같은 맨땅의 헤딩을 하기보다는 이 글을 읽는 것이 도움이 되지 않을까 싶어서 요약정리를 시작했다.&lt;/p&gt;

&lt;h2 id=&quot;목적&quot;&gt;목적&lt;/h2&gt;

&lt;p&gt;대부분의 이력서는 면접(인터뷰)를 진행하기 전 먼저 제출하는 문서이다.
채용 프로세스의 1차 관문인 서류전형에서 제출하게 되는 경우가 대부분일 것이다.
당연히 이 서류전형에 통과해야만 2차 관문인 코딩테스트 또는 면접에 도달할 수 있다.
그러면 채용 프로세스의 시작인 이력서의 목적은 채용 담당자의 눈에 띄도록 하여 다음 관문에 나를 초대하도록 하는 것이라고 생각했다.&lt;/p&gt;

&lt;p&gt;우선 채용 담당자가 내 이력서를 읽을 수 있어야 한다.
하루에 수 많은 이력서를 처리하는 채용담당자의 눈에 띄기 위해서는 적당히 눈에 잘 띄며, 읽기 좋은 형식이어야 할것이다.
채용 담당자는 모든 이력서를 꼼꼼하게 읽을 수 없기 때문에 어느정도 눈에 띄는 이력서를 1차적으로 걸러낸 후에 걸러진 이력서들을 조금 더 자세하게 훑어본다고 한다.
중요하거나 내세우고 싶은 부분을 적당히 강조하여 표현하고 가독성이 좋게 작성하는 것이 빠르게 눈에 들어오도록 하는 데도움이 될 것이다.&lt;/p&gt;

&lt;p&gt;추가적으로 나의 이력서를 읽고서 호기심을 느끼도록 해야한다.
다음 단계로 넘어가면 코딩테스트를 통해 나의 실력을 가늠하거나 인터뷰를 통해 실제로 만나서 이야기를 하게 되는데, 그만큼 나에게 더 알고 싶은 부분이 생기도록 만들어야 한다.
이 부분에서는 기존의 경험이나, 실력을 어필하는 것이 도움이 된다고 생각한다.&lt;/p&gt;

&lt;h2 id=&quot;기본&quot;&gt;기본&lt;/h2&gt;

&lt;p&gt;이력서 작성에 있어서 가장 기본적인 수칙들은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 내용에는 사실만을 작성한다.&lt;/li&gt;
  &lt;li&gt;전체 이력서의 길이를 가능한 짧게 작성한다.
    &lt;ul&gt;
      &lt;li&gt;길이가 길수록 퍼져있는 중요한 내용들을 채용 담당자가 자세하게 읽지 못할 가능성이 높다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;줄글로 작성하기보다는 목록으로 작성한다.&lt;/li&gt;
  &lt;li&gt;가독성이 좋은 레이아웃을 채택/제작 하여 작성한다.
    &lt;ul&gt;
      &lt;li&gt;내용의 순서 및 위치, 적당한 여백, 강조 표시 등으로 구성할 수 있다.&lt;/li&gt;
      &lt;li&gt;감이 오지 않는다면 &lt;a href=&quot;https://docs.google.com/document/u/0/?ftv=1&amp;amp;tgif=c&quot;&gt;구글 문서 이력서 템플릿&lt;/a&gt;이나 원티드의 이력서 등을 참고하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;맞춤법을 검사하자.
    &lt;ul&gt;
      &lt;li&gt;맞춤법 검사기를 이용하여 오탈자를 수정하는 작업이 꼭 필요하다.&lt;/li&gt;
      &lt;li&gt;자소설 닷컴의 자소서 작성란의 &lt;a href=&quot;https://www.jasoseol.com/resume&quot;&gt;맞춤법 검사기&lt;/a&gt;를 이용하고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;링크를 추가한 경우 모든 링크가 정상적으로 작동하는지 검사한다.
    &lt;ul&gt;
      &lt;li&gt;github 링크 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PDF형식으로 저장하며 요구하지 않는다면 별도 첨부파일을 첨부하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;채용 담당자는 많은 양의 서류를 검토하기 때문에 하나하나 읽지 않을 가능성이 높고, 결정적으로 해당 파일을 열지 못할 수 있다. (뷰어가 없다거나..)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구성&quot;&gt;구성&lt;/h2&gt;

&lt;p&gt;지원하는 기업, 기업에서의 요구사항, 개인의 성향 등 여러가지 차이로 인해서 구성을 달라질 수 있다.
반드시 아래 구성을 따라야 하는 것은 아니지만 어느정도 보편화된 구성이라고 생각한다.&lt;/p&gt;

&lt;h3 id=&quot;제목&quot;&gt;제목&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;필수로 작성하지 않아도 되지만 한줄로 작성한 제목이 나를 잘 설명할 수 있다면 좋은 임팩트를 줄 수 있다.&lt;/li&gt;
  &lt;li&gt;너무 오글거리지 않게, 기억되기 쉽도록, 호기심을 유발하는 문장이면 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인적사항&quot;&gt;인적사항&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이름, 연락처, 이메일, 블로그 링크 등을 포함하여 적는다.&lt;/li&gt;
  &lt;li&gt;나이, 결혼 여부, 주소 등은 최근 기업에서도 요구하지 않는 경우가 많다. 제외하자.&lt;/li&gt;
  &lt;li&gt;사진의 경우 기업에서 필수로 요구하지 않는 경우가 많아져 넣지 않아도 된다. 하지만 뭔가 공간이 비어보여서 넣었는데, 이왕 넣을 거려먼 직무와 관련된 활동이나, 그나마 잘나왔다고 생각하는 사진을 넣자😂&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;자기소개&quot;&gt;자기소개&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;경력/경험에 대한 내용, 업무나 관련 분야에서의 관심사에 대한 짧은 소개글을 작성한다.&lt;/li&gt;
  &lt;li&gt;2~5줄 정도로 자신이 어떤 사람인지에 대해 작성하되 필요하다면 너무 많지 않은 수준에서 더 작성해도 된다.&lt;/li&gt;
  &lt;li&gt;내용이 길어진다면 문단을 활용하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;경험&quot;&gt;경험&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;회사명, 부서, 직함, 기간, 업무, 기술, 결과(성과 등)을 포함하여 작성한다.&lt;/li&gt;
  &lt;li&gt;자신이 어떤 역량을 보유하고 어떻게 일해왔는지를 보여주는 가장 중요한 부분이라고 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;가장 최근의 경험이 제일 상단에 오도록 작성한다. (최신-과거 순)&lt;/li&gt;
  &lt;li&gt;경험이 회사에서 겪은 경험뿐만 기타 경험이 있다면 세부 카테고리를 나누어 작성하는 것도 좋다.&lt;/li&gt;
  &lt;li&gt;여러명이 참여한 프로젝트의 경우 자신의 역할과 경험을 중심으로 작성하고, 기여도를 작성한다.&lt;/li&gt;
  &lt;li&gt;제대로 진행한 프로젝트만 기입한다. 중요하지 않거나 규모가 너무 작다면 과감하게 제외한다.&lt;/li&gt;
  &lt;li&gt;업무 자체를 성과인 것처럼 작성하면 이력서의 전체적인 인상이 약해지는 역효과를 준다. 그런 내용은 삭제하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;개인-프로젝트&quot;&gt;개인 프로젝트&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;경험 항목과 동일하게 작성하되 없는 경험을 만들거나 짜내어 작성할 필요까지는 없다.&lt;/li&gt;
  &lt;li&gt;프로젝트가 현재 서비스중이라면 해당 링크를 포함시키는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;반대로 서비스를 중지했다면 서비스중지사유를 함께 적어주자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기술&quot;&gt;기술&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;자신이 활용할 수 있는 기술만 적는다.&lt;/li&gt;
  &lt;li&gt;익숙하지 않거나 지나가면서 들어보기만 한 기술, 프로젝트에 사용되었지만 내가 사용하지 않은 기술 등은 제외한다.&lt;/li&gt;
  &lt;li&gt;기술을 사용한 연차, 숙련도 등을 표시할 필요는 없다. 위 경험 항목에서 기술의 정도를 알 수 있게 작성하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;학력&quot;&gt;학력&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;학교, 전공, 입학/졸업 시기 정도를 간략하게 작성한다.&lt;/li&gt;
  &lt;li&gt;학점이나 휴학에 대한 정보는 작성하지 않는다.&lt;/li&gt;
  &lt;li&gt;지원하는 기업이나, 포지션 등에 관련이 있는 논문이나 프로젝트가 있다면 추가적으로 한두 줄 추가해도 좋다.&lt;/li&gt;
  &lt;li&gt;정규 교육, 대학 교육뿐만 아니라 지원한 기업이나 포지션에 관련이 있는 프로그램 수료, 학원 교육 이수, 부트 캠프 등을 적어도 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;피드백&quot;&gt;피드백&lt;/h2&gt;

&lt;p&gt;이력서는 작성자가 아닌 다른 사람이 읽는 문서이다. 아무리 잘 작성했다고 생각해도 다른 사람이 보았을 때 문제가 나타날 수 있다.
이력서를 모두 작성했다면 조금 부끄러워도 주변 사람들에게 피드백 받는 것을 추천한다.
피드백을 받아 부족한 부분을 수정하여 더욱 개선된 이력서를 작성할 수 있다.&lt;/p&gt;

&lt;p&gt;사실 피드백을 받을 때 아무에게나 피드백을 받아서는 큰 의미가 없을 수 있다. 이럴 때 어떤 사람에게 피드백을 받으면 좋을지에 대한 의문이 생긴다.
가장 좋은 피드백을 줄 수 있는 사람은&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내가 일하는 분야에 인사이트가 있는 사람&lt;/li&gt;
  &lt;li&gt;신뢰할 수 있고 솔직하게 피드백을 해줄 수 있는 사람&lt;/li&gt;
  &lt;li&gt;채용을 담당해본 사람&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이라고 생각한다.&lt;/p&gt;

&lt;p&gt;주변에 위와 같은 사람이 전혀 없다면 개발자관련 행사등에 참여하여 기회를 스스로 만들어 내는 방법도 있고, 유명하신 분들에게 메일로 정중히 요청하는 방법도 있다. 피드백을 잘 받았다면 꼭 감사인사를 하도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;이력서-체크리스트&quot;&gt;이력서 체크리스트&lt;/h2&gt;

&lt;p&gt;이력서 작성을 도와주는 체크리스트를 작성할 계획이다. 추후 공개~&lt;/p&gt;

&lt;h2 id=&quot;이력서-관련-글&quot;&gt;이력서 관련 글&lt;/h2&gt;

&lt;p&gt;좋은 이력서 작성을 위해서 많은 글을 읽었다. 그 중 많이 참고하고 좋은 글들을 링크로 공유한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://brunch.co.kr/@wantedlab/29&quot;&gt;인사담당자가 직접 말하는, 서류 통과가 잘 되는 이력서&lt;/a&gt; - 원티드&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://woowabros.github.io/experience/2017/07/17/resume.html&quot;&gt;이직초보 어느 개발자의 력서 만들기&lt;/a&gt; - 구인본(우아한형제들)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.junholee.me/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B4%EB%A0%A5%EC%84%9C-%EC%9E%91%EC%84%B1-%EB%B0%8F-%EB%A9%B4%EC%A0%91-%EC%B0%B8%EA%B3%A0%EC%82%AC%ED%95%AD/&quot;&gt;개발자 이력서 장성 및 면접 참고사항&lt;/a&gt; - JunHo Lee&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://parkscom.tistory.com/1167111262&quot;&gt;취업전선.신입 S/W 개발자를 위한 이력서 쓰기&lt;/a&gt; - parscom&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://brunch.co.kr/@imagineer/215&quot;&gt;[번역] 2017년 개발자 이력서 작성 가이드&lt;/a&gt; - 마르코&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.outsider.ne.kr/1234&quot;&gt;이력서&lt;/a&gt; - Outsider&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;공개-이력서&quot;&gt;공개 이력서&lt;/h2&gt;

&lt;p&gt;다른 사람의 이력서를 읽는 것은 피드백 요청을 받거나, 채용을 담당하는 사람이 아니라면 힘들다.
아래는 공개되어있고 잘 작성된 이력서들이다. 다른 사람들의 이력서를 참고하는 것이 큰 도움이 되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://woowabros.github.io/experience/2017/07/17/resume.html&quot;&gt;구인본&lt;/a&gt; - 배달의민족 개발자&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.outsider.ne.kr/1234&quot;&gt;변정훈(Outsider)&lt;/a&gt; - OnDemandKorea 개발자&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jojoldu.github.io/&quot;&gt;이동욱&lt;/a&gt; - 배달의민족&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hyunseob.github.io/resume/&quot;&gt;이현섭&lt;/a&gt; - 비바리퍼블리카&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;마침&quot;&gt;마침&lt;/h2&gt;

&lt;p&gt;사실 이력서는 작성자가 어떤 경험을 했는지, 어떤 역량을 쌓아왔는지, 자신의 경험과 역량을 얼마나 잘 보여주는지가 가장 중요하다고 생각한다.
이력서가 이쁘고, 정리가 잘 되어있어도 좋은 경험이 적다면 경쟁력이 떨어질 것이다.
좋은 경험을 가지고 있고 뛰어난 역량을 가지고 있는데 이력서를 잘 못 작성하여 서류부터 광탈하는 경우가 없기를 바란다.
가슴이 웅장해지는 이직을 하는데 도움이 되었다면 좋겠다.&lt;/p&gt;

&lt;p&gt;ps.&lt;/p&gt;

&lt;p&gt;처음 입사지원을 할 당시의 이력서 수십통을 찾아내어 다시 보는 계기가 되었다.
어떻게 서류에서 합격을 했고 면접을 보러 다녔는지 정말 신기할 정도로 엉망이었다.
간절했던 시기였지만 따로 정보를 찾아보지는 않았던 것이 문제였던 것 같다.
지금 살펴보면 이력서를 작성할 때 하면 안되는 것들을 모조리 한 것이나 다름이 없고, 결정적으로 굉장히 촌스럽다고 느껴졌다.
그 당시에 나의 이력서를 뽑아주고 합격을 준 인사 담당자가 고마워지려고 한다.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Resume" /><category term="Resume" /><summary type="html">이력서를 작성 체크리스트</summary></entry><entry><title type="html">블로그 시작</title><link href="http://localhost:4000/blog/1/" rel="alternate" type="text/html" title="블로그 시작" /><published>2020-08-03T00:00:00+09:00</published><updated>2020-08-03T00:00:00+09:00</updated><id>http://localhost:4000/blog/1</id><content type="html" xml:base="http://localhost:4000/blog/1/">&lt;h2 id=&quot;블로그&quot;&gt;블로그&lt;/h2&gt;
&lt;p&gt;제대로 된 블로그를 만들어보자는 생각을 가지고서 몇 번이나 블로그를 만들었지만 매번 얼마 지나지 않아 더 이상 글을 올리지 않게 되었습니다. 이유는 여러 가지지만 가장 큰 이유는 &lt;strong&gt;‘방법을 몰라서’&lt;/strong&gt; 였던 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;좋은-기술-블로그&quot;&gt;좋은 기술 블로그&lt;/h2&gt;
&lt;p&gt;업무를 하면서 많은 블로그들을 봅니다. 글을 잘 작성하고 정리가 잘 되어 보기 편한 블로그가 있다면 정반대인 블로그도 있습니다. 읽는 사람이 보기 편하고 원하는 정보를 정확하게 얻을 수 있다면 그것이 좋은 블로그인 것 같습니다. 좋은 블로그가 되기 위한 방법을 블로그에서 보게 되었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;완성된 글을 작성한다.&lt;/li&gt;
  &lt;li&gt;적당한 분량의 글을 작성한다.&lt;/li&gt;
  &lt;li&gt;글의 형식을 정한다.&lt;/li&gt;
  &lt;li&gt;컨텐츠 관리가 가능한 블로그 도구를 선택한다.&lt;/li&gt;
  &lt;li&gt;보존, 보존, 그리고 보존&lt;/li&gt;
  &lt;li&gt;수익을 얻는다.&lt;/li&gt;
  &lt;li&gt;글을 홍보하기 위한 채널을 만든다.&lt;/li&gt;
  &lt;li&gt;검색 엔진 최적화(SEO)를 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이전에 만들었던 블로그에 작성된 글들은 제시된 8가지 중 한 가지도 제대로 지키지 못했습니다. 좋은 블로그를 만들기 위해서는 공부가 필요하다는 것을 알았습니다. 앞으로는 나와 내 글을 읽는 사람을 위해 완벽하진 않아도 최대한 좋은 글을 쓰고, 좋은 블로그를 만들어보려고 합니다.&lt;/p&gt;

&lt;p&gt;수익이라는 항목은 블로그의 수익 구조가 어떤 형태인지 모르겠지만 수익을 얻을 만큼 고급 정보는 없을 테니 기대는 말아야겠습니다.😅&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.44bits.io/ko/post/8-suggestions-for-tech-programming-blog&quot;&gt;좋은 기술 블로그를 만들어 나가기 위한 8가지 제언&lt;/a&gt;&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Blog" /><category term="Blog" /></entry></feed>