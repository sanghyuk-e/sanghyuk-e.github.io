<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://sanghyuk.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sanghyuk.dev/" rel="alternate" type="text/html" /><updated>2021-09-15T21:39:54+09:00</updated><id>https://sanghyuk.dev/feed.xml</id><title type="html">Sanghyuk’s Blog</title><subtitle>Sanghyuk's Blog</subtitle><author><name>SANGHYUK LEE</name></author><entry><title type="html">최고 제품 책임자(CPO)</title><link href="https://sanghyuk.dev/product-manager/6/" rel="alternate" type="text/html" title="최고 제품 책임자(CPO)" /><published>2021-09-04T00:00:00+09:00</published><updated>2021-09-04T00:00:00+09:00</updated><id>https://sanghyuk.dev/product-manager/6</id><content type="html" xml:base="https://sanghyuk.dev/product-manager/6/">&lt;h1 id=&quot;chief-product-officer&quot;&gt;Chief Product Officer&lt;/h1&gt;

&lt;p&gt;최고 제품 책임자(CPO)는 조직 내 모든 제품 관련 활동의 전략 및 실행을 책임지는 C-Level 임원이다. CPO의 책임은 제품 혁신 및 비전 단계에서 시작해 마케팅 캠페인을 통해 계속되며 제품 출시 이후까지 확장된다. 최고 제품 책임자는 일반적으로 회사 최고 경영자(CEO)에게 보고한다. 역할은 제품의 부사장(VP) 또는 제품 책임자라고도 한다.&lt;/p&gt;

&lt;p&gt;CPO의 주요 목표는 제품 관리 팀을 이끌고 촉진하여 사용자와 비즈니스 모두에 가치를 제공하는 제품을 만들도록 하는 것이다. 이를 위해 최고 제품 책임자는 제품과 회사 모두의 요구와 목표를 일치시켜야 한다. 또한 CPO는 다음을 통해 조직에 이점을 제공한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소비자 요구 평가를 통해 회사를 고객과 연결하여 높은 수요를 경험할 제품을 결정하는 데 도움을 준다.&lt;/li&gt;
  &lt;li&gt;제품 제안을 제시하기 위해 투자자 및 기타 이해 관계자와 회의한다.&lt;/li&gt;
  &lt;li&gt;신제품 판매를 통한 매출 증대를 위한 제품 개발 전략을 제안한다.&lt;/li&gt;
  &lt;li&gt;새 제품의 비용을 결정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 CPO는 설계자, 엔지니어, 마케팅 담당자를 비롯한 조직 내 다양한 팀과 커뮤니케이션 할 수 있어야 제품이 컨셉에서 개발을 거쳐 출시 및 유통까지 성공적으로 진행된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;역할-및-책임&quot;&gt;역할 및 책임&lt;/h1&gt;

&lt;p&gt;대부분의 조직이 디지털 혁신을 경험함에 따라 최고 제품 책임자의 역할이 더욱 중요해졌다. CPO는 조직의 목표, 요구사항 및 성공에 대한 폭넓은 관점을 유지하면서 동시에 제품의 목표와 요구사항에 구체적으로 집중함으로써 회사를 이끄는 데 도움이 된다.&lt;/p&gt;

&lt;p&gt;CPO의 역할은 일반적으로 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제품 비전&lt;/li&gt;
  &lt;li&gt;제품 혁신&lt;/li&gt;
  &lt;li&gt;제품 디자인&lt;/li&gt;
  &lt;li&gt;사용자 조사&lt;/li&gt;
  &lt;li&gt;제품 개발&lt;/li&gt;
  &lt;li&gt;제품 마케팅 이니셔티브&lt;/li&gt;
  &lt;li&gt;제품 분석 및 측정항목&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일부 회사에서는 CPO를 유통, 제조 및 조달을 담당하기도 한다.&lt;/p&gt;

&lt;p&gt;최고 제품 책임자의 목표에는 제품 팀을 이끌고 멘토링 하는 것이 포함된다. 제품 생성을 위한 비전 및 전략 개발, 제품의 개념부터 출시까지 제품에 대한 마케팅 및 인지도 제고 정보에 입각한 문제 해결 및 회사 전체의 의사 결정을 용이하게 하는 연구를 제공한다.&lt;/p&gt;

&lt;p&gt;이러한 목표를 달성하기 위해 최고 제품 책임자는 다음을 수행해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;강력한 지도자와 감독자가 되어야 한다.&lt;/li&gt;
  &lt;li&gt;데이터를 이해하고 해석할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;전략적 제품 비전 기술을 보유하고 있다.&lt;/li&gt;
  &lt;li&gt;마케팅 및 홍보 이해&lt;/li&gt;
  &lt;li&gt;고객과 사용자에게 민감한 상태 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리더로서 CPO는 모든 제품 관련 활동의 일일 진행 상황을 관리한다. 그들은 조직의 사일로를 방지하고 관련된 모든 팀과 개인 간의 의사 소통을 촉진하여 프로젝트의 성공을 보장 할 책임이 있다.&lt;/p&gt;

&lt;p&gt;CPO는 사용자 경험(UX) 이사, 제품 마케팅 이사 및 제품 분석 책임자와 같은 제품 관리 책임자를 감독하는 책임도 있다. 또한 CPO는 이러한 제품 관리 담당자가 지속적으로 전문 기술을 향상시키고 필요할 때 지원을 받을 수 있도록 멘토링해야 한다.&lt;/p&gt;

&lt;p&gt;CPO는 객관적이고 데이터에 기반한 결정을 내릴 책임이 있기 때문에 데이터를 이해하고 해석할 수 있어야 한다. 여기에는 제품 성능과 관련된 메트릭을 정의하고 지속적으로 추적하는 작업이 포함된다. CPO가 사용하는 몇 가지 메트릭은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;수익과 이익&lt;/li&gt;
  &lt;li&gt;유지 및 회전율&lt;/li&gt;
  &lt;li&gt;사용자 활동 및 참여&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 CPO는 양적 및 질적 데이터를 사용하여 제품 또는 특정 기능이 시장에 출시될 준비가 되었는지 여부를 결정한다.&lt;/p&gt;

&lt;p&gt;최고 제품 책임자는 회사의 수익성을 높이는 확장 가능한 제품 포트폴리오를 만드는 것을 목표로 하는 전략적 제품 비전을 가지고 있어야 한다. CPO는 각 제품과 기능이 조직의 목표와 일치하는지 확인해야 한다. 또한 제품 판매 전략을 검토하고 개선하며 지원하는지 확인해야 한다. 또한 CPO는 제품이 지속적으로 개선되고 지속적으로 고객을 만족시킬 수 있도록 제품 출시 후 지원해야 한다.&lt;/p&gt;

&lt;p&gt;전략적 제품 비전의 대부분은 목표 시장과 청중을 이해하는 것이다. 결과적으로 CPO는 시장 동향과 경쟁 업체의 다양한 마케팅 전략을 평가하는 책임이 있다. 이러한 관행을 통해 CPO는 제품 포지셔닝 및 가격 책정에 대한 효과적인 권장 사항을 제공할 수 있다.&lt;/p&gt;

&lt;p&gt;CPO는 각 제품이 적절하게 홍보되도록 마케팅 및 커뮤니케이션 부서와 소통하고 협력해야 한다. 최고 제품 책임자(Chief Product Officer)는 모든 제품 전시회, 관련 연설 및 행사 프레젠테이션을 담당한다. 또한 CPO는 모든 지역 및 국제 마케팅 이벤트, 정보, 출시, 회의, 시연 및 언론을 조직해야 한다.&lt;/p&gt;

&lt;p&gt;제품 수명 주기 전반에 걸쳐 CPO는 제품이 고객을 계속 만족시킬 수 있도록 제품을 설계, 개선 및 유지 관리할 책임이 있다. 고객의 요구와 욕구에 민감한 상태를 유지하면 이 프로세스가 용이해질 것이다.&lt;/p&gt;

&lt;p&gt;소비자를 이해하는 한 가지 방법은 현재 및 잠재 고객을 만나 제품에서 어떤 가치나 이점을 얻을 수 있는지, 그리고 고객 경험(CX)을 개선하기 위해 무엇을 할 수 있는지 이해하는 것이다. 이는 궁극적으로 고객 기반을 확대하고 판매량을 증가시킬 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;최고-제품-책임자-vs-최고-기술-책임자&quot;&gt;최고 제품 책임자 vs 최고 기술 책임자&lt;/h1&gt;

&lt;p&gt;궁극적으로 최고 제품 책임자(CPO)와 최고 기술 책임자(CTO)는 동일한 목표를 가지고 있다. 즉, 고객을 위한 최상의 사용자 경험을 생성 및 제공하고 회사를 위한 지속적인 가치를 창출하는 것이다. CPO와 CTO는 함께 협력하여 회사의 비전을 팀의 작업과 일치시켜 소비자를 위한 최상의 제품을 구축해야 한다.&lt;/p&gt;

&lt;p&gt;두 역할은 이러한 목표를 달성하기 위해 취하는 접근 방식이 다르다. CPO는 제품의 이유 또는 제품을 만든 전략과 이유에 중점을 둔다. CTO는 제품의 방법 또는 개발 및 제공에 대한 전략적 접근 방식에 중점을 둔다.&lt;/p&gt;

&lt;p&gt;결과적으로 CPO는 제품이 변화하는 조건에 계속 적응하고 전반적인 조직 목표를 충족하도록 할 책임이 있다. CTO는 개발 또는 제품 관리 팀이 생산하는 제품이나 서비스를 개선하기 위해 기술을 사용하는 방법을 관리하는 책임이 있다. 이 작업에는 일반적으로 가장 비용이 효과적이고 수익이 높은 솔루션 또는 플랫폼을 결정하기 위한 비용 편익 및 투자 수익률(ROI) 분석이 포함된다.&lt;/p&gt;

&lt;p&gt;또한 CPO는 제품 결정을 내리기 위해 고객 통찰력에 계속 민감하게 집중하는 반면 CTO는 기술을 통해 가치를 제공하기 위해 고객 기반에 대한 CPO의 지식에 의존한다. 결과적으로 CPO는 고객의 요구와 행동을 이해해야 하고 CTO는 기술 지식을 사용하여 고객이 제품과 상호 작용하는 방식을 기술 애플리케이션에 반영해야 한다.&lt;/p&gt;

&lt;p&gt;또한, 최고 제품 책임자는 제품 경험과 관련된 질적 및 양적 데이터를 평가하는 반면, 최고 기술 책임자는 개발 팀 및 제품 성능과 관련된 핵심 성과 지표(KPI) 및 성과 지표를 측정한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;최고-제품-책임자cpo가-되는-방법&quot;&gt;최고 제품 책임자(CPO)가 되는 방법&lt;/h1&gt;

&lt;p&gt;CPO의 교육 요건은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;비즈니스, 경제학, IT 제품 관리, 컴퓨터 과학, 마케팅, 심리학 또는 기타 관련 과목에서 최소 학사 학위.&lt;/li&gt;
  &lt;li&gt;많은 고용주는 석사 또는 박사 학위를 가진 지원자를 선호한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대부분의 조직은 다음을 포함한 다양한 직무 기술을 선호한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마케팅 경험&lt;/li&gt;
  &lt;li&gt;리더십 능력&lt;/li&gt;
  &lt;li&gt;의사 소통 및 대중 연설 기술&lt;/li&gt;
  &lt;li&gt;문제 해결 및 의사 결정 능력&lt;/li&gt;
  &lt;li&gt;강력한 대인 관계 기술&lt;/li&gt;
  &lt;li&gt;독창성&lt;/li&gt;
  &lt;li&gt;팀워크 기술&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 CPO 구직자는 다년간의 상위 제품 관리 경험을 보유하고 있다.&lt;/p&gt;

&lt;hr /&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Product-Manager" /><category term="Product-Manager" /><category term="CPO" /><category term="Chief Product Officer" /></entry><entry><title type="html">[CHAPTER 4] 성장 단계의 회사: 성공을 위한 확장</title><link href="https://sanghyuk.dev/product-manager/5/" rel="alternate" type="text/html" title="[CHAPTER 4] 성장 단계의 회사: 성공을 위한 확장" /><published>2021-09-04T00:00:00+09:00</published><updated>2021-09-04T00:00:00+09:00</updated><id>https://sanghyuk.dev/product-manager/5</id><content type="html" xml:base="https://sanghyuk.dev/product-manager/5/">&lt;h1 id=&quot;성장-단계의-회사-성공을-위한-확장&quot;&gt;성장 단계의 회사: 성공을 위한 확장&lt;/h1&gt;

&lt;p&gt;충분한 역량과 운을 바탕으로 마침내 제품/시장 궁합을 달성한 스타트업들은 지금까지만큼이나 어려운 도전 상황을 이겨 낼 준비를 해야 한다. 어떻게 효과적으로 성장하고 확장해 나갈 것인가 하는 문제다.&lt;/p&gt;

&lt;p&gt;스타트업이 큰 규모의 성공적인 비즈니스로 성장하고 확장하는 과정에는 여러 중대한 도전들이 있다. 엄청나게 어려운 도전이긴 하지만, 이른바 행복한 고민이다.&lt;/p&gt;

&lt;p&gt;많은 사람을 채용하는 동시에 초기 성공을 이어나가기 위해 새롭고 인접한 제품과 서비스를 어떻게 만들어 낼지 고민해야 한다. 동시에 핵심 비즈니스 또한 가능한 한 빠른 속도로 성장시켜야 한다.&lt;/p&gt;

&lt;p&gt;성장 단계에서는 보통 25명에서 수백 명의 엔지니어로 구성이 되고, 더불어 이들을 돕는 많은 사람이 함께한다. 이 정도 규모가 되면 곳곳에 조직적인 스트레스의 신호들이 포착된다.&lt;/p&gt;

&lt;p&gt;제품팀들은 큰 그림을 이해할 수 없다며 불평하기 시작한다. 그들이 하는 일이 전체 목표에 어떻게 기여하는지 도대체 알 수 없다고 한다. 또한, 권한을 가진 자율성 높은 팀에서 고군분투하며 일을 해나간다.&lt;/p&gt;

&lt;p&gt;영업과 마케팅에서는 초기 제품에서 통했던 시장 진출 전략(go-to-market strategy)이 새로운 제품에서는 적합하지 않다며 자주 불만을 제기한다.&lt;/p&gt;

&lt;p&gt;첫 제품의 요건에 부합했던 기술 인프라도 한 번씩 터질 듯한 상황이 온다. 당신이 이야기 나누는 모든 엔지니어의 입에서 ‘기술 부채(technical debt)&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;‘라는 단어가 들리기 시작한다.&lt;/p&gt;

&lt;p&gt;리더들은 초기 스타트업 시절에 작동했던 리더십 스타일과 방식이 이제는 잘 통하지 않는 문제들을 겪는다. 리더들은 그들의 역할과 많은 상황에서의 행동이 바뀌어야 한다는 압박을 받는다.&lt;/p&gt;

&lt;p&gt;반면 이런 변화를 극복해야만 한다는 동기부여는 매우 강한 상황이다. 회사는 기업 공개(public offering)나 다른 회사의 핵심 사업으로 피인수되는 기회를 만들어 나간다. 또한, 세상에 유의미하고 큰 영향을 줄 수 있다는 현실적인 가능성도 강한 동기부여 요인이 될 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/Product-Manager/4/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/Product-Manager/7/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;기술 부채는 기술적으로 최선이 아님을 알면서도 비즈니스 성과를 앞당기는 선택을 함으로써 발생하는 기술적인 문제(비용)를 말한다. 자금을 앞당겨서 빌려 쓰면 이자가 발생하는 것과 비슷하다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Product-Manager" /><category term="Product-Manager" /><category term="Product" /><category term="Manager" /><category term="PM" /><summary type="html">Part.1 최고의 기술 기업에서 배운 것</summary></entry><entry><title type="html">[CHAPTER 3] 스타트업: 제품/시장 궁합 찾기</title><link href="https://sanghyuk.dev/product-manager/4/" rel="alternate" type="text/html" title="[CHAPTER 3] 스타트업: 제품/시장 궁합 찾기" /><published>2021-09-03T00:00:00+09:00</published><updated>2021-09-03T00:00:00+09:00</updated><id>https://sanghyuk.dev/product-manager/4</id><content type="html" xml:base="https://sanghyuk.dev/product-manager/4/">&lt;h1 id=&quot;스타트업-제품시장-궁합-찾기&quot;&gt;스타트업: 제품/시장 궁합 찾기&lt;/h1&gt;

&lt;p&gt;기술 산업에서 일반적으로 회사를 스타트업(startup), 성장 단계(growth-stage)의 기업, 대기업(enterprise companies)의 세 가지 단계로 정의한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스타트업&lt;/strong&gt;은 ‘제품/시장 궁함(product/market fit)을 아직 찾지 못한, 새로운 제품을 만드는 회사’ 라고 간단히 정의할 수 있다. 제품/시장 궁합은 너무나도 중요한 개념이며, 다시 자세히 알아보자. 스타트업이란, ‘유효한 비즈니스를 창출하는 제품을 찾기 위해 여전히 노력하고 있는 단계의 회사’ 정도로 알아두자.&lt;/p&gt;

&lt;p&gt;스타트업에서 제품 관리자의 역할은 공동 창업자 중 한 명이 대체로 맡게 된다. 일반적으로 25명 미만의 엔지니어와 함께, 한 개 제품팀에서 많게는 4~5개의 제품팀을 담당하게 된다.&lt;/p&gt;

&lt;p&gt;스타트업의 현실은 통장의 잔액이 떨어지기 전에 제품/시장 궁합을 어떻게든 달성하기 위해 달리는 경주이다. 그래서 스타트업은 제품에 집중할 필요가 있고, 초기 시장의 니즈(needs)에 부합하는 강력한 제품을 만들어 내야 한다.&lt;/p&gt;

&lt;p&gt;스타트업은 초기 자금이 매우 제한적이다. 시장이 필요로 하는 제품을 발견하고 출시할 수 있을지 결정하는 것을 목표로 자금을 사용한다. 통장 잔액이 바닥나는 시점이 가까워질수록 팀과 리더십은 정신없이 달려나가며, 더욱 필사적인 상황을 맞이하게 된다.&lt;/p&gt;

&lt;p&gt;스타트업은 시간과 비용이 매우 빠듯하다. 그래서 좋은 스타트업은 실행 속도를 늦추는 불필요한 관료 체계를 최소화한다. 그런데도 아직 기술 스타트업은 실패 확률이 높다. 그중 일부 성공하는 스타트업은 특히 제품 발견에 매우 뛰어나다.&lt;/p&gt;

&lt;p&gt;제품/시장 궁합을 위해 달려나가야 하는 스타트업에서 일한다는 것은 높은 스트레스, 산더미 같은 업무량, 위험한 상황을 항상 마주해야 한다. 반면에 그것은 놀라운 경험이 될 수도 있다. 특히 상황에 따라 금전적으로 큰 보상을 기대할 수도 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/Product-Manager/3/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/Product-Manager/5/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Product-Manager" /><category term="Product-Manager" /><category term="Product" /><category term="Manager" /><category term="PM" /><summary type="html">Part.1 최고의 기술 기업에서 배운 것</summary></entry><entry><title type="html">[CHAPTER 1] 훌륭한 제품을 이끄는 사람</title><link href="https://sanghyuk.dev/product-manager/2/" rel="alternate" type="text/html" title="[CHAPTER 1] 훌륭한 제품을 이끄는 사람" /><published>2021-09-02T00:00:00+09:00</published><updated>2021-09-02T00:00:00+09:00</updated><id>https://sanghyuk.dev/product-manager/2</id><content type="html" xml:base="https://sanghyuk.dev/product-manager/2/">&lt;h1 id=&quot;part1-최고의-기술-기업에서-배운-것&quot;&gt;Part.1 최고의 기술 기업에서 배운 것&lt;/h1&gt;

&lt;p&gt;제품을 만드는 사람들이 밤과 주말을 희생해 가며 오랜 기간 열심히 제품을 만들었다. 제품을 설명하는 자리를 가졌고 좋은 평가를 받았다. 성공을 위한 만반의 준비를 하고 마침내 제품을 출시했다. 그런데 제품은 실패했다. 원인은 제품을 구매하는 사람이 없었기 때문이다. 기술적으로 매우 훌륭한 제품이었고, 전문가들은 극찬을 아끼지 않았다. 하지만 결국 사람들이 원하는 제품이 아니었던 것이다. 여기서 알 수 있는 점은 &lt;strong&gt;만들 만한 가치가 있는 제품이 아니라면 엔지니어 팀이 얼마나 훌륭한지는 아무 의미가 없다는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;여기서 배울 점이 있다. 만들 제품을 정의하는 책임을 진 ‘제품 관리자’라는 사람이 무슨 제품을 만들지에 대한 의사결정을 한다는 것이다. 또 대부분의 회사가 제품 관리에 서툴고, 지금도 마찬가지라는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최고&lt;/strong&gt;의 기업들과 &lt;strong&gt;대부분&lt;/strong&gt; 기업이 제품을 만드는 방식에서 큰 차이가 있다. &lt;strong&gt;최신 기술을 잘 아는 것과 실제로 잘 만드는 것은 매우 다르다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;대부분 기업은 여전히 오래되고 비효율적인 방법으로 제품을 발견하고 출시한다. 학계나 최고 경영대학의 프로그램, 산업 기관 등 모두 과거의 실패한 모델에 갇혀 있다.&lt;/p&gt;

&lt;p&gt;대부분의 제품 리더들은 사람들에게 진정한 가치과 감동을 제공하는, 고객이 사랑하는 제품을 만들기 원한다. 하지만 많은 제품은 감동을 주지 못하며, 우리의 삶은 좋은 제품만을 사용하기에도 모자라다.&lt;/p&gt;

&lt;h1 id=&quot;훌륭한-제품을-이끄는-사람&quot;&gt;훌륭한 제품을 이끄는 사람&lt;/h1&gt;

&lt;p&gt;모든 훌륭한 제품 이면에는 지칠줄 모르고, 무대 뒤에서 최선을 다하는 누군가가 있다. 그 사람은 제품팀을 이끌며, 비즈니스 목표에 맞는 방향으로 기술과 디자인을 통해 고객의 실제 문제를 해결한다. 이런 사람들을 우리는 &lt;strong&gt;제품 관리자(product manager)&lt;/strong&gt;라고 부른다. 이들은 스타트업의 공동 창업자나 대표일 수 있다. 또한, 이미 다른 역할을 가지고 있지만, 필요에 의해 선택된 사람일 수도 있다. 제품 관리자로서 임무를 수행한다는 것은 디자이너, 엔지니어, 마케팅, 프로젝트 매니저의 역할과는 매우 다르다.&lt;/p&gt;

&lt;p&gt;기술 제품을 만드는 팀에서 제품 관리자는 매우 특별하고 도전적인 책임을 지고 일을 한다. 어려운 역할이고, 다른 사람이 어떤 이야기를 해준다고 도움이 되지 않는다. 제품 관리자는 보통 풀타임 업무가 필요하다. 일반적으로 업무를 충실하게 수행하는 제품 관리자는 주 60시간보다 적게 일하는 경우를 찾아보기 힘들다.&lt;/p&gt;

&lt;p&gt;디자이너나 엔지니어로서 제품 관리자의 역할을 동시에 수행하는 것도 충분히 가능하고, 실제로 몇 가지 장점들이 있다. 하지만 어마어마한 업무량을 소화해야 한다.&lt;/p&gt;

&lt;p&gt;제품팀은 적어도 한 명의 제품 관리자 및 두 명에서 최대 10명의 엔지니어로 구성된다. 사용자 접점에 있는 제품을 만드는 경우라면 아마도 팀에 제품 디자이너도 필요할 것이다.&lt;/p&gt;

&lt;p&gt;앞으로의 이야기는 팀의 구성이 어떻게 되었든 제품 관리자라는 역할, 그리고 함께 일하는 전담팀이 있다는 것을 가정한다. 그 팀은 제품을 설계-구현-출시를 위해 함께 업무를 하는 팀을 말한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/Product-Manager/1/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/Product-Manager/3/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Product-Manager" /><category term="Product-Manager" /><category term="Product" /><category term="Manager" /><category term="PM" /><summary type="html">Part.1 최고의 기술 기업에서 배운 것</summary></entry><entry><title type="html">[CHAPTER 2] 기술 중심의 제품과 서비스</title><link href="https://sanghyuk.dev/product-manager/3/" rel="alternate" type="text/html" title="[CHAPTER 2] 기술 중심의 제품과 서비스" /><published>2021-09-02T00:00:00+09:00</published><updated>2021-09-02T00:00:00+09:00</updated><id>https://sanghyuk.dev/product-manager/3</id><content type="html" xml:base="https://sanghyuk.dev/product-manager/3/">&lt;h1 id=&quot;기술-중심의-제품과-서비스&quot;&gt;기술 중심의 제품과 서비스&lt;/h1&gt;

&lt;p&gt;소비재 제품과 같은 비기술(non-tech) 제품 및 해당 제품의 관리자들을 위한 좋은 자료들은 이미 쉽게 구할 수 있을 정도로 충분하다. 여기서는 내가 현제 일하고 있는 분야인 오로지 &lt;strong&gt;기술 중심의 제품&lt;/strong&gt;에만 집중한다.&lt;/p&gt;

&lt;p&gt;기술 중심의 제품, 서비스, 사용자 경험을 만드는 것과 관련된 고유의 이슈와 도전들을 다룬다. 소비자 서비스 제품들이 도움이 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전자상거래 사이트 및 중계 서비스 : 넷플릭스(Netflix), 에어비앤비(Airbnb), 엣시(Etsy)&lt;/li&gt;
  &lt;li&gt;소셜 미디어 : 페이스북(Facebook), 링크드인(LinkedIn), 트위터(Twitter)&lt;/li&gt;
  &lt;li&gt;비즈니스 서비스 : 세일즈포스(salesforce.com), 워크데이(Workday), 워키바(Workiva)&lt;/li&gt;
  &lt;li&gt;소비자 디바이스 : 애플(Apple), 소노스(Sonos), 테슬라(Tesla)&lt;/li&gt;
  &lt;li&gt;모바일 애플리케이션 : 우버(Uber), 오더블(Audible), 인스타그램(Instagram)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기술 중심의 제품이라고 해서 순수하게 디지털이어야 할 필요는 없다. 요즘은 온라인과 오프라인이 연계된 훌륭한 사례들도 흔히 찾아볼 수 있다.&lt;/p&gt;

&lt;p&gt;대부분 제품의 &lt;strong&gt;기술 중심의 제품&lt;/strong&gt;으로 변화하고 있다. 이러한 변화를 깨닫지 못하는 기업은 빠르게 무너질지도 모른다. 기술 변화를 빠르게 흡수하고 고객을 위해 끊임 없이 혁신해야만 한다고 믿는 기업들에 집중해보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/Product-Manager/2/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/Product-Manager/4/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Product-Manager" /><category term="Product-Manager" /><category term="Product" /><category term="Manager" /><category term="PM" /><summary type="html">Part.1 최고의 기술 기업에서 배운 것</summary></entry><entry><title type="html">Product Manager</title><link href="https://sanghyuk.dev/product-manager/1/" rel="alternate" type="text/html" title="Product Manager" /><published>2021-09-01T00:00:00+09:00</published><updated>2021-09-01T00:00:00+09:00</updated><id>https://sanghyuk.dev/product-manager/1</id><content type="html" xml:base="https://sanghyuk.dev/product-manager/1/">&lt;h1 id=&quot;product-manager&quot;&gt;Product Manager&lt;/h1&gt;

&lt;p&gt;요즘 기업에서는 많은 팀에 애자일(agile)이 정착되었고, 고객 개발(customer development)과 린 스타트업(lean startup)등의 방법을 수년간 사용하고 있으며, 이제는 린와 애자일을 넘어서는 무언가에 관심을 가지고 있다.&lt;/p&gt;

&lt;p&gt;제품관리의 기법들은 계속 발전해왔다. 기업은 규모를 확장하면서 새로운 도전 과제들에 직면하게 된다. 빠르게 성장하며 생존한다는 것이 얼마나 어려운지를 표현할 때, 생존 그 자체를 ‘성공’이라고 부른다.&lt;/p&gt;

&lt;p&gt;제품 관리자에게는 크게 두 가지의 중요한 주제가 있다.&lt;/p&gt;

&lt;p&gt;첫째, 제품 관리자(product manager)에 대해 구체적으로 알아야 한다. 제품 관리자는 기술 제품(technology-powered)를 책임지는 중요한 사람인데도 잘 모르고 있다. 기술 제품을 만드는 회사의 제품 관리자 혹은 그 일을 희망하는 사람들은 반드시 제품 관리자가 하는 일을 알아야 정확하게 알아야 한다.&lt;/p&gt;

&lt;p&gt;둘째, 고객이 사랑하는 훌륭한 제품을 만드는 지침이나 체계, 비법은 있을 수 있다. 하지만 그것만으로 훌륭한 제품을 만들 수 없다. 제품의 성공을 위해서는 올바른 제품 문화를 만들어야 한다. 또, 제품 발견(product discovery)과 제품 실행(product delivery)에 이르는 일련의 방법들을 이해해야 이슈가 발생하는 상황이 되었을 때 올바른 도구들을 선택할 수 있다. 제품 관리자의 일은 절대 쉽지 않으며, 이 일을 성공적으로 할 수 있도록 준비를 해야 한다.&lt;/p&gt;

&lt;p&gt;이 모든 것을 고려하여 업계에서 제품 관리자는 매우 인기가 높은 직종이다. 특히 스타트업의 대표이사가 되거나 혹은 그러한 자질을 시험할 기회가 되기도 한다.&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/Product-Manager/2/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;제품 실행은 제품 발견 단계 이후부터 실제로 제품을 구현하고 테스트하고 고객에게 전달하는 과정을 모두 포함하는 용어이다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Product-Manager" /><category term="Product-Manager" /><category term="Product" /><category term="Manager" /><category term="PM" /></entry><entry><title type="html">기획</title><link href="https://sanghyuk.dev/planner/1/" rel="alternate" type="text/html" title="기획" /><published>2021-08-31T00:00:00+09:00</published><updated>2021-08-31T00:00:00+09:00</updated><id>https://sanghyuk.dev/planner/1</id><content type="html" xml:base="https://sanghyuk.dev/planner/1/">&lt;h1 id=&quot;제목&quot;&gt;제목&lt;/h1&gt;

&lt;p&gt;내용&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Planner" /><category term="기획" /></entry><entry><title type="html">CHAPTER07: 함수 - 1.함수의 기본 개념</title><link href="https://sanghyuk.dev/swift-grammar/7-1/" rel="alternate" type="text/html" title="CHAPTER07: 함수 - 1.함수의 기본 개념" /><published>2021-02-21T00:00:00+09:00</published><updated>2021-02-21T00:00:00+09:00</updated><id>https://sanghyuk.dev/swift-grammar/7-1</id><content type="html" xml:base="https://sanghyuk.dev/swift-grammar/7-1/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/swift.png&quot; alt=&quot;Swift&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;text-center&quot;&gt;&lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fsanghyuk.dev%2Fswift-grammar%2F7-1%2F&amp;amp;count_bg=%23FA7343&amp;amp;title_bg=%23555555&amp;amp;icon=swift.svg&amp;amp;icon_color=%23E7E7E7&amp;amp;title=Views&amp;amp;edge_flat=false&quot; alt=&quot;Hits&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;함수(Function)&lt;/strong&gt;는 대부분의 프로그래밍 언어에서 지원하는 개념으로 프로그램의 실행 과정 중에서 독립적으로 처리될 수 있는 부분을 분리하여 구조화한 객체를 의미한다. 즉, 외부에 의존하는 부분 없이 툭 떼어 분리할 수 있는 실행 단위를 일종의 캡슐처럼 포장해놓은 것이다. 이렇게 독립적으로 작성된 함수는 간단한 방식으로 여러 번 호출하여 사용할 수 있어서 같은 코드를 반복해서 작성할 필요가 없다.&lt;/p&gt;

&lt;p&gt;스위프트는 함수를 지원하므로, 이를 통해 한번 작성된 코드를 여러 곳에서 호출하여 사용할 수 있다. 특히 스위프트는 함수형 프로그래밍 패러다임을 채택하고 있는 언어이므로 함수형 프로그래밍의 특성을 이해하는 것은 매우 중요하다.&lt;/p&gt;

&lt;h1 id=&quot;1-함수의-기본-개념&quot;&gt;1. 함수의 기본 개념&lt;/h1&gt;

&lt;p&gt;일반적으로 함수를 표현할 때에는 다음과 같은 모습으로 표현하는 경우가 많다. 함수의 성격과 특성을 가장 잘 나타내는 모습이기 떄문일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-21-7-1/1.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-21-7-1/1.png&quot; alt=&quot;함수의 모식도&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;함수는 위 그림처럼 입력값을 받아 내부 처리 과정(그림에서는 입력값에 4를 더하는 처리)을 거친 후 그 결과값을 내어 놓는 형태를 기본으로 한다. 입력값을 &lt;strong&gt;인자값&lt;/strong&gt; 혹은 &lt;strong&gt;파라미터&lt;/strong&gt;라고 하고, 내어놓는 결과값을 &lt;strong&gt;반환값&lt;/strong&gt; 혹은 &lt;strong&gt;리턴값&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;함수의 인자값은 하나도 없을 수도 있고, 하나 이상일 수도 있다. 특별한 경우에는 인자값의 개수가 제한되지 않는 형태를 가지기도 한다.&lt;/p&gt;

&lt;p&gt;함수의 반환값은 특정 값을 반환하는 형태와 반환하는 값이 없는 형태 두 가지로 나눌 수 있다. 다만 특정 값을 반환하더라도 그 값의 갯수는 일반적으로 하나이다. 만약 둘 이상의 값을 반환해야 할 필요가 있다면 반환할 값들을 집단 자료형 하나에 담아 반환해야 한다. 즉, 실질적으로 반환하는 값이 여러 개더라도, 반환하는 단위는 하나라는 것이다.&lt;/p&gt;

&lt;p&gt;함수는 &lt;strong&gt;일반 함수&lt;/strong&gt;와 &lt;strong&gt;사용자 정의 함수&lt;/strong&gt;로 나눌 수 있따. 일반 함수는 프로그래밍 언어나 프레임워크 수준에서 제공하는 함수로 &lt;strong&gt;기본적인 데이터의 처리나 연산 등을 수행하기 위한 목적&lt;/strong&gt;으로 사용된다. 대표적으로 출력에 사용하는 함수인 print()를 들 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 실제로 애플리케이션을 개발하다 보면 언어나 프레임워크가 제공하는 함수만으로는 충반하지 않은 경우가 많다. 이때에는 우리가 원하는 기능을 실행해 줄 함수를 직접 만들어 사용해야 하는데, 이를 사용자 정의 함수라고 부른다. 이때 말하는 정의란 옳고 그름의 Justice가 아니라 Definition을 의미한다. 이번 장에서 배울 대부분의 내용은 이같은 사용자 정의 함수에 관련된 것들이다.&lt;/p&gt;

&lt;p&gt;기본적으로 함수는 의존성 없이 독립적으로 실행 가능한 코드를 모듈 단위로 분리해 놓은 것에 불과하므로, 함수를 사용하지 않고 함수 내부의 실행 코드만 가져다 전체 코드에 넣고 사용해도 된다. 다시 말해 프로그래밍에서 함수가 필수 요소는 아니라는 것이다. 그럼에도 함수가 중요한 의미를 가지는 것은 다음과 같은 이점들 떄문이라고 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 코드가 여러 곳에서 사용될 때 이를 함수화하면 재작성을 할 필요 없이 함수 호출만으로 처리할 수 있다.&lt;/li&gt;
  &lt;li&gt;전체 프로세스를 하나의 소스 코드에서 연속적으로 작성하는 것보다 기능 단위로 함수화하면 가독성이 좋아지고, 코드와 로직을 이해하기 쉽다.&lt;/li&gt;
  &lt;li&gt;비즈니스 로직을 변경해야 할 때 함수 내부만 수정하면 되므로 유지보수가 용이하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;11-사용자-정의-함수&quot;&gt;1.1 사용자 정의 함수&lt;/h2&gt;

&lt;p&gt;사용자 정의 함수를 만드는 방법을 알아보자. 스위프트에서 함수를 정의하는 형식은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;함수명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;매개변수1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;매개변수2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환타입&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;실행내용&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환값&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스위프트에서 함수를 정의할 때 func 키워드를 사용한다. 함수를 선언할 때 키워드를 사용하지 않는 언어들도 많지만 스위프트는 명시적으로 func 키워드를 사용하여 함수를 선언해야 한다. func 키워드 다음에는 함수의 이름을 작성하는데, 이때 [+, -, *, /] 같은 연산자와 예약어는 사용할 수 없다.&lt;/p&gt;

&lt;p&gt;함수의 이름에 사용할 수 있는 문자들은 영어나 숫자, 한자, 바이너리 이미지 등으로 다양하지만, 첫 글자는 반드시 영어 또는 언더바(_)로 시작해야 한다. 언더바 이외의 특수문자나 숫자로 시작할 경우 컴파일러에 의해 오류가 발생한다. 대신 두 번째 글자부터는 이런 제약이 없으므로 영어, 숫자, 일부 특수문자를 충분히 활용할 수 있다. 단, 숫자나 특수 문자 등을 너무 남발하면 함수의 핵심인 재사용성과 생산성 측면에서 불편함이 야기될 수 있으므로 주의해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;s0110&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;사당역 5번 출구&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 함수는 스위프트에서 함수명에 적용되는 규칙을 정확하게 지키고 있어 아무런 문제가 없다. 하지만 실제로 사용하기에 적절하지는 않다. 여러 개의 숫자로 이루어져 있어 쉽게 헷갈릴 수 있기 때문이다. 무엇보다 함수를 작성한 사람 이외에는 함수의 기능과 함수명을 연관 짓기 어렵다는 것이 치명적인 단점이다. 이 함수 하나만 사용한다면 외워서 사용할 수도 있겠지만, 이같은 함수들이 백 개쯤 된다고 생각해보자. 그것은 악몽이다.&lt;/p&gt;

&lt;p&gt;이름에 특수문자가 포함되어 있는 함수도 마찬가지이다. 앞에서 이미지를 사용한 변수명의 불편함에 대해 잠깐 이야기한 적이 있는데, 비슷한 이유로 함수명에 특수문자가 포함되면 충분히 불편하다. 함수를 호출할 떄마다 특수문자를 입력하는 복잡한 과정을 거쳐야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;숫자도 마찬가지이다. 숫자를 너무 남발하면 함수의 이름을 외우기 쉽지 않다. 과자 포장지 뒤에 있는 바코드 숫자 외우고 있는 사람이 있을까? 아마 없을 것이다. 너무 외우기 어려우니까. 그러므로 함수에서 숫자나 특수기호는 꼭 필요할 때 의미를 구분하는 용도로 적당한 선만큼만 사용하는 것이 좋다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;이름 지을 땐 왠만하면 숫자를 자제하자.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예전에 필자가 어떤 회사의 내부 시스템 리뉴얼을 진행할 떄의 이야기이다.(리뉴얼은 ‘개편’이라는 뜻으로, 기존에 있던 시스템을 업그레이드하거나 바꿀 때 사용하는 현장 용어이다.) 리뉴얼을 위한 미팅에서 데이터를 저장하고 있는 데이터베이스의 명세서를 받아보고는 이내 당황해 버렸는데, 데이터베이스에서 수백 개 되는 테이블의 이름이 모조리 의미를 쉽게 짐작하기 어려운 숫자와 코드로 이루어져 있었기 때문이다.&lt;/p&gt;

&lt;p&gt;물론 최초 개발 당시에는 테이블에 저장하는 데이터의 성격에 따라 분류하려는 의도였겠지만, 이후 데이터베이스의 내용을 정리한 문서 관리가 제대로 되지 않고, 담당자까지 교체되면서 복잡한 코드로 이루어진 테이블명들은 개발자들에게 마치 다빈치 코드 같은 존재가 되어 버렸다. 실제로 운영을 담당하고 있던 기존 개발자들도 주로 사용하는 몇 개의 테이블명만 표로 정리해서 출력하여 참조하고 있었다. 매번 데이터베이스를 다루어야 할 때마다 테이블을 찾기가 정말 힘들었던 기억이 새록새록하다.&lt;/p&gt;

&lt;p&gt;이런 의미에서 회사가 여러분을 해고하지 못하도록 하려면 변수명이나 함수명을 모두 숫자나 코드로 작성하면된다. 후임자가 와서 코드를 보고 나면 바로 도망칠 테니까. 유지보수해야 하는 여러분들에게도 악몽과 같다는 건 함정. 단, 개발이 끝날 때까지는 들키지 말아야 할 것이다. 개발 도중에 들키면 일찍 집에 가는 수가 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;함수명을 작성하고 나면 다음으로 해야 할 것은 함수의 인자값 개수와 형태를 정의하기 위해 소괄호로 영역을 표시해 주는 것이다. 이 공간에는 함수가 호출될 때 전달되는 입력값을 대입 받기 위한 변수의 이름과 타입이 정의되는데, 이를 &lt;strong&gt;매개변수&lt;/strong&gt;라고 한다. 영어로는 &lt;strong&gt;파라미터(Parameter)&lt;/strong&gt;라고도 부른다. 오브젝티브-C에서 콜론(;) 다음에 매개변수명이 작성되던 것과 달리 스위프트에서는 괄호 내부에 쉼표(,)로 구분된 매개변수가 차례로 정의된다. 함수의 인자값이 필요 없는 경우라면 매개변수를 생략할 수 있으며, 이때 함수를 정의하는 형식은 다음과 같이 변경된다. 위의 함수 정의 구문과 비교해 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;함수명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환타입&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;실행내용&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환값&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;매개변수가 없는 함수를 작성할 떄는 함수명 뒤의 매개변수 영역을 표시하는 괄호 내부를 비워두면 된다. 일부 언어에서는 매개변수를 사용하지 않는 함수의 경우 매개변수 영역을 비워두는 대신 void라는 키워드를 명시적으로 작성할 것을 강제하기도 하지만, 스위프트에서는 그냥 빈칸으로 두면 된다. 하지만 매개변수가 없더라도 괄호는 생략할 수 없다.&lt;/p&gt;

&lt;p&gt;매개변수의 이름과 타입까지 작성이 완료되었으면 이제 이 함수의 반환 타입을 작성해 줄 차례이다. 반환타입이라는 것은 함수가 실행된 결과로 어떤 값을 내놓을 것이냐 하는 것이다. 함수의 기본은 인자값을 입력받아 내부적으로 처리하고, 그 결과를 외부로 다시 반환하는 과정에 있다. 따라서 반환값이라는 요소는 함수 내부에서 생성된 값을 외부로 전달하는 역할을 한다. 이를 &lt;strong&gt;함수가 값을 반환한다&lt;/strong&gt;고 표현한다. 실무에서는 &lt;strong&gt;함수가 값을 리턴한다&lt;/strong&gt;라는 표현을 더 많이 사용하기도 한다.&lt;/p&gt;

&lt;p&gt;함수의 반환 타입을 표시할 때에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; 기호와 함께 사용한다. 이 기호 다음에 작성된 자료형이 함수가 반환하는 값의 타입인 것이다. 함수의 반환 타입으로 사용될 수 있는 자료형에는 제약이 없다. String이나 Int, Double, Bool 등 기본 자료형은 물론이거니와 AnyObject, UITableCell 등과 같은 클래스 객체도 사용할 수 있으며, 사용자가 정의한 커스텀 클래스도 가능하다. 구조체 역시 사용할 수 있다. 하지만 반환 타입이 지정되면 반드시 그 타입에 맞는 값을 반환해야 한다. 반환 타입을 문자열로 정의했는데 실수를 반환해서는 안 된다. 또한 nil을 반환하려면 함수의 반환타입이 반스듸 옵셔널 타입으로 정의되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;함수의 성격에 따라서는 반환값이 전혀 없는 함수를 작성할 수도 있다. 이런 경우를 “아무 값도 반환하지 않는다.” 또는 “void 타입을 반환한다.”고 표현한다. 반환 타입을 생략할 수 없도록 설계된 언어에서는 반환 타입을 void로 작성하도록 강제되기도 하지만, 스위프트에서는 다음과 같이 반환 타입을 생략함으로써 반환값이 없음을 표현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;함수명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;매개변수1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;매개변수2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;실행내용&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환값&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/6-2/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/ios/2/&quot; class=&quot;btn btn--success&quot;&gt;iOS 면접 질문 목록 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/7-2/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><category term="함수" /><category term="문법" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER06: 옵셔널 - 2. 옵셔널 값 처리</title><link href="https://sanghyuk.dev/swift-grammar/6-2/" rel="alternate" type="text/html" title="CHAPTER06: 옵셔널 - 2. 옵셔널 값 처리" /><published>2021-02-16T00:00:00+09:00</published><updated>2021-02-16T00:00:00+09:00</updated><id>https://sanghyuk.dev/swift-grammar/6-2</id><content type="html" xml:base="https://sanghyuk.dev/swift-grammar/6-2/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/swift.png&quot; alt=&quot;Swift&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;text-center&quot;&gt;&lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fsanghyuk.dev%2Fswift-grammar%2F6-2%2F&amp;amp;count_bg=%23FA7343&amp;amp;title_bg=%23555555&amp;amp;icon=swift.svg&amp;amp;icon_color=%23E7E7E7&amp;amp;title=Views&amp;amp;edge_flat=false&quot; alt=&quot;Hits&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-옵셔널-값-처리&quot;&gt;2. 옵셔널 값 처리&lt;/h1&gt;

&lt;p&gt;문자열을 숫자로 변환해주는 생성자 Int(문자열) 이야기를 조금 더 해보자. 숫자로 바꿀 수 있는 문자열 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;123&quot;&lt;/code&gt;이 입력되면 숫자로 변환할 수 있지만, 그럴 수 없는 일반 문자열이 입력되면 잠재적인 오류 가능성이 있다고 설명했다. 이 때문에 Int(문자열)은 그냥 정수가 아니라 옵셔널 타입의 정수값을 반환하도록 설계되어 있다. Int 구조체의 생성자를 정의하는 구문 일부를 살펴보면 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;radix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Int(문자열) 구문이 반환하는 옵셔널 타입을 분석해보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;안녕하세요&quot;&lt;/code&gt;처럼 숫자로 바꿀 수 없는 문자열이 입력되었을 떄 옵셔널 타입에는 nil이 할당된 상태로 반환된다. 다른 문자열이 입력되어 변환에 성공하면 Optional(123)이라는 옵셔널 값이 할당된다. 어쨋거나 두 경우 모두 옵셔널 타입으로 반환되는 것만은 분명하다.&lt;/p&gt;

&lt;p&gt;이렇게 전달받은 옵셔널 타입의 결과값은 그 자체로는 아무것도 할 수 없다. 옵셔널 타입은 애초에 연산을 지원하지 않는 타입이다. 따라서 옵셔널 타입과 일반 타입은 서로 연산할 수 없으며 옵셔널 타입끼리의 연산이나 결합도 지원하지 않는다. 옵셔널 Int 타입과 일반 Int 타입의 연산도, 옵셔널 String과 일반 String 결합도 모두 불가능하다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ( x ) : 옵셔널 타입은 결합 연산 또는 더하기 연산이 가능한 데이터 타입이 아님&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// ( x ) : Int? 와 Int 는 서로 다른 타입이므로 연산이 불가능함&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 옵셔널 값을 그대로 사용하는 방법을 알아보자. 우리가 결과값으로 전달받은 것은 Optional이라는 객체이다. 그 내부에 우리가 원하는 값이 들어있을 것이다. 이 값을 우리가 원하는 대로 사용하려면 실제 값을 둘러싼 옵셔널 객체를 해제해야 한다. 옵셔널 객체를 해제하면 일반 타입의 값이 되는데, 이 값이 비로소 우리가 직접 사용할 수 잇는 값이다. 이처럼 옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 옵셔널 해제라고 한다. 다른 말로 옵셔널 언래핑(Optional Unwrapping)이라고도 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-16-6-2/1.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-16-6-2/1.png&quot; alt=&quot;옵셔널 타입의 값을 연산에 사용할 수 있도록 처리하는 과정&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;옵셔널 해제 방식은 &lt;strong&gt;명시적 해제&lt;/strong&gt;와 &lt;strong&gt;묵시적 해제&lt;/strong&gt;로 나누어진다. 명시적 해제는 다시 &lt;strong&gt;강제적인 해제&lt;/strong&gt;와 &lt;strong&gt;비강제적인 해제&lt;/strong&gt;로 나눌 수 있고 묵시적 해제는 각각 &lt;strong&gt;컴파일러에 의한 자동 해제&lt;/strong&gt;와 &lt;strong&gt;연산자를 이용한 자동 해제&lt;/strong&gt;로 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-16-6-2/2.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-16-6-2/2.png&quot; alt=&quot;옵셔널 해제 방식&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;차례대로 각 해제 방법에 대해 알아보자. 우선 학습할 것은 명시적 해제, 특히 가장 많이 사용되는 강제 해제이다. 강제 해제는 옵셔널 값의 nil 여부와 관계없이 옵셔널을 무조건 해제하는 방식으로, 스위프트 공식 문서에서 사용하는 용어로는 Forced Unwrapping이다. 정확한 의미로는 옵셔널을 벗겨내는 것이지만, 이 강의에서는 편의상 강제 해제라고 부르겠다.&lt;/p&gt;

&lt;h2 id=&quot;21-옵셔널-강제-해제&quot;&gt;2.1 옵셔널 강제 해제&lt;/h2&gt;

&lt;p&gt;옵셔널을 강제 해제하는 방법은 무척 단순하다. 옵셔널 타입의 값 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt;기호만 붙여주면 된다. 이렇게 처리해 주면 옵셔널 객체가 해제되고, 그 내부에 저장된 값을 꺼내 사용할 수 있게 된다. 이때 사용된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; 기호를 가리켜 옵셔널에 대한 ‘강제 해제 연산자(Forced-Unwrapping Operator)’라고 한다. 이와 관련된 다음 예제를 살펴보자. 옵셔널 Int 타입으로 선언된 optInt를 강제 해제 연산자를 사용하여 값을 추출하는 구문이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 옵셔널 타입의 변수 선언&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;옵셔널 자체의 값 : &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;!로 강제해제한 값 : &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 위 구문을 실행한 결과이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;옵셔널 자체의 값 : Optional(3)
!로 강제해제한 값 : 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;뱐수 optInt를 Int 타입으로 정의하면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt;를 붙여 옵셔널 타입으로 선언했다. 옵셔널 타입에 대입된 값은 옵셔널 객체로 감싸 처리되므로, 변수 자체를 출력하면 ‘Optional(3)’이라는 값이 출력된다. 이어서 두 번째 print 구문을 살펴보자. optInt 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; 연산자를 붙였더니 3이 출력되었다. 이는 옵셔널 타입의 값이 ! 연산자 덕분에 해제되었기 때문이다. 이처럼 옵셔널 타입으로부터 값을 추출하려면 옵셔널 값 뒤에 ! 연산자를 붙이면 된다. 앞에서 옵셔널 타입끼리 연산은 불가능하다고 이야기했지만, 강제 해제 연산자를 사용하면 일반 타입으로 해제되므로 연산이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 246&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 153&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 이상한점이 있다. 옵셔널 타입의 변수나 상수에 ! 연산자만 붙이면 일반 타입처럼 사용할 수 있는 앞서 설명대로라면 그냥 모든 옵셔널 타입에 ! 연산자를 붙여서 사용해버리면 되는것이다. 게다가 옵셔널 변수의 값이 nil일 때도 강제 해제 연산자를 붙일수는 있는데, 실제로 값이 nil인 옵셔널 변수에 이 연산자를 붙이면 오류가 발생한다. 이렇게 된다면 굳이 힘들게 옵셔널 타입을 사용하는 의미가 있을까?&lt;/p&gt;

&lt;p&gt;그래서 옵셔널 변수나 상수를 안전하게 사용하려면 조건이 따른다. 강제 해제 연산자를 사용할 때에는 먼저 옵셔널 값이 nil인지 점검해야 한다. 그리고 옵셔널 값이 nil이 아닐 떄에만 강제 해제 연산자를 붙여서 값을 추출해야 한다. 다음 구문을 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값이 변환되었습니다. 변환된 값은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ①&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값 변환에 실패하였습니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ②&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞서 여러 차례 설명한 바와 같이 Int(문자열) 생성자는 옵셔널 정수값을 반환한다. 따라서 위 예제에서 Int(문자열)의 결과를 대입받는 intFromStr 상수 역시 옵셔널 타입으로 정의된다. 옵셔널은 값이 없는 nil이거나 정상적인 값을 옵셔널 객체로 둘러싼 두 가지 경우만 존재하므로 옵셔널 값이 nil인지를 if 조건절로 점검해야 한다. 그리고 그에 맞는 조건절 블록 내에서만 강제 해제 연산자를 사용해야 한다. 이것이 오류 없이 안전하게 옵셔널 타입을 해제하여 사용할 수 있는 방법이다.&lt;/p&gt;

&lt;p&gt;위 예제에서 Int(문자열) 생성자의 변환 대상이 되는 문자열 “123”은 숫자로 변환할 수 있는 문자열이므로 intFromStr은 nil이 아니다. 정확히는 Optional(123)이다. 따라서 if 조건절이 참이 되면서 ①의 내용이 실행되므로 실행 결과는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;값이 변환되었습니다. 변환된 값은 123입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 대입된 값이 숫자로 변환할 수 없는 “Swift” 문자열이라면 어떻게 실행될까?&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값이 변환되었습니다. 변환된 값은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ①&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값 변환에 실패하였습니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ②&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;입력된 문자열은 Int(&lt;문자열&gt;)을 통해 숫자로 변환할 수 없는 값이므로 실행 결과는 nil이다. if 조건절이 거짓이므로 else 블록 영역인 ②가 실행된다. 따라서 결과는 다음과 같다.&lt;/문자열&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;값 변환에 실패하였습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;else 블록에서 ! 연산자를 사용하면 nil에 대한 옵셔널 강제 해제가 실행되어 오류가 발생한다. 따라서 ! 연산자는 확실히 옵셔널의 값이 nil이 아닌 조건에서만 사용해야 한다.&lt;/p&gt;

&lt;p&gt;위 구문에서 주의 깊게 살펴보아야 할 부분이 있다. if에서 nil 값을 비교하는 데 사용된 조건절이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 조건절에서 intFromStr와 비교연산자 != 사이에 의도적인 공백이 있음을 알아야 한다. 이 공백은 단순히 가독성을 높이기 위해 추기된 것이 아니다. 일반적으로 연산자 앞에 공백이 있을 필요는 없다. 일부는 가독성을 위해 공백을 집어넣기도 하지만 그것은 습관일 뿐, 컴파일러의 규칙상 반드시 그래야 하는 것은 아니다.&lt;/p&gt;

&lt;p&gt;그런데 이번처럼 옵셔널 타입의 nil 점검을 위한 != 연산자를 사용할 때는 반드시 앞에 공백을 두어야 한다. 문법의 오류를 방지하기 위한 목적이다. intFromStr 변수처럼 옵셔널 타입의 값을 비교 연산자와 함께 사용하면서 공백을 두지 않으면 컴파일러는 이 구문을 다음 두 가지로 해석할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 해석 ① : (intFromStr)!=(nil) -&amp;gt; 원래 의도한 대로 intFromStr 변수와 nil의 비교&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 해석 ② : (intFromStr)=nil -&amp;gt; intFromStr 변수의 옵셔널 강제 해제 + nil 값의 할당&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결국, 해석의 차이가 발생할 수 있으므로 구문이 모호해지는 결과를 가져온다. 컴파일러는 이를 확실하게 해석하지 못하므로 구문 분석 오류가 발생하게 된다. 이러한 상황을 방지하기 위해 옵셔널 타입이 비교 대상이라면 부등 비교 연산자(!=)를 사용할 때 공백을 두어야 한다. ‘아버지가방에들어가십니다’가 생각나는, 의외로 띄어쓰기가 중요해지는 이야기라고 할 수 있겠다.&lt;/p&gt;

&lt;h2 id=&quot;22-옵셔널-바인딩&quot;&gt;2.2 옵셔널 바인딩&lt;/h2&gt;

&lt;p&gt;앞에서 우리는 nil 체크 조건절을 사용하여 안전하게 옵셔널 타입을 해제할 수 있었다. 이 예제는 동일한 기능을 하는 비강제적인 해제 구문으로 바꾸어 작성이 가능하다. 이는 if 구문 내에서 조건식 대신 옵셔널 값을 일반 변수나 상수에 할당하는 구문을 사용하는 방식으로, &lt;strong&gt;옵셔널 바인딩(Optional Binding)&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;옵셔널 바인딩은 &lt;strong&gt;조건문 내에서 일반 상수에 옵셔널 값을 대입하는 방식&lt;/strong&gt;으로 이루어진다. 반드시 조건문에서 사용해야만 하며, 상수에 옵셔널 값을 대입한 결과는 true/false 로 리턴된다. 우리가 배운 대표적인 조건절인 if를 사용하여 옵셔널 바인딩하는 예제를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값이 변환되었습니다. 변환된 값은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값 변환에 실패하였습니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞의 구문과 매우 비슷하지만, infFromStr가 상수로 선언되었다는 점과 이 상수가 옵셔널이 아닌 일반 타입이라는 점이 다르다. 강제 해제 연산자를 사용하지 않아도 옵셔널 값이 일반 변수나 상수에 할당되면서 자연스럽게 옵셔널 타입이 해제되지만, 값이 nil이더라도 값의 할당이 실패하여 결과값이 false로 반환될 뿐이므로 오류는 발생하지 않는다. 단지 else 블록이 실행 될 뿐이다. 또다른 구문 하나를 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;intFromStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값 변환에 실패하였습니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;값이 변환되었습니다. 변환된 값은 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intFromStr&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;입니다.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 구문은 guard 구문을 이용하여 옵셔널 바인딩을 구현한 예제이다. guard 구문은 특성상 함수나 메소드에만 사용할 수 있기 때문에 intStr() 함수를 정의하고 그 안에 guard 구문을 작성하였다. 실제로 앱을 만드는 과정 거의 대부분은 함수로 이루어지기 때문에, guard 구문을 사용할 여지는 많다.&lt;/p&gt;

&lt;p&gt;guard 구문을 사용하더라도 옵셔널 바인딩 방식은 동일하다. 상수를 선언하고, 여기에 옵셔널 값을 대입하는 것이 전부다. 하지만 사용 용법상 if 구문 내에서 옵셔널 바인딩을 사용하는 것과 구분해야 할 필요는 있다. if 구문을 사용한 옵셔널 바인딩은 단순히 옵셔널 값의 처리 결과에 따라 서로 다른 피드백을 주고 싶을 때 사용한다. 하지만 guard 구문은 조건에 맞지 않으면 무조건 함수의 실행을 종료시키는 특성이 있기 때문에, 실행 흐름상 옵셔널 값이 해제되지 않으면 더 이상 진행이 불가능할 정도로 큰일이 생길 때에만 사용하는 것이 좋다. 참고로, 옵셔널 타입이긴 하지만 절대 nil 값이 들어가지 않을 것이라는 보장이 있을 때에는 강제 해제 연산자를 사용하여 옵셔널 타입을 처리하는 것이 효율적이다.&lt;/p&gt;

&lt;p&gt;옵셔널과 관련하여, 앞 장에서 학습했던 딕셔너리에 값을 입력하고 사용하는 예제를 다시 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 딕셔너리 선언&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;capital&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Seoul&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;EN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;London&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;FR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Paris&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 실행 결과
Optional(&quot;Seoul&quot;)
Seoul
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;딕셔너리에 키로 접근하면 그 결과값은 옵셔널 타입으로 반환된다. 값을 출력한 결과를 확인하면 금세 알 수 있다. 옵셔널 타입 대신 일반 타입의 값을 얻으려면 capital[“KR”] 뒤에 ! 연산자를 붙여야 한다. 그렇지 않으면 옵셔널 타입이 그대로 반환되어 예제에서 보는 것과 같이 Optional(“Seoul”)이 반환된다. 그런데 딕셔너리는 왜 옵셔널 타입의 값을 반환하는 것일까?&lt;/p&gt;

&lt;p&gt;딕셔너리에 키로 사용될 수 있는 값은 Hashable 프로토콜이 구현된 모든 자료형이라고 설명했다. 정해진 숫자 0, 1, 2, 3…만 차례대로 들어갈 수 있는 배열과 달리 딕셔너리는 미리 정해진 키 값만 사용되는 것이 아니라 무작위로 키가 사용될 수도 있다. 키 사용에 대한 제한이 거의 없는 거나 마찬가지이므로 키가 있는지를 점검하기도 어렵다.&lt;/p&gt;

&lt;p&gt;이 때문에, 딕셔너리에서 값을 읽을 때에는 존재하지 않는 키를 사용할 가능성이 있다. 이 경우 딕셔너리는 주어진 키에 값이 비어있거나 입력된 키가 아예 없다는 것을 표현하기 위해 nil을 반환해야 한다. 이 때문에 딕셔너리는 기본적으로 옵셔널 타입으로 정의된 값을 반환하게된다.&lt;/p&gt;

&lt;p&gt;사실 위 코드 역시 잘 구성된 코드는 아니다. nil 여부를 체크하지 않고 ! 연산자를 사용하여 바로 강제 해제를 실행한 것 때문이다. 이를 그대로 실행하면 오류가 발생할 수 있으므로 다음과 같이 보완하는 것이 좋다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 또는&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;옵셔널 타입에서 ! 연산자를 사용할 떄는 반드시 nil 점검을 해 주어야 오류를 미연에 방지할 수 있다는 점, 잊지 말아야 한다.&lt;/p&gt;

&lt;h2 id=&quot;23-컴파일러에-의한-옵셔널-자동-해제&quot;&gt;2.3 컴파일러에 의한 옵셔널 자동 해제&lt;/h2&gt;

&lt;p&gt;옵셔널 타입의 값을 사용하려면 항상 ! 연산자를 사용하여 옵셔널을 &lt;strong&gt;강제 해제(Forced-unwrapping)&lt;/strong&gt;하든가, 아니면 옵셔널 바인딩을 통해 일반 자료형으로 바꾸어 주어야 한다. 이렇게 해야 옵셔널 객체로 감싸진 값을 꺼낼 수 있다. 하지만 명시적으로 강제 해제를 하지 않아도 컴파일러에서 자동으로 옵셔널을 해제해주는 경우가 있다. 다음 예제를 보자&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;optInt == 123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;optInt != 123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문자열을 숫자로 변환한 옵셔널 상수의 값이 nil이 아니면 ! 연산자를 사용하여 옵셔널 값을 강제 해제하고 이 값을 정수 123과 비교하는 예제이다. 그 결과는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;optInt == 123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이번에는 강제 해제하지 않은 옵셔널 타입과 정수 123을 비교해보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;optInt == 123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;optInt != 123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;강제 해제하지 않은 옵셔널 값은 Optional(123)이므로 정수값 123과 다르다. 따라서 위 예제에서는 else 영역이 실행되어야 한다. 하지만 실제로 실행한 결과는 그렇지 않다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;optInt == 123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이상한 결과이다. 해제하지 않은 옵셔널 값 자체로 정수와 비교한 결과는 예상대로라면 일치하지 않는다고 나왔어야 한다. 그런데 결과는 값이 일치하는 것으로 보여주고 있다. 어떻게 된 것일까?&lt;/p&gt;

&lt;p&gt;옵셔널 타입으로 감싼 변수나 상수는 그 값을 사용하기 위해 반드시 ! 연산자를 사용하여 옵셔널 객체를 해제해야 한다. 하지만 굳이 해제하지 않아도 괜찮을 때가 있다. 옵셔널 객체의 값을 비교 연산자를 사용하여 비교하는 경우가 그에 해당하는데, 명시적으로 옵셔널 객체를 강제 해제하지 않아도 한쪽이 옵셔널, 다른 한쪽이 일반 타입이라면 자동으로 옵셔널 타입을 해제하여 비교 연산을 수행한다. 따라서 아래의 예제에서 모든 결과는 true이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tempInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tempInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tempInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tempInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tempInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;말하자면 비교 연산을 처리할 떄는 옵셔널 타입 여부에 구애받지 않고 일반 자료형처럼 값을 비교하면 된다는 것이다. 이는 옵셔널 타입에 값을 할당할 때도 마찬가지이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optValue01&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// ①&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optValue02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// ②&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원칙적으로 옵셔널 타입의 변수나 상수를 정의할 떄는 대입할 값을 Optional() 객체로 감싼 ①의 방식으로 처리해야 한다. 하지만 ②처럼 감싸지지 않은 순수 리터럴을 직접 대입할 수도 있다. 주의할 점은 타입 어노테이션 없이 직접 대입하면 단순히 일반 Int 타입의 변수로 선언되므로 타입 어노테이션을 추가하여 Int 타입이면서 동시에 옵셔널 타입이라는 것을 명시해 주어야 한다는 것 이다. 그러면 값 123은 대입될 대상이 옵셔널 타입이라는 것을 인지하고, 그것에 맞게 Optional(123)으로 변환된다.&lt;/p&gt;

&lt;h2 id=&quot;24-옵셔널의-묵시적-해제&quot;&gt;2.4 옵셔널의 묵시적 해제&lt;/h2&gt;

&lt;p&gt;옵셔널 타입을 해제하는 방법 중에는 &lt;strong&gt;묵시적 해제(Implicitly Unwrapped Optional)&lt;/strong&gt;라는 개념이 존재한다. 이것은 비록 옵셔널 타입이긴 하지만 값을 사용할 때에는 자동으로 옵셔널이 해제되기때문에 굳이 ! 연산자를 사용하여 해제할 필요가 없는 아주 편리한 구문이다. 컴파일러가 알아서 옵셔널을 해제해 준다는 점에서 방금 다루어 본 자동 해제와 유사하지만, 자동 해제가 비교 연산이나 값의 할당 등 일부 구문에 한정되는 것과 달리 묵시적 해제는 옵셔널 변수를 사용하는 모든 경우에 적용할 수 있으며, 옵셔널 변수의 타입을 선언할 떄 묵시적 해제를 미리 선언해 주어야 한다는 차이점이 있다.&lt;/p&gt;

&lt;p&gt;옵셔널의 묵시적 해제 구문은(이하 &lt;strong&gt;묵시적 옵셔널&lt;/strong&gt;) 일반 옵셔널 타입의 변수 선언 구문과 매우 유사하다. ? 연산자 대신 ! 연산자만 붙여주면 그뿐이다. 먼저 일반 옵셔널 변수를 선언하는 구문을 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 명시적 옵셔널 선언&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift Optional&quot;&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 구문의 실행 결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Optional(&quot;Swift Optional&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문자열 변수 str을 옵셔널 타입으로 선언하고, 여기에 “Swift Optional”이라는 문자열을 대입했다. 이를 출력해 보면 대입된 문자열이 옵셔널 객체로 감싸진 것을 확인할 수 있다. 이제 이 구문을 묵시적 옵셔널로 바꾸어 보자. 딱히 큰 수정이 필요하지는 않다. 단지 ? 연산자를 제거하고 ! 연산자로 그 자리를 대체하기만 하면 된다. 하지만 결과는 사뭇 다르다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 묵시적 옵셔널 선언&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift Optional&quot;&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Swift Optional
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;타입 어노테이션 뒤에 붙은 연산자 하나만 바꾸었을 뿐인데 결과는 전혀 달라졌다. 출력된 구문에서 옵셔널 객체가 사라졌다. 컴파일러에 의해 옵셔널 객체가 자동으로 해제된 것이다. 혹시 str 변수가 일반 타입인 것을 아닐까? 혹시 모르니 nil 값을 대입해 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nil을 대입해도 아무 문제가 없다. 이는 곧 str이 옵셔널 타입으로 정의되어 있음을 의미한다.&lt;/p&gt;

&lt;p&gt;이처럼 ! 연산자를 붙여 변수를 정의하면 옵셔널 타입이 된다. 하지만 일반적으로 옵셔널 타입을 사용할 때 필요한 강제 해제 연산자나 옵셔널 바인딩 과정 없이, 일반 변수처럼 다루어도 된다. 이는 묵시적 해제 선언이 이루어졌기 때문이다.&lt;/p&gt;

&lt;p&gt;묵시적 옵셔널을 사용하면 옵셔널 타입 변수의 연산도 간단하게 처리할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value01&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 오류&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value02&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반적으로 옵셔널 타입과 일반 타입을 직접 연산하는 것은 오류이지만, 묵시적 해제를 선언한 옵셔널 타입은 다르다. 직접 일반 타입과 연산해도 문제가 되지 않는다. 이처럼 묵시적 해제를 선언한 옵셔널은 일반 타입처럼 사용할 수 있기 때문에 굉장히 편리하게 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 무조건 모든 경우에 묵시적 옵셔널을 사용할 수 있는 것은 아니다. 옵셔널의 묵시적 해제 선언에서 염두에 두어야 할 것 한 가지가 있는데, 바로 &lt;strong&gt;변수의 값이 nil이 될 가능성이 있다면 묵시적 옵셔널 해제를 사용하지 않아야 한다&lt;/strong&gt;는 것이다.&lt;/p&gt;

&lt;p&gt;의아할 것이다. 변수가 nil이 될 가능성이 있을 때 사용하는 것이 옵셔널 타입인데 변수가 nil이 될 가능성이 있다면 사용하지 말라니. 그렇다면 도대체 언제 사용하는 것일까?&lt;/p&gt;

&lt;p&gt;묵시적 옵셔널 해제를 사용하는 경우는 한 가지로 정의할 수 있다. 바로,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;“형식상 옵셔널로 정의해야 하지만, 실제로 사용할 때에는 절대 nil 값이 대입될 가능성이 없는 변수일 때”&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이다. 다음 구문을 보자.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 구문은 Int(문자열)이 반환하는 값이 옵셔널 타입이기 떄문에 어쩔 수 없이 value 변수를 옵셔널 타입으로 선언해야 한다. 하지만 Int(“123”)은 누가 봐도 제대로 정수로 변환될 것이 확실하다. 이런 확실한 값에 굳이 옵셔널 처리를 해 줄 필요는 사실 거의 없다. 이때 위와 같이 value 변수를 묵시적 옵셔널로 선언한다면 옵셔널 타입 여부에 신경 쓰지 않고 일반 변수처럼 편하게 사용할 수 있다. 하지만 이 경우가 묵시적 옵셔널을 사용해야 하는 이유로 납득하기는 조금 어렵다. Int(“123”)! 처럼 대입하는 값 쪽에 강제 해제 연산자를 붙여주면 처음부터 value를 일반 변수로 만들어줄 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;실제로 묵시적 옵셔널이 정말 유용하게 사용되는 경우는 클래스 또는 구조체 내에서 이다. 주로 멤버 변수를 정의할 때 선언과 초기화를 분리시켜야 하는 경우에 해당한다. 아직 클래스를 배우기 전이므로 이해하기 어려울 것이다. 지금은 그냥 클래스에서는 묵시적 옵셔널 해제가 많이 사용되는구나 하는 정도로만 알고 있으면 될 것 같다.&lt;/p&gt;

&lt;p&gt;많은 사람이 옵셔널 개념의 도입 여부에 대해 의문을 표시한다. 필요할 떄만 값의 여부를 점검하여 정상적으로 값이 있을 때 처리할 수 있도록 코딩하면 될 것을 뭐하러 까다롭고 번거로운 옵셔널 개념을 도입했는가에 대해 말이다. 그러나 옵셔널의 강점은 안전성뿐만 아니라 안전성을 담보하는 과정에서 표현되는 코드의 간결성에 있다.&lt;/p&gt;

&lt;p&gt;다음은 애플에서 스위프트 언어를 발표할 때 제시했던 코드로, nil 값을 점검하면서 사용하는 오브젝티브-C 코드와 이를 옵셔널을 사용하여 간결하게 표현한 스위프트 코드를 함께 보여주고 있다. 이 처럼 옵셔널을 이용하여 간결하게 처리할 수 있는 문법을 &lt;strong&gt;옵셔널 체인(Optional Chain)&lt;/strong&gt;이라고 하는데, 스위프트의 옵셔널 개념이 코드를 얼마나 간결하게 만들어줄 수 있는지 보여주는 대표적인 예라고 할 수 있다. 옵셔널 체인에 대한 문법은 클래스에 대해 학습하는 과정에서 자세히 다루겠다.&lt;/p&gt;

&lt;div class=&quot;language-objectivec highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 오브젝티브-C 코드&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myDelegate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myDelegate&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;respondsToSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scrollViewDidScroll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:)])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myDelegate&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scrollViewDidScroll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myScrollView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 스위프트 코드&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myDelegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scrollViewDidScroll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myScrollView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/6-1/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/ios/2/&quot; class=&quot;btn btn--success&quot;&gt;iOS 면접 질문 목록 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/7-1/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><category term="옵셔널" /><category term="Optional" /><category term="언래핑" /><category term="unwrapping" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER06: 옵셔널 - 1. 옵셔널 타입 선언과 정의</title><link href="https://sanghyuk.dev/swift-grammar/6-1/" rel="alternate" type="text/html" title="CHAPTER06: 옵셔널 - 1. 옵셔널 타입 선언과 정의" /><published>2021-02-05T00:00:00+09:00</published><updated>2021-02-05T00:00:00+09:00</updated><id>https://sanghyuk.dev/swift-grammar/6-1</id><content type="html" xml:base="https://sanghyuk.dev/swift-grammar/6-1/">&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/swift.png&quot; alt=&quot;Swift&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;text-center&quot;&gt;&lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fsanghyuk.dev%2Fswift-grammar%2F6-1%2F&amp;amp;count_bg=%23FA7343&amp;amp;title_bg=%23555555&amp;amp;icon=swift.svg&amp;amp;icon_color=%23E7E7E7&amp;amp;title=Views&amp;amp;edge_flat=false&quot; alt=&quot;Hits&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;옵셔널(Optional)은 스위프트에서 도입된 새로운 개념으로서 언어 차원에서 프로그램의 안정성을 높이기 위해 사용하는 개념이다. 옵셔널의 개념을 한 문장으로 정의하자면 ‘nil을 사용할 수 있는 타입과 사용할 수 없는 타입을 구분하고, 사용할 수 있는 타입을 가리켜 옵셔널 타입(Optional Type)이라고 부른다’라고 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;여기서 말하는 nil이란, &lt;strong&gt;값이 없음&lt;/strong&gt;을 의미하는 특수한 값이다. 정수형의 0이나, 문자열의 ““과는 다른, 말 그대로 순수하게 하무 값도 없다는 것을 의미한다. 이런 특수성 때문에 nil은 종종 실제 값으로는 처리할 수 없는, 무엇인가 문제가 발생했을 때 이를 의미하기 위해 사용된다.&lt;/p&gt;

&lt;p&gt;앞에서 잠깐 다룬 딕셔너리를 떠올려보자. 저장된 값을 읽으려면 딕셔너리 변수명 뒤에 대괄호와 함께 키 값을 넣어주어야 하는데, 종종 잘못된 키를 대입할 때가 있다. 오타이거나, 혹은 이미 삭제된 키를 사용하는 경우가 대표적이다. 이같은 상황에서 스위프트는 우리에게 뭔가 ‘너 지금 잘못했어. 그 키는 지금의 딕셔너리에는 존재하지 않아’라고 알려주고 싶어한다.&lt;/p&gt;

&lt;p&gt;하지만 오류를 발생시키는 것은 그리 좋지 않다. 겨우 딕셔너리 키에 대한 잘못된 참조 하나 때문에 실행을 중단시키는 것은 매정할 뿐만 아니라, 스위프트는 최대한 안정성을 높이고자 노력하는 언어이다. 하지만 결과값을 공백을 반환할 수는 없다. 그랬다면 사용자가 자신이 실수한 것을 알지 못하고 정말 ‘그 키에는 공백이 저장되어 있었나보군’이라고 착각하게 될지도 모르기 때문이다. 이런 상황에서 스위프트는 오류도 발생시키지 않고 뭔가 문제가 있었다는 것도 알려주기 위해 nil이라는 값을 반환하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;capital&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;KR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Seoul&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;CN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Beijing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;JP&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Tokyo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;capital&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ko&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이처럼 스위프트에서는 값을 처리하는 과정에 문제가 있을 경우 많은 부분에서 오류를 발생시키는 대신 결과값을 nil로 반환한다. 하지만 모든 타입이 nil을 반환할 수 있는 것은 아니며 오직 옵셔널 타입만 nil을 반환할 수 있다. 다시 말해, nil을 반환하려면 해당 값이 옵셔널 타입으로 정의되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;여기에서 중요한 것은 “오류가 발생할 가능성”이다. 경우에 따라서는 오류가 발생하지 않을 수도 있지만, 언젠가 오류가 발생할 수 있는 가능성이 아주 조금이라도 있다면 모두 옵셔널 타입으로 정의해야 한다. 이해를 돕기 위해 또다른 예를 살펴보자. 문자열 “123”을 숫자로 변환해야 한다고 가정해 보겠다.&lt;/p&gt;

&lt;p&gt;일반적으로 사람의 인식에서는 “그저 큰따옴표만 떼면 된다”라고 생각할지도 모르겠지만, 프로그래밍에서 문자열 “123”을 숫자로 바꾸려면 다소 복잡한 변환 과정을 거쳐야 한다. 다행히 스위프트를 포함한 많은 프로그래밍 언어에서는 문자열을 숫자로 변환해주는 간편한 방법을 제공한다. 스위프트에서는 Int 객체의 생성자 옵션에 숫자로 변환할 문자열을 넣어주면 정수로 변환된다. 사용 형식은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;바꿀&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;문자열&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예를 들어, 문자열 “123”을 숫자로 바꾸려면 다음과 같이 작성하면 된다. 상수 num은 문자열 “123”이 아니라 정수 123이 대입된 Int 타입의 상수로 정의된다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 값을 넣어도 마찬가지이다. 문자열을 정수로 변환한 값을 얻을 수 있따. 그런데 만약 “123”이나 “456”처럼 숫자로 바꿀 수 있는 문자열 대신, 아래와 같이 문자열을 인자값으로 넣으면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;무척 난감한 상황이다. 일반 문자열은 숫자로 변환할 수 없기 떄문이다. 따라서 컴파일러는 이럴 떄 “죄송합니다. 이 문자열은 숫자로 변환할 수 없습니다”라고 난감함을 표현해야 한다. 개발자가 상황을 이해하고 적절히 대응할 수 있는 구문을 보완할 수 있도록 말이다.&lt;/p&gt;

&lt;p&gt;대부분 프로그래밍 언어에서는 이런 상황을 오류로 처리하거나 혹은 예외사항으로 처리한다. 오류 처리 구문을 사용할 수 있는 대표적인 언어인 자바는 이럴 떄 NumberFormatException() 예외를 발생함으로써 개발자가 인지하고 이에 대응하는 코드를 작성할 수 있도록 돕는다. 비단 자바뿐만 아니라 PHP도 오류 코드를 발생시키고, 자바스크립트 역시 NaN을 반환하여 변환에 실패했음을 알려준다.&lt;/p&gt;

&lt;p&gt;그러나 스위프트는 조금 다르다. 언어의 안정성을 위해 가급적 오류를 발생시키지 않으려고 노력한다. 오류가 발생하면 프로그램의 실행 흐름이 중단되고 경우에 따라 앱의 동작이 멈추거나 아예 꺼져버릴 수도 있으므로, 언어의 안정성을 위해서는 될 수 있으면 피해야 하는 상황일 수밖에 없다. 이런 맥락에서 스위프트는 문자열의 정수 변환이 실패하더라도 실행을 중지시키거나 오류를 발생시키지 않고 억지로 값을 반환하려고 노력한다. 반환하는 값이 그 무엇이 도든 간에 말이다.&lt;/p&gt;

&lt;p&gt;하지만 아무 값이나 반환할 수는 없다. 특히 0을 반환해서는 안 된다. 누군가 Int(“0”)을 호출했을 떄 정상적인 처리 결과로 정수 0이 반환된 경우와 구분할 수 없기 떄문이다. 또한 공백을 사용해서도 안 된다. 공백은 일반적으로 문자열로 처리되는 경향이 있어, 반환 타입이 일치하지 않을 뿐만 아니라 공백 또한 실패를 의미하는 값은 아니기 떄문이다. 이런 상황에서 개발자들은 실패를 의미하면서도 오류를 던지는 것이 아닌 값이 필요했다. 이런 목적에서 정의된 값이 바로 “값이 없음”을 뜻하는 nil이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;다른 언어에서 Null이나 null로 표현되기도 하는 nil은 &lt;strong&gt;값이 없다는 것&lt;/strong&gt;을 표현하기 위해 사용하는 일종의 특수 값이다. 이 값은 원래 오브젝티브-C에서 쓰이던 값이었는데, 스위프트로 넘어오면서 의미가 약간 달라졌다. 오브젝티브-C에서는 빈 메모리 주소를 가리키는 값이었지만 스위프트에서는 단순히 &lt;strong&gt;‘값이 없음’&lt;/strong&gt;을 의미하게 된 것이다. 스위프트에서는 뭔가 연산 과정에서 정상적으로 값을 처리하지 못하는 상황이 발생했을 떄 제대로 된 결과값 대신 nil을 반환한다. 앞에서 예로 든 문자열을 숫자로 변환하는 과정에서도 잘못된 인자값으로 인해 문자열의 정수 반환이 실패했을 떄, ‘인자값이 잘못되었으므로 이 변환 처리는 실패입니다. 따라서 아무 값도 반환되지 않습니다’라는 의미를 표현하기 위해 nil을 반환한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런데 스위프트에서는 nil의 사용에 제약을 걸어두었다. 바로 일반 자료형은 nil 값을 가질 수 없다는 것이다. 문자열이나 정수 등은 일반 자료형이기 때문에 &lt;strong&gt;‘값이 없음’&lt;/strong&gt;을 뜻하는 nil 값을 저장할 수 없다. 만약 일반 자료형에 억지로 nil 값을 대입하려고 하면 다음과 같은 오류가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/1.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/1.png&quot; alt=&quot;일반 자료형에 nil을 대입하려고 했을 때의 오류&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;함수에서 값을 반환할 때에도 마찬가지이다. 함수는 반환 타입이 정해져 있기 때문에 항상 그 타입에 맞는 값을 반환해야 하는데, 처리 과정이 실패했을 경우에는 nil을 반환하게 된다. 하지만 일반 자료형에는 nil 값을 할당할 수 없다는 스위프트의 특성 때문에 nil을 반환하면 오류가 발생한다.&lt;/p&gt;

&lt;p&gt;이때 사용하는 타입이 바로 옵셔널 타입이다. 옵셔널 타입으로 선언된 자료형은 nil 값을 저장할 수 있다. 만약 nil 값을 저장해야 하거나 혹은 함수의 반환값에 nil이 포함될 가능성이 있다면, 다시 말해 오류가 발생할 가능성이 있다면 반환 타입을 반드시 옵셔널 타입으로 설정해야 한다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int(&amp;lt;바꿀문자열&amp;gt;)&lt;/code&gt; 구문의 반환 타입은 옵셔널 타입으로 정의된다.&lt;/p&gt;

&lt;p&gt;사실 옵셔널 타입은 별도로 존재하는 자료형이 아니다. 스위프트에서 모든 기본 자료형들은 그에 대응하는 옵셔널 타입이 존재한다. 다시 말해 정수형에 대응하는 옵셔널 타입과, 문자열에 대응하는 옵셔널 타입이 모두 있다는 뜻이다. 또한, 클래스나 구조체를 이용하여 만든 객체도 옵셔널 타입으로 바꿀 수 있다. 함수를 통해서 반환 가능한 모든 타입들 역시 옵셔널 타입으로 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;어떤 자료형을 사용하는지에 따라 대응하는 옵셔널 타입은 다르다. 정수 타입을 옵셔널 타입으로 변경하면 Optional Int 타입이 되고, 문자열을 옵셔널 타입으로 바꾸면 Optional String이 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int(&amp;lt;바꿀문자열&amp;gt;)&lt;/code&gt; 구문의 반환타입은 Optional Int이다.&lt;/p&gt;

&lt;p&gt;그런데 스위프트에서 옵셔널 타입이 실제로 가질 수 있는 값의 종류는 오직 두 가지 뿐이다. 하나는 &lt;strong&gt;nil이 아닌 값&lt;/strong&gt;, 또다른 하나는 &lt;strong&gt;nil 값&lt;/strong&gt;이다. nil이 아닌 값은 실제 실행 결과에서 오류가 발생하지 않았을 때 반환되며, 실제 실행 과정에서 오류가 발생했을 때에는 nil이 반환된다.&lt;/p&gt;

&lt;p&gt;헷갈릴지도 모르겠지만 여기에서 말하는 ‘nil이 아닌 값’은 “ABC” 또는 123 등의 구체적인 값이 아니라 정말 nil이 아닌 값 그 자체이다. 이것은 반환하려는 실제 값이 옵셔널이라는 객체로 둘러 싸인 상태를 의미한다. 다시 말해 처리 과정에 문제가 있었다면 nil이 반환되고, 문제가 없어 처리가 성공했다면 옵셔널 객체로 감싸진 결과값이 반환된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/2.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/2.png&quot; alt=&quot;옵셔널 타입이 가질 수 있는 값의 경우&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;결국, 옵셔널 타입이란 &lt;strong&gt;반환하고자 하는 값을 옵셔널 객체로 다시 한 번 감싼 형태&lt;/strong&gt;를 의미한다. 하지만 성공했을 때에는 일반 값을 반환하고, 그렇지 않으면 특수하게 처리된 예외나 NaN 값을 반환하는 방식으로 나누어 반환하는 다른 프로그래밍의 반환 방식과는 다르다. 스위프트에서는 일단 오류가 발생할 가능성이 있기만 하면, 성공적으로 처리했더라도 일단 옵셔널 타입으로 감싸서 반환하기 떄문이다.&lt;/p&gt;

&lt;p&gt;문자열 “123”을 숫자로 변환한 값을 반환하고자 한다면 실제로 변환된 값 123을 직접 반환하는 것이 아니라 옵셔널 타입으로 값을 감싼 Optional(123)을 반환한다. 만약 숫자로 변환하지 못할 문자열(예를 들어, “안녕하세요”와 같은)이 입력되어 정상적인 변환이 불가능한 상황이라면 Optional(“안녕하세요”)가 아니라 nil 값을 반환한다. 이떄 Optional(123)과 nil은 모두 옵셔널 타입이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/3.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/3.png&quot; alt=&quot;문자열의 정수 변환 처리 결과&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;처리가 성공적일 경우, 옵셔널 타입으로 반환된 값을 열어보면 실제 값이 옵셔널 타입으로 둘러싸여 있는 것을 볼 수 있다. 이를 &lt;strong&gt;옵셔널 래핑(Optional Wrapping)&lt;/strong&gt;이라고 한다. 이렇게 받은 값은 &lt;strong&gt;옵셔널 언래핑(Optional Unwrapping)&lt;/strong&gt;이라고 불리는 특수한 처리 과정을 통해 옵셔널 타입을 해제하고 실제 값을 추출하여 사용해야 한다. 단, 처리 결과가 실패여서 옵셔널 타입의 값이 nil이라면 옵셔털 타입을 해제해서는 안 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/4.png&quot;&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2021-02-05-6-1/4.png&quot; alt=&quot;문자열의 정수 변환 처리 결과&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;질문 : 차라리 모든 값을 옵셔널 타입으로 선언하고 사용하면 안 되나요? 일반 타입과 옵셔널 타입으로 나누어 사용하는 건 헷갈리고 불편할 것 같아서요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모든 값을 옵셔널 타입으로 선언하는 것은, 일반 자료형에 nil 값을 대입할 수 잇도록 허용하는 것과 다를 바가 없다. 그런데 모든 값이 nil을 가질 수 있다는 것은 또 다른 문제를 발생시킨다. 값을 사용할 때마다 일일이 nil인지 아닌지를 체크하여 사용해야 한다. 이는 프로그래밍 로직을 복잡하게 만들 뿐만 아니라 처리 과정 또한 어렵게 만든다. 그러므로 꼭 필요한 경우에만 제한적으로 옵셔널 타입을 적용하는 것이 좋다.&lt;/p&gt;

&lt;h1 id=&quot;1-옵셔널-타입-선언과-정의&quot;&gt;1. 옵셔널 타입 선언과 정의&lt;/h1&gt;

&lt;p&gt;일반 자료형을 옵셔널 타입으로 만드는 방법은 단순하다. 우리가 사용하는 자료형 뒤에 퀘스천 마크(물음표)만 붙이면 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'String?'&lt;/code&gt; 은 Optional String 타입을 의미하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'Int?'&lt;/code&gt;는 Optional Int 타입을 의미한다. String 타입에는 nil을 대입할 수 없지만 String? 타입에는 nil을 대입할 수 있다. 다음 예제들은 다양한 옵셔널 타입을 보여주고 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Int 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 String 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Double 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optDouble&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Array 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Dictionary 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optDic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optDic2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Class 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AnyObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반 자료형을 선언만 하고 초기화하지 않으면 아예 아무것도 할당되지 않지만, 옵셔널 타입으로 자료형을 선언하면 자동으로 nil로 초기화된다. 물론, 옵셔널 내부에 있는 자료형에 nil 값이 부여된다는 것은 아니다. 옵셔널 타입 자체에 nil이 부여된다는 것이다.&lt;/p&gt;

&lt;p&gt;옵셔널 타입으로 선언된 변수나 상수에 실제 값을 할당하는 방법은 일반 타입의 그것과 동일하다. 다음은 옵셔널 타입의 변수와 상수에 값을 할당하는 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Int 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;optInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 String 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;optString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Swift&quot;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Array 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optArr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;optArr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;JAVA&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Objective-C&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;SmallTalk&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 옵셔널 Dictionary 타입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;optDic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;optDic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;국어&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;94&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;수학&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;88&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;영어&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;96&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;옵셔널 타입의 변수에 값을 할당할 때에는 옵셔널 타입임을 인지할 필요가 거의 없다. 일반 변수처럼 값을 할당하면 옵셔널 객체 내부에 값이 대입되기 때문이다. 즉, 값을 대입할 때에는 옵셔널이 아닌 일반 변수처럼 생각하고 다루어도 무방하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/2-5/&quot; class=&quot;btn btn--info&quot;&gt;이전 내용 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/ios/2/&quot; class=&quot;btn btn--success&quot;&gt;iOS 면접 질문 목록 보기&lt;/a&gt;
&lt;a href=&quot;https://sanghyuk.dev/swift-grammar/6-2/&quot; class=&quot;btn btn--info&quot;&gt;다음 내용 보기&lt;/a&gt;
&lt;/center&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><category term="옵셔널" /><summary type="html">스위프트 문법 스터디</summary></entry></feed>