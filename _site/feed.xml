<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-03T12:00:54+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Sanghyuk’s Blog</title><subtitle>Sanghyuk's Blog</subtitle><author><name>SANGHYUK LEE</name></author><entry><title type="html">Mac 업데이트 후 xcrun error 해결방법</title><link href="http://localhost:4000/git/2/" rel="alternate" type="text/html" title="Mac 업데이트 후 xcrun error 해결방법" /><published>2020-12-03T00:00:00+09:00</published><updated>2020-12-03T00:00:00+09:00</updated><id>http://localhost:4000/git/2</id><content type="html" xml:base="http://localhost:4000/git/2/">&lt;p&gt;MacOS를 업데이트를 할 때마다 여러 문제가 발생하는데, 이번에도 개발 관련 이슈가 터졌다. 매번 구글에 검색하여 해결했는데 이번에는 블로그에 간단하게 정리하려고 한다.&lt;/p&gt;

&lt;p&gt;깃에 커밋을 하려고 디렉토리로 이동을 했는데 왠지 모르게 어색한 느낌이 들었다. 자세히 보니 터미널에 브랜치 표시도 나오지 않았고 해당 디렉토리의 현재 상태도 보이지 않았다. 아니나 다를까 깃에 문제가 생겨있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Git/2020-12-03-2/1.png&quot; alt=&quot;xcrun 에러&quot; /&gt;&lt;/p&gt;

&lt;p&gt;찾아보니 해당 오류는 git을 비롯하여 다수의 개발 툴들이 xcrun 에러를 뱉는다고 한다. xcode cli 이슈라고 하는 것 같은데 해결 방법은 의외로 간단했다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xcode-select&lt;/code&gt; 명령어를 사용하여 xcode cli만 따로 설치하는 방법으로 이 문제를 해결할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ xcode-select --install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Git/2020-12-03-2/2.png&quot; alt=&quot;xcode-select 명령어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 진행하면 __‘xcode-select’ 명령어는 명령어 라인 개발자 도구가 필요합니다. 도구를 지금 설치하겠습니까?__라는 메시지와 함께 팝업창이 등장한다. 설치 버튼을 누르면 설치가 시작되고 설치에는 2분 정도 소요된 것 같다. 설치가 완료되면 git이 정상적으로 돌아온 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Git/2020-12-03-2/3.png&quot; alt=&quot;정상으로 돌아온 git&quot; /&gt;&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="git" /><category term="Swift" /><category term="git" /><category term="terminal" /><category term="error" /></entry><entry><title type="html">Swift 개발자 면접 질문 List</title><link href="http://localhost:4000/interview/1/" rel="alternate" type="text/html" title="Swift 개발자 면접 질문 List" /><published>2020-11-12T00:00:00+09:00</published><updated>2020-11-12T00:00:00+09:00</updated><id>http://localhost:4000/interview/1</id><content type="html" xml:base="http://localhost:4000/interview/1/">&lt;h1 id=&quot;swift-개발자-면접-질문-list&quot;&gt;Swift 개발자 면접 질문 List&lt;/h1&gt;

&lt;p&gt;개발자를 채용하는 면접에는 기술 면접이 있다. 여러번 면접을 경험하다 보니 특정 질문들을 자주 받는 느낌이 들었다. 업무를 진행하는데 있어서 중요한 부분들을 주로 질문한다고 생각이 들었고, 그 말은 반대로 꼭 공부해야 알아야 할 부분이라는 생각이 들었다. 그래서 실제 면접을 통해서 받는 질문들을 정리하려고 한다.&lt;/p&gt;

&lt;p&gt;우선 나는 Swift 언어로 개발하는 iOS 개발자이므로 Swift 와 관련된 질문들이 주가 될 것이다. 기술적인 질문들과 개발자 한 사람 자체를 평가하기 위해 하는 질문들도 포함하여 정리해보겠다.&lt;/p&gt;

&lt;h2 id=&quot;기술-관련&quot;&gt;기술 관련&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Class 와 Struct 의 차이점&lt;/li&gt;
  &lt;li&gt;동기와 비동기의 차이점&lt;/li&gt;
  &lt;li&gt;Swift 의 접근제어자의 종류와 범위&lt;/li&gt;
  &lt;li&gt;Swift 에서으 소켓통신&lt;/li&gt;
  &lt;li&gt;프로세스와 스레드&lt;/li&gt;
  &lt;li&gt;프로세스와 스레드의 차이점&lt;/li&gt;
  &lt;li&gt;Serial Queue, Concurrent Queue 차이&lt;/li&gt;
  &lt;li&gt;깃 플로우&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;협업-관련&quot;&gt;협업 관련&lt;/h2&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Interview" /><category term="Interview" /></entry><entry><title type="html">CHAPTER02: Xcode - 3. Xcode 설치</title><link href="http://localhost:4000/swift-grammar/2-3/" rel="alternate" type="text/html" title="CHAPTER02: Xcode - 3. Xcode 설치" /><published>2020-10-26T00:00:00+09:00</published><updated>2020-10-26T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/2-3</id><content type="html" xml:base="http://localhost:4000/swift-grammar/2-3/">&lt;h1 id=&quot;3-xcode-설치&quot;&gt;3. Xcode 설치&lt;/h1&gt;

&lt;p&gt;Xcode는 애플 전용 데스크톱 운영체제인 macOS에서만 실행할 수 있다. 따라서 애플에서 출시한 맥북(MacBook), 맥북 프로(MacBook Pro), 맥북 에어(MacBook Air), 아이맥(iMac), 맥 미니(Mac Mini), 맥 프로(Mac Pro) 중 하나가 필요하다. 마이크로소프트사의 Windows 운영체제가 설치된 일반 PC에서는 Xcode를 설치할 수 없다.&lt;/p&gt;

&lt;p&gt;과거에는 Xcode를 내려받기 위해서 맥 OS 개발자 프로그램이나 iOS 개발자 프로그램에 가입해야 했다. 그렇지 않으면 별도 비용을 지불한 뒤에 내려받아야 했다. 물론 개발자 프로그램에 가입하는 것도 비용이 발생하므로 Xcode는 유료로 제공되는 툴이었다고 볼 수 있다. 하지만 스위프트의 발표와 함께 Xcode에 대한 라이선스를 무료 제공 방식으로 전환하면서 이제는 거의 제약 없이 무료로 내려받을 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;Xcode의 정식 버전은 항상 앱스토어에서 받을 수 있지만, 베타 버전은 애플에서 제공하는 애플 개발자 사이트에서만 내려받을 수 있다. 베타 버전은 정식 버전보다 한발 앞서 최신 개선사항을 적용해 볼 수 있다는 장점이 있지만 아직 안정화되지 않은 버전이어서, 개발 도중 알 수 없는 오류로 인하여 Xcode가 다운되기도 한다. 호환성이 담보되지 않은 문법 및 구분 변경으로 인해 멀쩡하게 잘 돌아가던 스위프트 소스 코드들이 새 베타 버전의 Xcode에서 빨간 오류를 정신없이 뱉어낼 수도 있다. 이런 일들로 인한 스트레스를 덜 받고 안정적으로 사용하려면 가급적 앱스토어에서 제공하는 정식 버전을 이용하는 편이 좋다.&lt;/p&gt;

&lt;h2 id=&quot;31-정식-버전-설치--앱스토어&quot;&gt;3.1 정식 버전 설치 : 앱스토어&lt;/h2&gt;

&lt;p&gt;Xcode 정식 버전은 항상 앱 스토어를 통해 제공된다. 설치를 위해 맥 환경에서 앱스토어를 실행해 보자. 실행된 앱스토어 창의 왼쪽 위에 있는 검색 창에 Xcode를 입력하여 검색하면, 큼지막한 망치가 떡하니 자리 잡은 Xcode 앱 아이콘을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2020-10-26-2-3/1.png&quot; alt=&quot;앱스토어에서 Xcode 검색&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앱 아이콘을 클릭하여 상세페이지로 진입한 다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;설치&amp;gt;&lt;/code&gt; 버튼을 클릭하면 로그인 과정을 거쳐 자동으로 Xcode 설치가 시작된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2020-10-26-2-3/2.png&quot; alt=&quot;앱스토어를 통한 Xcode 정식 버전 설치&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치 과정에서 등장하는 로그인 창에서는 애플에 등록된 계정을 입력하면 된다. 앱스토어에서 다른 앱을 내려받을 때 사용하던 일반 계정으로도 Xcode를 내려받고 설치하는 데에 아무 문제 없으므로 그냥 사용하면 된다. 이와 달리 베타 버전을 내려받을 경우에는 애플에 등록된 개발자 계정이 있어야 하니, 이를 구분해서 알아두면 될 것 같다. 물론 개발자 계정 등록은 무료이다.&lt;/p&gt;

&lt;p&gt;설치는 비교적 간단하다. 정식 버전으로 출시된 Xcode는 단순히 앱스토어를 거쳐 설치하기만 하면 끝이므로 크게 신경 써야 할 부분은 없다. 설치가 완료되면 위 앱스토어에 표시된 Xcode 아이콘이 맥의 응용프로그램에도 자동으로 추가되므로, 이를 통해 Xcode가 정상으로 설치되었음을 확인할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;32-베타-버전-설치--애플-개발자-사이트&quot;&gt;3.2 베타 버전 설치 : 애플 개발자 사이트&lt;/h2&gt;

&lt;p&gt;만약 여러분이 최신 문법과 곧이어 발표될 새 iOS 버전에 한발 앞서 대응하고 싶다면, 앱 스토어를 통해 Xcode 정식 버전을 사용할 것이 아니라, 애플 개발자, 사이트에서, 베타 버전의 Xcode를 내려받아 사용해야 한다. 다음은 베타 버전을 받을 수 있는 URL이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;애플 개발자 사이트 : https://developer.apple.com/download/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/Swift-Grammar/2020-10-26-2-3/3.png&quot; alt=&quot;애플 개발자 사이트(https://developer.apple.com/download/)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개발자 사이트를 통해 내려받은 파일은 xip 확장자 형식으로, ‘Extract in Place’ 또는 ‘Execute in Place’의 약자이다. ZIP 형식의 압축 파일과 비슷하지만, 파일의 압축을 해제하기 전에 먼저 파일의 변경이 없었는지 여부를 애플로부터 인증을 받는 압축 형식으로, Xcode 8 버전의 다운로드부터 적용되었다. macOS는 유닉스 시스템을 기반으로 하고 있기 때문에, 다운로드된 xip 파일은 압축을 해제한 결과물을 응용프로그램 폴더에 복사하는 형태로 프로그램이 설치된다. 설치된 프로그램을 제거할 때는 프로그램이 설치된 디렉터리를 응용프로그램 폴더로부터 삭제하기만 하면 된다.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER02: Xcode - 2. Xcode란?</title><link href="http://localhost:4000/swift-grammar/2-2/" rel="alternate" type="text/html" title="CHAPTER02: Xcode - 2. Xcode란?" /><published>2020-10-19T00:00:00+09:00</published><updated>2020-10-19T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/2-2</id><content type="html" xml:base="http://localhost:4000/swift-grammar/2-2/">&lt;h1 id=&quot;2-xcode란&quot;&gt;2. Xcode란?&lt;/h1&gt;

&lt;p&gt;Xcode는 앞으로 우리가 인터넷 브라우저만큼이나 자유자재로 다루어야 할 툴로서, iOS와 macOS용 앱을 개발할 수 있도록 애플에서 제공하는 IDE이다. ‘엑스코드’라고 읽으며, 맥북 등 애플 컴퓨터의 운영체제인 맥 OS에서만 실행되는 애플리케이션이다. 우리는 이 Xcode를 이용하여 오브젝티브-C나 스위프트를 작성하고, 애플리케이션을 개발한다.&lt;/p&gt;

&lt;p&gt;일반적으로 C 기반의 코드를 컴파일할 때 많이 사용되는 GCC라는 컴파일러가 있는데, Xcode는 GCC의 성능을 더욱 개선한 LLVM을 메인 컴파일러로 사용한다. 오브젝티브-C나 스위프트 코드 모두 실행 파일로 만들어질 때에는 LLVM 컴파일러에 의해 컴파일된다. Xcode가 공식적으로 지원하는 언어에는 C, C++, 오브젝티브-C, 스위프트, 자바, 파이썬, 루비 등이 있으며, 플러그인을 사용하면 파스칼, C#, 펄 등의 언어도 지원 가능하다.&lt;/p&gt;

&lt;p&gt;Xcode는 무척 방대한 역사를 자랑하는 애플리케이션이다. Xcode의 시작은 맥 OS의 시작과 거의 일치하는데, 맥 OS가 시작된 해가 2003년도이므로, Xcode는 11년 정도의 역사를 가지고 있다. 이것만으로도 충분히 오래되었다고 할 수 있지만, 따지고 보면 맥 OS의 전신이라고 할 수 있는 NeXTSTEP 운영체제 시절부터 Xcode는 이미 프로젝트 빌더(Project Builder)라는 이름으로 제공되고 있었기 때문에 이를 감안한다면 Xcode는 1988년에 출시된, 무료 26년의 유구한 역사를 가지는 IDE가 되는 셈이다.&lt;/p&gt;

&lt;p&gt;프로젝트 빌더가 Xcode로 이름이 바뀌고 제로링크, 분산 빌드 옵션, 코드 센스 인덱싱 등을 지원하기 시작하면서, Xcode는 명실상부하게 맥 OS의 공식 개발환경이 되었다. 이 과정에서 과거 카본 기반으로 작성되었던 SDK의 API들이 모두 오브젝티브-C 언어와 코코아 프레임워크(Cocoa Framework)로 재작성되기도 했다. 그 이후로 시간이 흐르면서 카본 프레임워크의 위치를 코코아 프레임워크가 잠식해 나갔다(현재는 코코아 프레임워크와, 아룰 가번욿 iOS나 watchOSㄹㄹ 지원하는 코코아 터치 프레임워크를 스위프트 언어로 재작성하는 작업이 다시 이루어졌다).&lt;/p&gt;

&lt;p&gt;Xcode에서 아이폰용 앱을 만들 수 있게 된 것은 Xcode 3 버전부터이다. 예전부터 맥 OS를 써왔던 사람이라면 경험해보았을 OS X Leopard의 출시와 함께 공개되었다(맥북이나 아이맥 등 데스크톱용 애플 기기의 운영체제에는 버전에 따른 별칭이 있는데, Leopard는 10.5버전에 붙은 이름이다). 이때 애플의 메인 컴파일러인 LLVM도 함께 덧붙여졌다.&lt;/p&gt;

&lt;p&gt;Xcode 4는 기존 버전에 비해 굉장히 많은 면에서 변신이 일어났다. 현재의 Xcode 외형과 비슷한 모습을 가지게 된 것도 Xcode 4부터이며, 기존에는 별도의 독립 애플리케이션 형태였던 인터페이스 빌더가 이 버전부터 Xcode 내부에 모듈 형태로 탑재됨에 따라 Xcode 하나만으로 앱을 개발할 수 있게 되었다. 동시에, 객체의 참조 카운팅을 컴파일러에서 스스로 처리하는 ARC 기능이 추가되기도 하였다.&lt;/p&gt;

&lt;p&gt;Xcode 4.2버전에서 Xcode는 완벽하게 단일 애플리케이션으로 통합되었다. 이전에는 앱스토어에서 Xcode를 직접 내려받는 것이 아니라 Xcode 설치 프로그램을 내려받은 후 이를 실행하면 Xcode를 내려받는 방식이었지만, 이 버전부터 Xcode를 직접 내려받게 되었다. 사용자는 애플리케이션을 내려받은 후 실행하면 끝이다. 설치에 있어서도 조금 더 간편해진 셈이다. 이를 통해 비로소 Xcode는 하나의 완전한 앱 개발 환경을 구성할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;iOS 7의 발표와 함께 공대된 Xcode 5는 iOS 7의 달라진 UI를 지원하기 위해 기존 버전의 UI를 호환성 있게 가져가는 데에 주력했다. 내장된 인터페이스 빌더에 많은 변화가 있었는데, 개발 UI 화면 단위로 하나씩만을 다루던 nib 파일 기반의 인터페이스 빌더가 스토리보드(storyboard) 파일 형식의 통합 인터페이스 빌더 위주로 대체된 것이 가장 큰 이슈라고 할 수 있다. 스토리보드 형식은 화면 인터페이스를 설계할 때 &lt;strong&gt;여러 개의 화면을 하나의 스토리보드 파일에 모아 다룸으로써 화면 간의 연결 관계나 흐름을 쉽게 파악할 수 있도록 지원하는 형식&lt;/strong&gt;으로, Xcode 4 버전부터 공개되었지만 본격적으로 사용하게 된 것은 Xcode 5 버전부터이다.&lt;/p&gt;

&lt;p&gt;이후 스위프트와 함께 공개된 Xcode 6은 외견상 큰 변화는 없었다. 하지만 Xcode가 스위프트를 지원하기 시작하면서 실시간으로 스위프트 코드를 작성하고 결과를 확인할 수 있도록 해주는 플레이그라운드가 추가된 점은 특기할 만한 사항이다.&lt;/p&gt;

&lt;p&gt;다음 해인 2015년에 발표된 Xcode 7은 스위프트 2를 지원할 뿐만 아니라, 맥 OS X, iOS, watchOS용 앱을 모두 만들 수 있는 더욱 확장된 개발 환경을 제공했다. 전체적인 외관이 조금 더 다듬어졌고, 세련된 UI를 가지게 된 것은 말할 필요도 없다.&lt;/p&gt;

&lt;p&gt;2016년에 발표된 Xcode 8에서 외관상 뚜렷한 변화는 없었다. 하지만 Xcode 7에서 스토리보드의 확대 축소가 제한적이었던 것과 달리 Xocde 8에서는 여러 단계로 스토리보드를 축소 또는 확대해서 작업할 수 있게 되었다. 또한 스토리보드 축소 시 화면 UI에 대한 편집 작업이 허용되지 않았던 과거 버전에서 발전하여 화면이 축소된 상태에서도 필요한 UI 편집 작업을 얼마든지 수행할 수 있게 됨으로써 화면 설계 작업이 훨씬 편리해졌다. 개인적으로 이같은 스토리보드와 기능 변화가 제일 달콤하게 느껴지는 부분이다.&lt;/p&gt;

&lt;p&gt;2017년에는 Swift 4, iOS 11의 발표에 맞추어 Xocde 9이 공개되었다. 이 버전 역시 Xcode의 외관상 변화는 크지 않지만, 대신 함께 제공되는 iOS 시뮬레이터가 드라마틱하게 변신했다는 점을 주목할 만하다. 이전 버전까지의 시뮬레이터는 단순히 화면과 기능만 테스트할 수 있는 밋밋한 일반 창 형태에 불과했던 것이, Xcode 9에서는 아이폰 형태를 그대로 본딴 모습으로 재탄생했을 뿐만 아니라 이전 버전에서는 단축키로 해결해야만 했던 홈버튼도 부활했다. 게다가 이제는 임의대로 시뮬레이터 크기를 늘리고 줄일 수도 있게 되었다. 뿐만 아니라, iPhone 외에 watchOS, tvOS용 시뮬레이터도 동시에 실행하여 결과를 확인할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;이외에도 Xcode 9에서 생긴 몇 가지 변화를 꼽아본다면 깃허브 연동을 위한 소스 컨트롤 기능이 내비게이터 패널에 추가되었다는 점, 오토 레이아웃 설정 시 화면상의 변화를 바로바로 확인 할 수 있게 되었다는 점, 오토 레이아웃 설정 시 화면상의 변화를 바로바로 확인 할 수 있게 되었다는 점, Swift 3 코드의 호환성 유지를 위한 컴파일러 버전 설정이 추가되었다는 점 등을 들 수 있을 것 같다. 전체적으로 Xcode 9은 Swift 3와 Swift 4 버전간의 호환성을 유지하는 데에 주력한 면이 크다.&lt;/p&gt;

&lt;p&gt;이처럼 해마다 버전이 업그레이드되면서 Xcode는 그 형태를 다양하게 바꾸어나가고 있다. 주의할 것은, 최신 iOS 버전을 기준으로 개발 작업을 진행하기 위해서는 항상 최신 벚번의 Xcode를 사용해야 한다는 점이다. 일부 IDE의 경우 최신 버전의 언어 문법을 사용하기 위해서는 플러그인 정도만 추가해주기도 하지만, Xcode는 새 버저의 전체 업데이트를 통해서만 최신 iOS를 지원하는 앱을 제작할 수 있다. 따라서 앱을 개발할 때에는 Xcode의 버전 업데이트 여부를 항상 신경 써야 한다(사실 방법이 있지만 나중에 소개하도록 한다).&lt;/p&gt;

&lt;p&gt;스위프트 언어를 지원하기 시작하는 Xcode 버전은 6부터지만 여기서 다루는 스위프트 4 문법은 Xcode 9 버전부터 지원한다. 앱스토어를 통해 Xcode 정식 버전을 설치하는 방법과 개발자 사이트를 통해 베타 버전을 설치하는 방법 모두를 알아보자.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">Single Sign On (SSO)</title><link href="http://localhost:4000/development/1/" rel="alternate" type="text/html" title="Single Sign On (SSO)" /><published>2020-10-15T00:00:00+09:00</published><updated>2020-10-15T00:00:00+09:00</updated><id>http://localhost:4000/development/1</id><content type="html" xml:base="http://localhost:4000/development/1/">&lt;h1 id=&quot;single-sign-on-sso&quot;&gt;Single Sign On (SSO)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 번의 로그인으로 여러 개의 서비스들을 이용할 수 있게 해주는 시스템&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SSO(Single Sign On)는 가장 기본적인 &lt;strong&gt;인증 시스템&lt;/strong&gt;이다. ‘모든 인증을 하나의 시스템에서’라는 목적하에 개발된 것이다. 즉 시스템이 몇 대가 되어도 하나의 시스템에서 인증에 성공하면 다른 시스템에 대한 접근 권한도 모두 얻는 것이다.&lt;/p&gt;

&lt;p&gt;SK텔레콤의 연계 사이트에서는 하나의 패스워드를 가지고 중복 가입 없이 이용할 수 있다. 이러한 웹 기반의 SSO는 가입자의 인터넷 사용에 대한 정보를 좀 더 효과적으로 얻어낼 수 있다는 이점 때문에 사용률이 매년 증가하고 있다. 하지만 개인정보 보호 측면에는 우려되는 점이 많아 기업과 개인간의 입장이 상반된다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;SSO의 가장 큰 약점은 일단 최초 인증을 통과하고 나면 모든 서버나 사이트에 접속할 수 있다는 것이다. 이를 Single Point of Failure 라 한다. 이러한 치명적인 약점을 보완하기 위해 중요 정보에 대한 접근 및 동작 시 지속적인 인증(Continuos Authentication)을 하도록 되어 있다.&lt;/p&gt;

&lt;h2 id=&quot;opensource&quot;&gt;Opensource&lt;/h2&gt;

&lt;h3 id=&quot;keycloak&quot;&gt;&lt;a href=&quot;https://github.com/keycloak/keycloak&quot;&gt;Keycloak&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://tech.socarcorp.kr/security/2019/07/31/keycloak-sso.html&quot;&gt;사내 SSO(Single Sign-On) 구축하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://subji.github.io/posts/2020/07/08/keycloak1&quot;&gt;MSA 인증 서비스 Keycloak 소개&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tech.osci.kr/2020/04/04/91699412/&quot;&gt;Kubernetes상에서 Keycloak과 Jenkins 그리고 Spinnaker 연동하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@auscunningham/create-a-custom-theme-for-keycloak-8781207be604&quot;&gt;Create a custom theme for Keycloak&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Alfresco/alfresco-keycloak-theme&quot;&gt;Alfresco Keycloak Theme&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;authelia&quot;&gt;&lt;a href=&quot;https://github.com/authelia/authelia&quot;&gt;Authelia&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Features&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Several kind of second factor:
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.authelia.com/features/2fa/security-key&quot;&gt;Security Key (U2F)&lt;/a&gt; with &lt;a href=&quot;https://www.yubico.com/products/yubikey-hardware/yubikey4/&quot;&gt;Yubikey.&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.authelia.com/features/2fa/one-time-password&quot;&gt;Time-based One-Time password&lt;/a&gt; with &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;amp;hl=en&quot;&gt;Google Authenticator&lt;/a&gt;.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.authelia.com/features/2fa/push-notifications&quot;&gt;Mobile Push Notifications&lt;/a&gt; with &lt;a href=&quot;https://duo.com/&quot;&gt;Duo&lt;/a&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Password reset with identity verification using email confirmation.&lt;/li&gt;
  &lt;li&gt;Single-factor only authentication method available.&lt;/li&gt;
  &lt;li&gt;Access restriction after too many authentication attempts.&lt;/li&gt;
  &lt;li&gt;Fine-grained access control per subdomain, user, resource and network.&lt;/li&gt;
  &lt;li&gt;Support of basic authentication for endpoints protected by single factor.&lt;/li&gt;
  &lt;li&gt;Highly available using a remote database and Redis as a highly available KV store.&lt;/li&gt;
  &lt;li&gt;Compatible with Kubernetes ingress-nginx controller out of the box.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hydra&quot;&gt;&lt;a href=&quot;https://github.com/ory/hydra&quot;&gt;Hydra&lt;/a&gt;&lt;/h3&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Development" /><category term="Development" /></entry><entry><title type="html">CHAPTER02: Xcode - 1. 통합개발 환경</title><link href="http://localhost:4000/swift-grammar/2-1/" rel="alternate" type="text/html" title="CHAPTER02: Xcode - 1. 통합개발 환경" /><published>2020-10-03T00:00:00+09:00</published><updated>2020-10-03T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/2-1</id><content type="html" xml:base="http://localhost:4000/swift-grammar/2-1/">&lt;p&gt;이번에 다룰 내용은 툴(Tool)이다. 프로그래밍 환경에서 툴이 차지하는 비중은 상당하다. 얼마나 빠르고 쉽게 개발할 수 있는지가 툴에 달려 있기 때문이다. 그래서 툴에 대해 자세히 알고, 마음대로 다룰 수 있도록 능력을 갖추는 것은 매우 중요하다. 현대 프로그래밍은 상당히 많은 부분을 툴에 의존하는 경향이 있지만, 이는 툴과 프로그래밍 개발이 이제 떼려야 뗄 수 없는 관계에 들어섰다는 증거이기도 하다.&lt;/p&gt;

&lt;p&gt;프로그래밍 과정에서 툴이 갖는 위치와 필요성, 그리고 실무에서 꼭 필요한 통합개발 환경에 대해 살펴보고, 스위프트로 앱을 개발하기 위해 사용해야 할 툴인 Xcode에 대해 알아보고자 한다.&lt;/p&gt;

&lt;p&gt;프로그래밍 경험이 충분하거나 과거에 Xcode를 다루어 본 경험이 있다면 읽지 않아도 좋다. 하지만 Xcode가 낱설거나 새로운 Xcode의 특성을 알아보고 싶다면 이번 장을 통해 Xcode의 사용법을 숙지해 둘 필요가 있다. 좋은 집을 만들기 위해 아무리 완벽한 설계도와 훌륭한 재료가 있다 하더라도 망치와 끌, 정 같은 기본 연장을 숙련되게 사용하지 못한다면 결코 좋은 집을 빠르게 만들 수 없는 것과 같은 이치이다.&lt;/p&gt;

&lt;p&gt;최근 12번째 버전까지 발표된 Xcode는 역사도 길고, 매우 방대한 기능을 갖춘 툴이다. 세세한 내부 구성을 제대로 소개하려면 책 한 권으로도 부족할 정도이다. Xcode의 기본적인 내용과 더불어 앱을 만들 때 꼭 필요한 항목을 중심으로 설명하겠다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;1-통합개발-환경&quot;&gt;1. 통합개발 환경&lt;/h1&gt;

&lt;p&gt;Xcode에 대해 이야기 하기 전에, 먼저 ‘통합개발 환경’ 개념에 대해 알아본다. 외우거나 논리적으로 이해해야 하는 내용은 아니므로 편하게 읽어보면 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;11-통합개발-환경-이전의-프로그래밍&quot;&gt;1.1 통합개발 환경 이전의 프로그래밍&lt;/h2&gt;

&lt;p&gt;최근에 널리 사용되는 프로그래밍 언어 대부분은 개발 생산성을 높이기 위해 여러 가지 기능이 집약된 전용 개발 툴을 제공하거나, 또는 유명한 개발 툴에 플러그인 방식으로 사용할 수 있도록 컴포넌트를 제공한다. 이같은 도구들은 개발을 무척 편리하게 해 줄 뿐만 아니라, 하나의 툴 안에서 개발에 필요한 모든 것을 해결할 수 있도록 All-In-One 형식으로 구성되어 있어, 개발을 위해 여러 개의 툴을 사용할 필요가 없는 것이 장점이다.&lt;/p&gt;

&lt;p&gt;하지만 과거에는 그렇지 않았다. 프로그래머들은 하나의 소프트웨어를 완성하기 위해 용도별로 여러 가지 툴을 바꿔가며 사용하는 과정을 수백 수천 번 반복해야 했다. 대표적으로 C/C++ 언어를 이용하여 소프트웨어를 개발하는 과정을 예로 들어 보자. 먼저 프로그래머가 편집기(메모장이나 vi, vim, emacs 등)에서 소스 코딩을 마치면, 커맨드 창을 열고 GCC 컴파일러에게 이 소스를 컴파일하라는 명령을 입력한다. 컴파일러가 소스 코드를 컴파일하는 과정에서 오류가 발생하면(물론, 이 경우 대부분은 문법 오류거나 오타인 경우가 많다) 그 오류 내용은 화면에 표시된다. 이를 확인한 프로그래머가 잘못된 부분과 원인을 찾아 고친 후 다시 컴파일한다. 이 과정이 수없이 반복된 끝에 드디어 오류 없이 컴파일이 완료되면, 이제 그 결과로 만들어진 파일을 실행해 보는 단계에 접어든다.&lt;/p&gt;

&lt;p&gt;지금까지의 과정에서 발생했던 오류를 컴파일 오류(Compile Error)로 분류하는 반면, 파일을 직접 실행하면서 발생하는 오류는 런타임 오류(Runtime Error)라고 한다. 실행 시점에서 발생하는 오류라는 의미다(컴파일 오류보다 런타임 오류가 훨씬 잡아내기 힘들다).&lt;/p&gt;

&lt;p&gt;런타임 오류가 발생하면 이제부터는 순수하게 경험의 영역이다. 프로그래머가 사용할 수 있는 온갖 수단을 동원해 원인을 찾아내야 한다. 이런 작업을 기계 사이에 끼어 들어가 있는 버그, 즉 벌레는 잡아낸다는 뜻으로 디버깅(Debugging)이라고 부른다. 코드 중간중간에 브레이크 코드나 로그 출력 구문을 집어넣어서 실행 과정 중 어느 단계에서 오류가 발생하는지 알아내는 방법을 많이 사용하지만, 경우에 따라서는 메모리 덤프(Memory Dump)를 떠서 메모리에 입력된 데이터를 분석하기도 한다. 이를 편리하게 해주는 툴인 디버거를 사용하는 경우도 많다. 실무 현장에서는 앞서 설명한 것보다 더 다양한 방법들이 런타임 오류를 찾아내는 데에 동원된다. 소프트웨어를 개발하는 데에 걸리는 시간의 절반 이상이 오류를 수정하는 과정에 사용된다는 것이 일반적인 지론이다.&lt;/p&gt;

&lt;p&gt;이제 오류의 원인을 찾아내었다면 이를 고치기 위해 소스 코드를 다시 수정한다. 수정이 완료되면 커맨드 창을 열어 컴파일하고, 다시 그 결과로 나온 파일을 실행해본다. 먼저 기존의 런타임 오류가 제대로 해결되었는지 확인하고, 새로운 런타임 오류가 발생하지 않는지 체크한다. 실행한 애플리케이션이 원하는 결과를 내어놓을 때까지 이 과정을 무수히 반복하면 드디어 하나의 소프트웨어가 만들어진다.&lt;/p&gt;

&lt;p&gt;개발 과정을 진행하는 동안 개발자들은 소스 코딩과 컴파일, 실행 및 디버깅을 위해 여러 가지 관련 툴들을 번갈아가며 사용해야 했다. 그러다 보니 번거롭기도 하고, 이 과정에서 오류가 발생하는 경우도 생겨서 개발 생산성이 좀처럼 나아지지 않는 문제가 대두하였다. 굳이 무어(Moore, Gordon)의 법칙을 예로 들지 않더라도 하드웨어는 폭발적으로 생산성이 극대화되고 있는 상황에서 소프트웨어의 발전 속도는 이에 따라가지 못하게 된 거다. 이른바 소프트웨어의 위기라고 하는 상황이다. 이를 극복하기 위한 노력의 하나로 소프트웨어의 개발 생산성 향상에 대한 방법이 모색되기 시작했다.&lt;/p&gt;

&lt;h2 id=&quot;12-통합개발-환경의-등장&quot;&gt;1.2 통합개발 환경의 등장&lt;/h2&gt;

&lt;p&gt;개발 생산성을 향상시키기 위한 방법론적 시작은 단순히 소스 코드를 작성하던 편집기에 컴파일러를 연동할 수 있는 기능을 제공하는 것에 불과했다. 편집기에서 소스 코드를 작성한 후 단축키나 정해진 버튼을 클릭하면 연결된 컴파일러를 실행하여 그 결과를 바로바로 콘솔창에 보여주는 수준이었다. 그 전에 편집기와 컴파일러를 서로 연동하는 과정이 필요했다. 그 정도에 만족하고 사용하는 사람들이 있는가 하면, 만족하지 못한 사람들도 많아서 소스 코딩과 컴파일, 실행, 디버깅, 그리고 배포 환경 등의 여러 가지 툴을 하나로 갖춘 통합적인 개발도구의 필요성이 증대되어 갔다.&lt;/p&gt;

&lt;p&gt;이 과정에서 윈도우나 맥 OS, 리눅스의 X-Window, iOS나 안드로이드 등 그래픽 사용자 인터페이스를 기반으로 하는 다양한 운영체제들이 등장하면서, 소프트웨어 개발 시 UI 작업을 좀 더 쉽게 할 수 있는 도구들까지 만들어졌다. 시간이 지나면서 이런 그래픽 기반 도구들 역시 하나의 통합적인 개발 도구에 흡수되어 갔다. 다양한 툴들이 통합된 결과, 소스 코딩부터 디버깅뿐만 아니라 사용자 화면을 직접 그리거나 데이터 구조를 설계하고, 코딩의 편의를 돕는 자동 완성 기능까지 포함된 툴들이 등장하게 되었다. 이른바, 통합개발 환경(Integrated Development Environment, IDE)의 탄생이다.&lt;/p&gt;

&lt;p&gt;통합개발 환경은 프로그래밍 개발과 관련된 모든 작업을 하나의 프로그램 안에서 처리할 수 있도록 개발 환경을 통합적으로 제공해주는 툴로서, 이 툴 이외의 부가적인 툴 설치가 거의 필요하지 않을 뿐만 아니라 내부에 포함된 여러 가지 도구가 서로 연동되기 때문에 개발 생산성을 극대화할 수 있다는 장점이 있다. 현대 프로그래밍에 와서 이들 통합개발 환경이 소프트웨어 개발에 미치는 영향은 무척 지대해서 이제는 IDE 없이 단순히 SDK만으로 상용 소프트웨어를 만든다는 것이 거의 불가능한 일이 되어 버렸다.&lt;/p&gt;

&lt;p&gt;대중적이면서 주류인 언어들은 대부분 완성도 높은 IDE들을 하나 이상 가지고 있는데, 대표적인 것들이 자바 플랫폼 계열의 이클립스(Eclipse), MS 계열의 비주얼스튜디오(Visual Studio), Mac 계열의 Xcode 등이다. 물론 이들 이외에도 훨씬 더 많은 IDE가 공개되어 있으며, 일부는 무료로 제공되지만 일부는 유료로 판매되기도 한다. 잘 알려진 IDE에는 다음과 같은 것들이 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;strong&gt;통합개발 환경&lt;/strong&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;strong&gt;개발사&lt;/strong&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;strong&gt;운영체제&lt;/strong&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;strong&gt;언어&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;이클립스&lt;br /&gt;(Eclipse)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IBM, 이클립스 재단&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Window, Linux, Solaris, Mac OS X, AIX&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;JAVA, C, C++, PHP, JSP, Python&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비주얼 스튜디오&lt;br /&gt;(Visual Studio)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;마이크로 소프트&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Window&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Visual Basic, Visual C++, Visual C, Visual C#, F#&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;델파이&lt;br /&gt;(Delphi)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;코드기어&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Window&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Object Pascal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;엑스코드&lt;br /&gt;(Xcode)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;애플&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Mac OS X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C, C++, Objective-C, &lt;br /&gt;Objective-C++, Java, Cocoa, &lt;br /&gt;Carbon, GNU Pascal, C#, Perl, D&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;넷빈즈&lt;br /&gt;(Net Beans)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;썬 마이크로시스템즈, &lt;br /&gt;넷빈즈 재단&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MS-DOS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;JAVA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제이 디벨로퍼&lt;br /&gt;(J Developer)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;오라클&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Linux, Solaris, Windows, HP-UX, OS-X&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;JAVA, SML, PL/SQL, BPEL, PHP, HTML&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제이 빌더&lt;br /&gt;(J Builder)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;코드 기어&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Window&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;JAVA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;터보 C&lt;br /&gt;(Turbo-C)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;코드 기어&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MS-DOS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C, C++&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 표에 나열된 툴들이 개발 실무 현장에서 많이 사용되는 대표적인 IDE들이다. 그리고 이 중에서 iOS 개발자들이 사용하고, 우리가 실습 과정에서 사용할 툴은 바로 Xcode이다.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER01: 스위프트 - 3. 오브젝티브-C vs 스위프트</title><link href="http://localhost:4000/swift-grammar/1-3/" rel="alternate" type="text/html" title="CHAPTER01: 스위프트 - 3. 오브젝티브-C vs 스위프트" /><published>2020-09-27T00:00:00+09:00</published><updated>2020-09-27T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/1-3</id><content type="html" xml:base="http://localhost:4000/swift-grammar/1-3/">&lt;h1 id=&quot;3-오브젝티브-c-vs-스위프트&quot;&gt;3. 오브젝티브-C vs 스위프트&lt;/h1&gt;

&lt;p&gt;오브젝티브-C는 20여 년 동안 애플의 주력 개발 언어로 사용된 만큼 튼튼한 아키텍처와 검증된 성능을 가지고 있다. 이런 오브젝티브-C를 대체할 목적으로 스위프트가 출현했을 때 많은 사람의 관심은 과연 스위프트가 오브젝티브-C를 대체할 수 있을까였다. 언어를 대체한다는 것은 기존 언어가 담당하던 모든 역할을 처리할 수 있는 역량이 되어야 가능하다. 이런 점에서 스위프트를 이야기할 때 오브젝티브-C와의 비교는 빠질 수 없다. 애플에 의해 탄생한, 형제라면 형제일 수 있는 두 언어 사이의 공통점과 차이점에 대해서 알아보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;파일 통합&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 C를 기초로 하여 만들어진 언어이므로 파일 구조도 C 문법을 따라 헤더 파일과 소스 파일로 구분된다. .h 확장자로 작성되는 헤더 파일은 변수나 상수에 대한 선언, 인터페이스에 대한 정의가 작성되고, .m 확장자로 작성되는 소스 파일은 헤더 파일에서 정의한 인터페이스를 구현하는 내용이 작성된다. 선언과 구현이 분리되는 형태이다. 그러나 스위프트는 헤더 파일과 소수 파일이 모두 .swift 확장자를 갖는 파일 하나로 통합되어있다. 변수나 상수, 각종 객체의 형식에 대한 선언과 실질적인 내용 구현이 모두 하나의 파일에서 이루어진다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;클래스의 정의와 구현&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;클래스를 작성할 때 오브젝티브-C는 헤더 파일에 클래스의 인터페이스를 정의하고, 소스파일에서는 정의된 인터페이스를 구현한다. 그러나 스위프트에서는 클래스의 인터페이스 정의 없이 바로 클래스를 구현하면 된다. 또한 오브젝티브-C는 반드시 클래스 선언 시 반드시 상위 클래스를 상속 받아야 하며, 아무것도 상속받을 필요가 없을 때라도 최상위 클래스인 NSObject를 상속받아야 하지만, 스위프트에서는 상속받아야 할 클래스가 없다면 아무것도 상속받지 않아도 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;상속&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 다중 상속을 지원하지 않지만, 자바의 인터페이스(Interface)에 해당하는 개념인 프로토콜(Protocol)을 정의하여 클래스 객체가 준수해야 할 형식을 제공할 수 있다. 또한 카테고리(Category) 개념을 통해 상속 대신 기존 객체 자체를 직접 확장할 수 있다.&lt;/p&gt;

&lt;p&gt;스위프트도 마찬가지이다. 다중 상속을 지원하지 않으며 프로토콜을 정의할 수있다. 또한, 기존 객체를 직접 확장할 수있도록 Extention이 제공되는데, 이는 오브젝티브-C의 카테고리에 대응하는 개념이다. 단, 그보다는 더 넓고 강력한 개념으로 오브젝티브-C에서 클래스 객체만 확장할 수 있었던 카테고리에 비해 스위프트의 Extention은 클래스, 구조체, 프로토콜 등 대부분 객체에 사용할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;범용 타입&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;개발의 편의와 효율성을 높이기 위해 모든 데이터 타입을 저장할 수 있는 범용 타입 객체가 필요할 때가 있는데, 오브젝티브-C에서는 이와 같은 범용 타입으로 id 타입을 제공한다. id 타입은 모든 타입의 데이터를 저장할 수 있을 뿐만 아니라, 호환성만 보장된다면 저장된 데이터를 어떠한 타입으로든 변환할 수 있는 특성을 가지고 있다. 코코아 프레임워크나 코코아 터치 프레임워크에서는 범용 타입을 이용한 API들이 많이 사용되고 있다.&lt;/p&gt;

&lt;p&gt;스위프트 역시 동일한 코코아 프레임워크나 코코아 터치 프레임워크를 사용하기 때문에, 오브젝티브-C의 id 타입에 대응하는 범용 타입의 객체가 필요하다. 이 때문에 제공되는 것이 Any 타입과 AnyObject 클래스이다. Any는 구조체, 클래스, 열거형, 함수 등 스위프트에서 제공하는 모든 타입의 값을 저장할 수 있는 타입인 반면, AnyObject는 클래스에 한해 범용으로 사용 가능한 데이터 타입이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;메소드 호출&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 스몰토크의 문법을 차용한 결과, 메소드 호출을 메시지 전송 방식으로 처리한다. 즉, 객체의 메소드를 호출하는 대신 객체에 메시지를 보내서 필요한 기능을 처리한다. 객체와 메시지는 공백을 통해 연결되며 대괄호([])를 사용하여 메시지 전송 단위를 감싸서 구분한다. 이런 스몰토크의 문법이 낯설거나 익숙하지 않은 사람들이 많아서 오브젝티브-C를 다룰 때에는 종종 주의가 필요하기도 했다.&lt;/p&gt;

&lt;p&gt;그러나 스위프트는 일반적인 객체지향에서의 메소드 호출 방식을 따른다. 객체와 메소드 사이는 점(.)을 통해 연결되고, 메소드 호출 단위를 감싸는 구분자는 사용하지 않는다. 아래는 오브젝티브-C와 스위프트에서의 메소드 호출 방식 예제이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;오브젝티브-C에서의 메소드 호출
    &lt;div class=&quot;language-objectivec highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;인스턴스명&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;스위프트에서의 메소드 호출
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;인스턴스명&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;incrementBy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;nil의 의미&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C에서는 존재하지 않는 객체에 대한 참조를 위해 nil이라는 상수를 사용한다. nil과 NULL의 차이에 대해 궁굼해 하는 사람들이 있는데, 엄격하게 말해서 오브젝티브-C에서 정의된 nil 상수와 C에서 정의된 NULL 상수 간에 차이는 있지만, 오브젝티브-C 문법에서 두 상수는 기술적으로 혼용할 수 있다. 일반적으로 nil은 클래스 객체를 참조하는 데에 사용되고, NULL은 그 밖에 다른 포인터 자료형에 사용된다.&lt;/p&gt;

&lt;div class=&quot;language-objectivec highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 객체의 빈 참조에 사용되는 nil&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;UIViewController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uvc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 포인터 자료형의 빈 참조에 사용되는 NULL&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sPtr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반면, 스위프트에서 nil은 옵셔널 타입의 기본값으로 사용되며 &lt;strong&gt;‘값이 존재하지 않음’&lt;/strong&gt;을 의마한다. 스위프트에서는 NULL 상수가 정의되어 있지 않다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 옵셔널 타입의 기본값으로 nil이 대입&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;포인터 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 C의 포인터 문법을 그대로 물려받았다. 객체에 대한 인스턴스 변수를 정의할 때에는 항상 포인터를 사용하는 레퍼런스 참조를 기본으로 사용했다. 모든 변수 앞에 포인터를 거의 의무적으로 붙여주다 보니, 오브젝티브-C에서 포인터를 사용한다고는 해도 C 코드를 직접 작성하는 부분을 제외하면 크게 신경 쓸 부분이 없기는 했지만, 그럼에도 포인터를 사용해야 한다는 것은 초보자들에게는 적지 않은 부담으로 작용했다.&lt;/p&gt;

&lt;p&gt;스위프트에서는 이러한 포인터 개념을 제거하여 개발자가 직접 레퍼런스를 참조하지 않도록 하는 대신, 객체의 종류에 따라 컴파일러가 직접 레퍼런스를 참조할 것인지 아니면 객체를 복사할 것인지를 결정한다. 클래스틑 포인터를 사용하지 않아도 자동으로 레퍼런스를 참조하고, 구조체는 객체를 복사하여 사용하는 방식으로 처리된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;객체지향 타입&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝티브-C는 객체지향을 위한 타입으로 클래스를 제공한다. @Interface 어노테이션을 이용하여 형식을 선언하고, @Implementation 어노테이션을 이용하여 실질적인 내용을 구현한다. 이렇게 작성된 클래스를 사용할 때에는 인스턴스를 생성하여 사용한다.&lt;/p&gt;

&lt;p&gt;그러나 스위프트에서는 객체지향용 타입으로 클래스뿐만 아니라 구조체, 열거형까지 제공한다. 이들 객체 타입은 모두 인스턴스를 만들 수 있으며 인스턴스와 관련된 변수, 상수를 속성(property)으로 선언하여 사용할 수 있다. 그뿐만 아니라 이들 객체 타입에 인스턴스 메소드와 타입 메소드를 작성하여 사용할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 클래스 (Class)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SampleClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 구조체 (Structure)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SampleStruct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 열거형 (Enumeration)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SampleEnum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;익명 함수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;현대 프로그래밍 개념에서 익명 함수의 사용은 람다 함수를 사용할 수 잇게 해주는 리스프, 스킴 같은 함수형 프로그래밍 언어로부터 도입되었다고 할 수 있다. 람다 함수는 함수 기반으로 정의되는 코드 내에서 한 번만 사용하면 되는 코드마저 함수로 선언해서 사용해야 하는 번거로움을 피할 수 있게 해줌으로써 코드를 더욱 간결하게 만들어 준다.&lt;/p&gt;

&lt;p&gt;람다 함수는 최근 자바 8에서도 도입되는 등 프로그래밍 언어의 강력한 기능으로 고려되고 있다. 오브젝티브-C에서는 블록(Block)이라는 개념으로 익명 함수를 표현할 수 있었는데, 이 기능이 스위프트에서는 클로저를 이용한 익명 함수 정의 문법으로 제공된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;오류 처리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일반적으로 객체 지향 언어에서 제공하는 오류 처리 기능은 오류 발생이 예상되는 지점에 미리 오류를 검출하는 코드를 작성해두고, 실제로 오류가 발생했을 때 정해진 코드 블록 바깥으로 오류 정보를 던져 처리할 수 있도록 지원하는 방식이다. 오브젝티브-C에서도 오류를 검출하기 위한 기능은 제공되었지만, 이는 읽고 쓸 수 있는 매개변수를 사용하여 오류를 검출해내는 방법이었을 뿐 오류 처리를 위한 구문이 별도로 제공된 것은 아니었다.&lt;/p&gt;

&lt;p&gt;스위프트는 2.0 버전부터 오류를 검출해내고 각 오류에 효과적으로 대응할 수 있도록 전용 구문을 제공하고 있다. 많은 프로그래밍 언어에서 널리 사용하는 Try ~ Catch 구문을 채택한 스위프트는 코드를 실행하는 과정에서 오류가 발생하더라도 프로그램이 중단되는 것을 막아주고, 미리 준비된 대응 구문을 실행하여 효율적으로 오류에 대응할 수 있게 한다.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER01: 스위프트 - 2.스위프트 언어의 특징</title><link href="http://localhost:4000/swift-grammar/1-2/" rel="alternate" type="text/html" title="CHAPTER01: 스위프트 - 2.스위프트 언어의 특징" /><published>2020-09-25T00:00:00+09:00</published><updated>2020-09-25T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/1-2</id><content type="html" xml:base="http://localhost:4000/swift-grammar/1-2/">&lt;h1 id=&quot;2-스위프트-언어의-특징&quot;&gt;2. 스위프트 언어의 특징&lt;/h1&gt;

&lt;p&gt;상대적으로 언어에 대한 진입장벽이 낮고 개발하기 쉬운 자바스크립트나 파이썬, 루비와 같은 동적 바인딩 타입의 언어는 생산성이 좋지만 성능이 부족한 경우가 많고, 성능이 좋은 언어일수록 진입 장벽이 높고 개발하기 어려워 생산성이 낮은 경우가 많다. 이에 비해 스위프트는 개발 생산성과 앱 성능 모두에서 만족할 만한 결과를 가져오는 언어로 포지셔닝되어있다.&lt;/p&gt;

&lt;p&gt;스위프트가 파이썬이나 자바스크립트처럼 동적 바인딩(Dynamic Binding)을 채용하고 있는 언어는 아니다. C, C++, 오브젝티브-C, 자바처럼 정적 바인딩을 채용하고 있다. 비록 데이터 타입 추론 기능에 의해 컴파일러가 알아서 변수와 상수의 타입을 결정하기 때문에 마치 동적 바인딩 언어인 것처럼 착각되기도 하지만, 기본적으로 스위프트는 정적 바인딩 언어이다.&lt;/p&gt;

&lt;p&gt;스위프트는 데이터 타입에 대한 구분이 엄격하다. 스위프트에서 선언된 변수와 상수는 컴파일 단계에서 데이터 타입이 미리 정의되어 있어야 하고, 변수의 데이터 타입이 정의되면 다른 타입으로 변경할 수 없다. 이러한 엄격성을 바탕으로 컴파일러는 타입에 맞지 않는 데이터가 변수에 대입되는 것을 사전에 차단하여 안정성을 높일 수 있다.&lt;/p&gt;

&lt;p&gt;스위프트는 네임스페이스를 사용하여 필요한 객체들으 참조하는데, 일반적으로 프로젝트 전체가 네임스페이스의 범위로 지정된다. 이는 같은 프로젝트 내에 작성된 객체일지라도 오브젝티브-C에서는 참조를 위해 일일이 헤더 파일을 반입해 주어야 했던 것과 다르게, 스위프트에서는 같은 프로젝트 내에 작성된 객체들은 반입 과정 없이 참조할 수 있다는 뜻이다. 이 때문에 스위프트에서 import 구문은 UIKit, Foundation 등의 프레임워크나 라이브러리 정도에만 사용하게 되어 개발 생산성을 향항할 수 있게 되었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;21-스위프트-언어에서-차용하고-있는-주요-기능들&quot;&gt;2.1 스위프트 언어에서 차용하고 있는 주요 기능들&lt;/h2&gt;

&lt;p&gt;세상에 존재하는 수많은 프로그래밍 언어 대부분이 그렇겠지만, 특히 현대에 와서 발표되는 언어 중 전적으로 새로운 언어는 거의 없다고 해도 과언이 아니다. 대부분의 언어는 앞선 시대의 언어에서 아이디어를 차용하여 자신의 것으로 발전시키고, 시간이 지나면 또 다른 언어가 이를 차용하는 과정이 반복된다.&lt;/p&gt;

&lt;p&gt;기술적으로 새롭다고 할 수 있는 스위프트이지만, 사실 알고 보면 다른 언어에서 채택된 개념들을 새로운 이름으로 조합한 것에 지나지 않는다. 이런 관점에서 마국의 IT 전문 저술가 피터 웨이너(Peter Wayner)는 InfoWorld.com에서 애플이 스위프트를 만들면서 주변 언어로부터 차용한 10가지 개념과 특징들에 관해 이야기 하고 있다. 이 글을 인용하여 스위프트의 특성을 다른 언어들과 비교해 보겠다. 다른 언어를 익힌 분들이라면 이 설명을 통해 스위프트의 특징에 대해 더욱 잘 이애할 수 있을 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;딕셔너리(해시 테이블) - 자바스크립트, 파이썬&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바스크립트 프로그래머들은 대괄호 구문을 이용해 값을 배열로 만들거나 문자열을 입력받는데, 이것이 해시 테이블 역할을 한다. 스위프트도 마찬가지이다. 대괄호를 사용하여 해시 테이블을 만들 수 있다. 애플에서는 이것을 ‘딕셔너리(Dictionaries)’라고 부르며, 초기화할 수 있는 구문을 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;airports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?]()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;airports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ICN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Inchon International Airport&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// If close &quot;Inchon International Airport&quot;, then delete it&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;airports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ICN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ICN has now benn removed from the dictionary&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 타입 추론 - 함수형 프로그래밍 언어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그래머 관점에서 변수를 특정 데이터 형식으로 강제하면 코드를 실행해 보기 전에 버그를 미리 잡을 수 있어 효율적이다. 컴파일러가 데이터 형식을 확인하고 비호환성이 발견되면 오류를 검출해주기 때문이다. 편리함을 추구하는 프로그래밍에서 모든 변수마다 데이터 형식을 일일이 지정하는 고생을 감수할 사람은 그다지 많지 않다.&lt;/p&gt;

&lt;p&gt;최근의 우수한 컴파일러들은 데이터로부터 스스로 형식을 추론할 수 있으므로 컴파일러가 알아서 변수에 데이터 형식을 지정할 수 있게 되었다. 이러한 움직임은 ML과 같은 함수형 언어부터 시작 됐으며, 이후 하스켈, 스칼라, 오파 등의 언어에도 등장했다. 마이크로소프트까지도 이같은 추론 기능을 닷넷 프레임워크에 추가한 만큼 이제는 주류 기능이라고 할 만하다. 데이터 타입은 강제하지만, 데이터 타입을 생략할 수 있는 스위프트 컴파일러의 발전 덕분에 iOS 개발자들도 이제 코드 입력에 드는 수고를 조금은 덜 수 있게 되었다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;meaningOfLife&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// meaningOfLife is inferred to be of type Int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;자동 참조(가비지 콜렉터 비슷) - 자바, C#, 오브젝티브-C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가비지 콜렉터는 메모리를 탐색하면서 더는 사용되지 않는 메모리 영역을 회수하는 자동 루틴으로, GC라고 불리기도 한다. 자바와 C# 프로그래머들은 가비지 콜렉터를 무척 좋아하지만, 때로는 가비지 콜렉터 때문에 프로그램이 잠깐 멈추는 현상이 발생해 스트레스를 받기도 한다. 가비지 콜렉터의 결과로 가용 메모리가 다시 늘어나는 장점이 있는 반면, 가비지 콜렉터를 실핼하는 동안 프로세스는 원활한 진행을 방해받는다는 단점도 있다.&lt;/p&gt;

&lt;p&gt;스위프트는 자동 참조 카운트(ARC - Auto Referencing Counter)를 사용하는데, 이는 오브젝티브-C 사용자들 사이에서 널리 사용된 것과 비슷한 솔루션이다. 이 기능은 오브젝티브-C에서 물려받았다고 할 만한 기능이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;부호 있는 정수와 부호 없는 정수 - C#과 오브젝티브-C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;좋은 시스템 프로그램이란 바이트 레벨에서 작동하는 프로그랴ㅐㅁ을 의미하는 경우가 많다. 자바와 같은 일부 추상적 언어는 부호 없는 정수의 복잡성을 회피했지만, C# 언어는 이를 수용했다. 스위프트 역시 1, 2, 4, 8바이트의 부호 없는 정수와 부호 있는 정수를 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;pink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;UInt32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xCC6699&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;redComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xFF0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// redComponent is 0xCC, or 204&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;greenComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x00FF00&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// greenComponent is 0x66, or 102&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;blueComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000FF&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// blueComponent is 0x99, or 153&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;클로저(Closure) - 리스프와 스킴에서 자바스크립트까지&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바스크립트 프로그래머는 소량의 코드를 묶어서 함수처럼 전달하는 클로저를 사용할 수 있다. 이러한 클로저는 람다 함수 아이디어를 개발한 리스프, 스킴과 같은 언어에서 가져온 것이다. 스위프트는 클로저를 제공할 뿐만 아니라 함수를 1급 객체로 간주, 인자값으로 함수 자체를 전달하는 기능을 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;numbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;멀티 라인 쿼우팅(Multi-Line Quoting)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파이썬 프로그래머들은 세 개의 따옴표를 겹친 “”” ~ “”” 를 이용해 여러 줄의 문자열을 간편하게 입력해 왔다. 줄바꿈이나 범위에 삼관없이 “&quot;”로 시작하고 “&quot;”로 닫기만 하면 그 안에 표현된 모든 문자열(공백까지 포함한)이 그대로 처리된다는 장점 덕분에 긴 문자열을 입력할 때 요긴하게 사용되어 왔다. 스위프트 4 버전에서는 파이썬의 이와 같은 멀티 라인 쿼우팅 문법을 거의 그대로 도입했다. 파이썬처럼 큰따옴표 세 개 겹친 “&quot;”로 문자열의 시작과 끝을 나타내는 방식으로 우리는 여러 줄의 문자열을 간편하게 입력할 수 있게 되었다. 이는 여러 줄의 문자열을 입력하기 위해 더이상 문자열 내부에 인위적인 줄바꿈 문자(‘\n’)를 넣어주지 않아도 된다는 뜻이다.&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;query&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
    SELECT member_id, member_name, member_level, nick_name
    FROM member
    WHERE login_id = ? AND password = ?
&quot;&quot;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;22-구조적-특징&quot;&gt;2.2 구조적 특징&lt;/h2&gt;

&lt;p&gt;스위프트의 발표 자료에 따른 스위프트 언어의 구조적 특징은 여섯 가지 정도로 구분된다. 이들 특성은 스위프트가 지향하는 방향성이기도 하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;빠름(Fast)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스위프트는 매우 빠른 언어로, 복합정렬 연산에서 오브젝티브-C보다 빠른 성능을 나타낸다. 애플에서는 고성능 앱을 만들기 위해 GCC 대신 LLVM 컴파일러를 사용해오고 있는데, 이 컴파일러에서 제공하는 코드 최적화기를 사용하여 소스 컴파일과 최적화를 수행함으로써 스위프트의 성능을 극대화할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;설계에 의한 안정성(Safety by Design)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스위프트는 언어 차원에서 안전성을 담보하기 위한 설계로 여러 장치를 해 두었다. 변수나 상수는 반드시 선언한 후에 사용하도록 강제하였으며 타입 추론 기능에 의해 변수의 초기값을 기준으로 타입을 정의함으로써 데이터 입력에 대한 안전성을 높이고자 하였다. 배열과 정수는 오버플로우에 대비하여 확인하며, 특히 개발자가 정의하지 않은 배열 값에 승인하지 않은 값들이 주입될 수 없도록 Array bounds check 기능을 추가하였다.&lt;/p&gt;

&lt;p&gt;여기에 더하여 스위프트는 포인터에 직접 접근하는 시도를 차단하고, 클래스를 통해 간접적으로만 레퍼런스를 참조할 수 있도록 제한했다. 스위프트는 ARC를 이용하여 자동으로 메모리를 관리하므로 메모리 누수 현상에 대한 안전성도 높일 수 있다. 이처럼 설게 수준에서 안전성을 구현하는 것이 스위프트의 구조적 특징 중 하나이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;현대적(Modern)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스위프트는 파이썬 언어에 기반을 둔 읽고 쓰기 쉬운 문법을 채택하였다. 그 결과, 코드 작성이나 디버깅, 유지보수 과정에서 기존의 오브젝티브-C보다 훨씬 적은 양의 코드가 사용된다. 손쉬운 유지보수를 위해 헤더 파일 사용 대신 메인 파일에 통합하여 코드를 작성할 수 있도록 섳계되었다. 스위프트는 옵셔널(Optional), 제네릭(Generics), 클로저(Closure), 튜플(Tuple)뿐만 아니라 현대 프로그래밍 언어의 특성까지도 상당수 포함하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;상호반응(Interactive)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Xcode 6 버전부터 애플은 스위프트 코드의 프로토타이핑을 위해 플레이그라운드 편집기를 제공한다. 스위프트 코드를 작성하고, 그 결과와 메모리 스택 등의 정보 확인을 즉시 확인할 수 있어 상호반응적으로 코드를 작성할 수 있으며 디버깅도 무척 쉽다. 이러한 특징은 스위프트를 이용한 코딩의 효율성을 한껏 높였다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전한 플랫폼(Complete Platform)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;단순히 보조적인 수준으로만 스위프트를 사용할 수 있는 것이 아니라, 코코아 프레임워크나 코코아 터치 프레임워크의 모든 API를 스위프트로 호출할 수 있다. 오브젝티브-C로 작성되었던ㄴ 핵심 프레임워크의 모든 라인이 스위프트 언어를 이용하여 거의 모두 재작성되었고, 이를 이용하면 오브젝티브-C 코드에 의존하지 않고도 프로그램을 작성할 수 있다는 것은 애플의 발표에 의해 널리 알려진 사실이다. 스위프트만으로 하나의 완전한 앱을 만들 수 있다는 의미이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;통홥(Unified)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스위프트는 C 언어나 오브젝티브-C 언어를 완전히 대체할 수 있다. 스위프트는 객체지향 언어의 특성을 모두 제공하는 동시에 자료형과 흐름 제어, 연산자 같은 저수준 언어의 기본 요소들도 모두 포함한다. 하나의 앱 프로젝트에서 오브젝티브-C와 함께 사용할 수 있도록 통합성도 지니고 있다. 오브젝티브-C 객체를 스위프트에서 참조할 수 있으며, 각각의 화면별로 오브젝티브-C 또는 스위프트로 나누어 작성하는 것도 가능하디.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">CHAPTER01: 스위프트 - 1.스위프트 언어의 탄생과 배경</title><link href="http://localhost:4000/swift-grammar/1-1/" rel="alternate" type="text/html" title="CHAPTER01: 스위프트 - 1.스위프트 언어의 탄생과 배경" /><published>2020-09-23T00:00:00+09:00</published><updated>2020-09-23T00:00:00+09:00</updated><id>http://localhost:4000/swift-grammar/1-1</id><content type="html" xml:base="http://localhost:4000/swift-grammar/1-1/">&lt;h1 id=&quot;1-스위프트-언어의-탄생과-배경&quot;&gt;1. 스위프트 언어의 탄생과 배경&lt;/h1&gt;

&lt;p&gt;스위프트(Swift)는 애플이 2014 세계 개발자 대회(WWDC)에서 발표한 iOS나 macOS 앱 개발의 새로운 언어이다. 그동안 앱을 개발하는 데에 사용되던 오브젝티브-C를 대체할 목적으로 발표되었다.&lt;/p&gt;

&lt;p&gt;애플의 이전 주력 언어였던 오프젝티브-C는 C언어를 기초로 하여 스몰토크의 메시지 전달 개념과 객체지향 개념을 반영한, 객체지향형 C 언어이다. C 언어의 장점이자 단점인 포인터 개념은 오브젝티브-C를 강력한 언어로 만들어주긴 했지만, 처음 접근하는 사람에게는 그만큼 높은 장벽으로 작용한 것도 사실이다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어를 익히는 데에만 수개월이 걸리다 보니, 앱을 개발하기 위해 언어만 죽어라 익히다 포기하는 일이 잦았다. 언어 자체가 어렵다 보니 앱의 다양한 기능에 집중해야 할 개발자가 성능 개선에 더 많은 노력과 시간을 소모하는 현상을 가져왔다.&lt;/p&gt;

&lt;p&gt;애플은 앱 개발자들이 기능적으로 더 다양한 종류의 앱을 만들기를 원했다. 개방성을 강력한 무기로 내세우는 구글의 안드로이드에 점차 스마트폰 시장을 잠식당하고 있는 상황에서, 어떤 방식으로든 다시 앱스토어의 콘텐츠 다양성을 무기로 하는 시장 지배력을 갖추고 싶어했다. 현재 개발자뿐만 아니라 아이디어를 가진 많은 잠재적 개발자들까지 마음만 먹으면 손쉽게 앱을 구현할 수 있는 환경을 만들어주는 것이 당연한 과제였다.&lt;/p&gt;

&lt;p&gt;이러한 목적에 맞추어 기능이 아니라 성능에 관련된 많은 부분, 특히 코드 최적화나 메모리 관리, 성능 관리 등의 기술 경험 기반 개발 이슈를 시스템이 전담하여 개발자들의 부담을 덜어주는 것이 가장 중요했다. 아이디어를 가진 많은 사람이 기술에 제한받지 않고 마음껏 아이디어를 구현할 수 있는 손쉬운 개발 환경을 만들어 주고 싶었던 것이다.&lt;/p&gt;

&lt;p&gt;이런 목표를 위해서 만들어진 언어 플랫폼이 바로 스위프트이다. 스위프트는 기존의 오브젝티브-C가 C 언어로부터 가져온 저수준 프로그래밍을 자동 관리 영역으로 대체했고, 생소한 문법이지만 객체지향을 위해 사용할 수 밖에 없었던 스몰토크의 메시지 문법을 사람들에게 익숙한 자바, 파이썬, C#의 문법으로 바꾸었으며, 오브젝티브-C와 호환까지 가능하도록 설계되는 등 여러 가지 언어적 강점을 지녔다.&lt;/p&gt;

&lt;p&gt;오브젝티브-C가 고급 개발자를 대상으로 사용된 언어라면 스위프트는 개발에 갓 입문하는 사람들까지 무리 없이 사용할 수 있는 언어이다. 그 대표적인 기능이 바로 인터랙티브 플레이그라운드이다.&lt;/p&gt;

&lt;p&gt;직관적으로 코드를 작성하여 그 결과까지 볼 수 있는 플레이그라운드는 왼쪽의 편집 창에서 코드를 작성하면 중간 결과물을 보여줄 뿐만 아니라 즉석에서 컴파일하여 처리 결과까지 제공한다. 단순히 텍스트 결과를 나타내는 것만이 아니다. 반복적인 증감값의 경우 그래프를 통해 직관적인 결과를 볼 수 있도록 처리해 주며, 필요에 따라 다양한 멀티미디어 객체를 사용하여 풍부한 사용자 정보를 제공해 주기도 한다. 직관적인 사용자 인터페이스를 통해 쉬운 접근을 추구하는 애플의 철학이 반영된 결과물이다.&lt;/p&gt;

&lt;p&gt;기술적인 관점에서 스위프트는 애플의 메인 프레임워크인 코코아 프레임워크와 코코아 터치 프레임워크 모두 사용할 수 있다. LLVM 컴파일러, 옵티마이저, 오토백터링, ARC 메모리 관리, 런타임 환경 등을 기존 언어의 개발 환경과 거의 동일하게 사용할 수 있다는 장점도 있다. 이처럼 다양한 강점을 통해 스위프트는 점차 iOS 앱 개발의 강력한 플랫폼 언어로서 자리매김하고 있다.&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="Swift-Grammar" /><category term="Swift" /><category term="Swift-Grammar" /><category term="꼼곰한 재은 씨의 스위프트:문법편" /><category term="이재은" /><category term="루비페이퍼" /><category term="ISBN:979-11-86710-23-4" /><summary type="html">스위프트 문법 스터디</summary></entry><entry><title type="html">[git] 버전 관리 무시 목록(.gitignore) 설정</title><link href="http://localhost:4000/git/1/" rel="alternate" type="text/html" title="[git] 버전 관리 무시 목록(.gitignore) 설정" /><published>2020-08-12T00:00:00+09:00</published><updated>2020-08-12T00:00:00+09:00</updated><id>http://localhost:4000/git/1</id><content type="html" xml:base="http://localhost:4000/git/1/">&lt;h1 id=&quot;gitignore&quot;&gt;.gitignore&lt;/h1&gt;

&lt;h2 id=&quot;1-위험성&quot;&gt;1. 위험성&lt;/h2&gt;
&lt;p&gt;특정 파일은 git에서 버전 관리 대상에서 제외해야 합니다.&lt;/p&gt;

&lt;p&gt;프로젝트를 업로드할 때 개인키가 프로젝트 폴더내에 있을 수 있고, 이런 중요한 설정 정보는 git 저장소에 추가하지 말아야 합니다.&lt;/p&gt;

&lt;p&gt;이로인해서 해킹에 대상이 될 수 있고, 심각한 피해를 입을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;2-해결방안&quot;&gt;2. 해결방안&lt;/h2&gt;
&lt;p&gt;git 에는 이러한 문제를 방지하기 위한 무시 목록을 작성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;.gitignore 에 작성된 파일은 git add 명령시 제외됩니다.&lt;/p&gt;

&lt;h2 id=&quot;3-작성법&quot;&gt;3. 작성법&lt;/h2&gt;
&lt;p&gt;.gitignore 의 각 라인에 무시할 파일 또는 디렉토리의 패턴을 적습니다.&lt;/p&gt;

&lt;p&gt;여러 파일을 한번에 지정할 경우 * 을 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jdbc.properties
*.class
*.jar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 작성하면 git add 명령어를 실행했을 때 jdbc.properties 파일을 제외하며, .class와 .jar 확장자를 가진 파일을 모두 무시합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이미 추가되어 버전 관리중인 파일에는 영향을 미치지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;4-응용&quot;&gt;4. 응용&lt;/h2&gt;
&lt;p&gt;만약 .gitignore 목록에 있는 파일을 추가해야 할 경우 -f 옵션을 이용해 추가할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add -f jdbc.properties
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;.gitignore 에 설정한 내용은 하위 디렉토리에도 동일하게 적용됩니다.&lt;/p&gt;

&lt;p&gt;만약 특정 하위 디렉토리가 다른 ignore 를 적용해야 할 경우 해당 디렉토리에 .gitignore 을 새로 만들어줍니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*
!jdbc.properties
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 .gitignore 을 새로 만들어 config 폴더에 넣을 경우, 기본적으로 config 의 모든 파일을 무시하면서 jdbc.properties 라는 파일은 버전을 관리합니다. !는 이전의 ignore 패턴을 무효화 하는 문자열입니다.&lt;/p&gt;

&lt;p&gt;만약 파일명에 ! 가 들어갈 경우 escape 문자인 \ 를 ! 앞에 붙여줍니다.&lt;/p&gt;

&lt;h2 id=&quot;5-gitignoreio&quot;&gt;5. gitignore.io&lt;/h2&gt;
&lt;p&gt;사용하는 운영체제, IDE, 언어마다 추가하는 패턴들이 있으며 이를 매번 기억하여 입력하는 것은 매우 귀찮습니다.&lt;/p&gt;

&lt;p&gt;이런 귀찮은 일을 대신 처리해주는 &lt;a href=&quot;https://www.toptal.com/developers/gitignore&quot;&gt;gitignore.io&lt;/a&gt; 라는 서비스가 있습니다.&lt;/p&gt;

&lt;p&gt;일반적으로 사용되는 무시 패턴을 해당 서비스를 통해 작성하고, 추가적으로 필요한 부분만 무시 목록을 작성하면 편리하게 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;6-참고&quot;&gt;6. 참고&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/docs/gitignore&quot;&gt;https://git-scm.com/docs/gitignore&lt;/a&gt;&lt;/p&gt;</content><author><name>SANGHYUK LEE</name></author><category term="git" /><category term="git" /></entry></feed>